{"version":3,"sources":["node_modules/jquery/dist/jquery.js","node_modules/phoenix/priv/static/phoenix.js","node_modules/phoenix_html/priv/static/phoenix_html.js","node_modules/process/browser.js","web/static/js/3d-lines-animation.js","web/static/js/app.js","web/static/js/canvas-renderer.js","web/static/js/projector.js","web/static/js/socket.js","web/static/js/three.min.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClhUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC55CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7LA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAtJA;AAAA;CCAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlBA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA/8BA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA9yBA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAvEA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA3uLA;AAAA","file":"priv/static/js/app.js","sourcesContent":["\nrequire.register(\"jquery/dist/jquery.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"jquery\");\n  (function() {\n    /*!\n * jQuery JavaScript Library v3.2.1\n * https://jquery.com/\n *\n * Includes Sizzle.js\n * https://sizzlejs.com/\n *\n * Copyright JS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2017-03-20T18:59Z\n */\n( function( global, factory ) {\n\n\t\"use strict\";\n\n\tif ( typeof module === \"object\" && typeof module.exports === \"object\" ) {\n\n\t\t// For CommonJS and CommonJS-like environments where a proper `window`\n\t\t// is present, execute the factory and get jQuery.\n\t\t// For environments that do not have a `window` with a `document`\n\t\t// (such as Node.js), expose a factory as module.exports.\n\t\t// This accentuates the need for the creation of a real `window`.\n\t\t// e.g. var jQuery = require(\"jquery\")(window);\n\t\t// See ticket #14549 for more info.\n\t\tmodule.exports = global.document ?\n\t\t\tfactory( global, true ) :\n\t\t\tfunction( w ) {\n\t\t\t\tif ( !w.document ) {\n\t\t\t\t\tthrow new Error( \"jQuery requires a window with a document\" );\n\t\t\t\t}\n\t\t\t\treturn factory( w );\n\t\t\t};\n\t} else {\n\t\tfactory( global );\n\t}\n\n// Pass this if window is not defined yet\n} )( typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\n\n// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n// enough that all such attempts are guarded in a try block.\n\"use strict\";\n\nvar arr = [];\n\nvar document = window.document;\n\nvar getProto = Object.getPrototypeOf;\n\nvar slice = arr.slice;\n\nvar concat = arr.concat;\n\nvar push = arr.push;\n\nvar indexOf = arr.indexOf;\n\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar fnToString = hasOwn.toString;\n\nvar ObjectFunctionString = fnToString.call( Object );\n\nvar support = {};\n\n\n\n\tfunction DOMEval( code, doc ) {\n\t\tdoc = doc || document;\n\n\t\tvar script = doc.createElement( \"script\" );\n\n\t\tscript.text = code;\n\t\tdoc.head.appendChild( script ).parentNode.removeChild( script );\n\t}\n/* global Symbol */\n// Defining this global in .eslintrc.json would create a danger of using the global\n// unguarded in another place, it seems safer to define global only for this module\n\n\n\nvar\n\tversion = \"3.2.1\",\n\n\t// Define a local copy of jQuery\n\tjQuery = function( selector, context ) {\n\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\treturn new jQuery.fn.init( selector, context );\n\t},\n\n\t// Support: Android <=4.0 only\n\t// Make sure we trim BOM and NBSP\n\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n\n\t// Matches dashed string for camelizing\n\trmsPrefix = /^-ms-/,\n\trdashAlpha = /-([a-z])/g,\n\n\t// Used by jQuery.camelCase as callback to replace()\n\tfcamelCase = function( all, letter ) {\n\t\treturn letter.toUpperCase();\n\t};\n\njQuery.fn = jQuery.prototype = {\n\n\t// The current version of jQuery being used\n\tjquery: version,\n\n\tconstructor: jQuery,\n\n\t// The default length of a jQuery object is 0\n\tlength: 0,\n\n\ttoArray: function() {\n\t\treturn slice.call( this );\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\n\t\t// Return all the elements in a clean array\n\t\tif ( num == null ) {\n\t\t\treturn slice.call( this );\n\t\t}\n\n\t\t// Return just the one element from the set\n\t\treturn num < 0 ? this[ num + this.length ] : this[ num ];\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems ) {\n\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\teach: function( callback ) {\n\t\treturn jQuery.each( this, callback );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map( this, function( elem, i ) {\n\t\t\treturn callback.call( elem, i, elem );\n\t\t} ) );\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( slice.apply( this, arguments ) );\n\t},\n\n\tfirst: function() {\n\t\treturn this.eq( 0 );\n\t},\n\n\tlast: function() {\n\t\treturn this.eq( -1 );\n\t},\n\n\teq: function( i ) {\n\t\tvar len = this.length,\n\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || this.constructor();\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array's method, not like a jQuery method.\n\tpush: push,\n\tsort: arr.sort,\n\tsplice: arr.splice\n};\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[ 0 ] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\n\t\t// Skip the boolean and the target\n\t\ttarget = arguments[ i ] || {};\n\t\ti++;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !jQuery.isFunction( target ) ) {\n\t\ttarget = {};\n\t}\n\n\t// Extend jQuery itself if only one argument is passed\n\tif ( i === length ) {\n\t\ttarget = this;\n\t\ti--;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\n\t\t// Only deal with non-null/undefined values\n\t\tif ( ( options = arguments[ i ] ) != null ) {\n\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tsrc = target[ name ];\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\n\t\t\t\t\t( copyIsArray = Array.isArray( copy ) ) ) ) {\n\n\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && Array.isArray( src ) ? src : [];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && jQuery.isPlainObject( src ) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\njQuery.extend( {\n\n\t// Unique for each copy of jQuery on the page\n\texpando: \"jQuery\" + ( version + Math.random() ).replace( /\\D/g, \"\" ),\n\n\t// Assume jQuery is ready without the ready module\n\tisReady: true,\n\n\terror: function( msg ) {\n\t\tthrow new Error( msg );\n\t},\n\n\tnoop: function() {},\n\n\tisFunction: function( obj ) {\n\t\treturn jQuery.type( obj ) === \"function\";\n\t},\n\n\tisWindow: function( obj ) {\n\t\treturn obj != null && obj === obj.window;\n\t},\n\n\tisNumeric: function( obj ) {\n\n\t\t// As of jQuery 3.0, isNumeric is limited to\n\t\t// strings and numbers (primitives or objects)\n\t\t// that can be coerced to finite numbers (gh-2662)\n\t\tvar type = jQuery.type( obj );\n\t\treturn ( type === \"number\" || type === \"string\" ) &&\n\n\t\t\t// parseFloat NaNs numeric-cast false positives (\"\")\n\t\t\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n\t\t\t// subtraction forces infinities to NaN\n\t\t\t!isNaN( obj - parseFloat( obj ) );\n\t},\n\n\tisPlainObject: function( obj ) {\n\t\tvar proto, Ctor;\n\n\t\t// Detect obvious negatives\n\t\t// Use toString instead of jQuery.type to catch host objects\n\t\tif ( !obj || toString.call( obj ) !== \"[object Object]\" ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tproto = getProto( obj );\n\n\t\t// Objects with no prototype (e.g., `Object.create( null )`) are plain\n\t\tif ( !proto ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Objects with prototype are plain iff they were constructed by a global Object function\n\t\tCtor = hasOwn.call( proto, \"constructor\" ) && proto.constructor;\n\t\treturn typeof Ctor === \"function\" && fnToString.call( Ctor ) === ObjectFunctionString;\n\t},\n\n\tisEmptyObject: function( obj ) {\n\n\t\t/* eslint-disable no-unused-vars */\n\t\t// See https://github.com/eslint/eslint/issues/6125\n\t\tvar name;\n\n\t\tfor ( name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\ttype: function( obj ) {\n\t\tif ( obj == null ) {\n\t\t\treturn obj + \"\";\n\t\t}\n\n\t\t// Support: Android <=2.3 only (functionish RegExp)\n\t\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\t\tclass2type[ toString.call( obj ) ] || \"object\" :\n\t\t\ttypeof obj;\n\t},\n\n\t// Evaluates a script in a global context\n\tglobalEval: function( code ) {\n\t\tDOMEval( code );\n\t},\n\n\t// Convert dashed to camelCase; used by the css and data modules\n\t// Support: IE <=9 - 11, Edge 12 - 13\n\t// Microsoft forgot to hump their vendor prefix (#9572)\n\tcamelCase: function( string ) {\n\t\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n\t},\n\n\teach: function( obj, callback ) {\n\t\tvar length, i = 0;\n\n\t\tif ( isArrayLike( obj ) ) {\n\t\t\tlength = obj.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( i in obj ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\t// Support: Android <=4.0 only\n\ttrim: function( text ) {\n\t\treturn text == null ?\n\t\t\t\"\" :\n\t\t\t( text + \"\" ).replace( rtrim, \"\" );\n\t},\n\n\t// results is for internal usage only\n\tmakeArray: function( arr, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( arr != null ) {\n\t\t\tif ( isArrayLike( Object( arr ) ) ) {\n\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\ttypeof arr === \"string\" ?\n\t\t\t\t\t[ arr ] : arr\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tpush.call( ret, arr );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, arr, i ) {\n\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\n\t},\n\n\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t// push.apply(_, arraylike) throws on ancient WebKit\n\tmerge: function( first, second ) {\n\t\tvar len = +second.length,\n\t\t\tj = 0,\n\t\t\ti = first.length;\n\n\t\tfor ( ; j < len; j++ ) {\n\t\t\tfirst[ i++ ] = second[ j ];\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t},\n\n\tgrep: function( elems, callback, invert ) {\n\t\tvar callbackInverse,\n\t\t\tmatches = [],\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tcallbackExpect = !invert;\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tcallbackInverse = !callback( elems[ i ], i );\n\t\t\tif ( callbackInverse !== callbackExpect ) {\n\t\t\t\tmatches.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t},\n\n\t// arg is for internal usage only\n\tmap: function( elems, callback, arg ) {\n\t\tvar length, value,\n\t\t\ti = 0,\n\t\t\tret = [];\n\n\t\t// Go through the array, translating each of the items to their new values\n\t\tif ( isArrayLike( elems ) ) {\n\t\t\tlength = elems.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Go through every key on the object,\n\t\t} else {\n\t\t\tfor ( i in elems ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Flatten any nested arrays\n\t\treturn concat.apply( [], ret );\n\t},\n\n\t// A global GUID counter for objects\n\tguid: 1,\n\n\t// Bind a function to a context, optionally partially applying any\n\t// arguments.\n\tproxy: function( fn, context ) {\n\t\tvar tmp, args, proxy;\n\n\t\tif ( typeof context === \"string\" ) {\n\t\t\ttmp = fn[ context ];\n\t\t\tcontext = fn;\n\t\t\tfn = tmp;\n\t\t}\n\n\t\t// Quick check to determine if target is callable, in the spec\n\t\t// this throws a TypeError, but we will just return undefined.\n\t\tif ( !jQuery.isFunction( fn ) ) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Simulated bind\n\t\targs = slice.call( arguments, 2 );\n\t\tproxy = function() {\n\t\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t\t};\n\n\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\t\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\t\treturn proxy;\n\t},\n\n\tnow: Date.now,\n\n\t// jQuery.support is not used in Core but other projects attach their\n\t// properties to it so it needs to exist.\n\tsupport: support\n} );\n\nif ( typeof Symbol === \"function\" ) {\n\tjQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];\n}\n\n// Populate the class2type map\njQuery.each( \"Boolean Number String Function Array Date RegExp Object Error Symbol\".split( \" \" ),\nfunction( i, name ) {\n\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n} );\n\nfunction isArrayLike( obj ) {\n\n\t// Support: real iOS 8.2 only (not reproducible in simulator)\n\t// `in` check used to prevent JIT error (gh-2145)\n\t// hasOwn isn't used here due to false negatives\n\t// regarding Nodelist length in IE\n\tvar length = !!obj && \"length\" in obj && obj.length,\n\t\ttype = jQuery.type( obj );\n\n\tif ( type === \"function\" || jQuery.isWindow( obj ) ) {\n\t\treturn false;\n\t}\n\n\treturn type === \"array\" || length === 0 ||\n\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n}\nvar Sizzle =\n/*!\n * Sizzle CSS Selector Engine v2.3.3\n * https://sizzlejs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2016-08-08\n */\n(function( window ) {\n\nvar i,\n\tsupport,\n\tExpr,\n\tgetText,\n\tisXML,\n\ttokenize,\n\tcompile,\n\tselect,\n\toutermostContext,\n\tsortInput,\n\thasDuplicate,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = \"sizzle\" + 1 * new Date(),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// Instance methods\n\thasOwn = ({}).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpush_native = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\t// Use a stripped-down indexOf as it's faster than native\n\t// https://jsperf.com/thor-indexof-vs-for/5\n\tindexOf = function( list, elem ) {\n\t\tvar i = 0,\n\t\t\tlen = list.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( list[i] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\n\t// Regular expressions\n\n\t// http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\n\t// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\tidentifier = \"(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+\",\n\n\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\n\t\t// Operator (capture 2)\n\t\t\"*([*^$|!~]?=)\" + whitespace +\n\t\t// \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace +\n\t\t\"*\\\\]\",\n\n\tpseudos = \":(\" + identifier + \")(?:\\\\((\" +\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\t\t// 2. simple (capture 6)\n\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\t\t// 3. anything else (capture 2)\n\t\t\".*\" +\n\t\t\")\\\\)|)\",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\n\n\trattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n\tmatchExpr = {\n\t\t\"ID\": new RegExp( \"^#(\" + identifier + \")\" ),\n\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + identifier + \")\" ),\n\t\t\"TAG\": new RegExp( \"^(\" + identifier + \"|[*])\" ),\n\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t},\n\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trsibling = /[+~]/,\n\n\t// CSS escapes\n\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\n\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t// NaN means non-codepoint\n\t\t// Support: Firefox<24\n\t\t// Workaround erroneous numeric interpretation of +\"0x\"\n\t\treturn high !== high || escapedWhitespace ?\n\t\t\tescaped :\n\t\t\thigh < 0 ?\n\t\t\t\t// BMP codepoint\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t},\n\n\t// CSS string/identifier serialization\n\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\n\trcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n\tfcssescape = function( ch, asCodePoint ) {\n\t\tif ( asCodePoint ) {\n\n\t\t\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n\t\t\tif ( ch === \"\\0\" ) {\n\t\t\t\treturn \"\\uFFFD\";\n\t\t\t}\n\n\t\t\t// Control characters and (dependent upon position) numbers get escaped as code points\n\t\t\treturn ch.slice( 0, -1 ) + \"\\\\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + \" \";\n\t\t}\n\n\t\t// Other potentially-special ASCII characters get backslash-escaped\n\t\treturn \"\\\\\" + ch;\n\t},\n\n\t// Used for iframes\n\t// See setDocument()\n\t// Removing the function wrapper causes a \"Permission Denied\"\n\t// error in IE\n\tunloadHandler = function() {\n\t\tsetDocument();\n\t},\n\n\tdisabledAncestor = addCombinator(\n\t\tfunction( elem ) {\n\t\t\treturn elem.disabled === true && (\"form\" in elem || \"label\" in elem);\n\t\t},\n\t\t{ dir: \"parentNode\", next: \"legend\" }\n\t);\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\tpreferredDoc.childNodes\n\t);\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\t\t\t// Can't trust NodeList.length\n\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar m, i, elem, nid, match, groups, newSelector,\n\t\tnewContext = context && context.ownerDocument,\n\n\t\t// nodeType defaults to 9, since context defaults to document\n\t\tnodeType = context ? context.nodeType : 9;\n\n\tresults = results || [];\n\n\t// Return early from calls with invalid selector or context\n\tif ( typeof selector !== \"string\" || !selector ||\n\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n\t\treturn results;\n\t}\n\n\t// Try to shortcut find operations (as opposed to filters) in HTML documents\n\tif ( !seed ) {\n\n\t\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\t\tsetDocument( context );\n\t\t}\n\t\tcontext = context || document;\n\n\t\tif ( documentIsHTML ) {\n\n\t\t\t// If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n\t\t\t// (excepting DocumentFragment context, where the methods don't exist)\n\t\t\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\n\n\t\t\t\t// ID selector\n\t\t\t\tif ( (m = match[1]) ) {\n\n\t\t\t\t\t// Document context\n\t\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\t\tif ( (elem = context.getElementById( m )) ) {\n\n\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// Element context\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\tif ( newContext && (elem = newContext.getElementById( m )) &&\n\t\t\t\t\t\t\tcontains( context, elem ) &&\n\t\t\t\t\t\t\telem.id === m ) {\n\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t// Type selector\n\t\t\t\t} else if ( match[2] ) {\n\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\t\treturn results;\n\n\t\t\t\t// Class selector\n\t\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName &&\n\t\t\t\t\tcontext.getElementsByClassName ) {\n\n\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Take advantage of querySelectorAll\n\t\t\tif ( support.qsa &&\n\t\t\t\t!compilerCache[ selector + \" \" ] &&\n\t\t\t\t(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n\n\t\t\t\tif ( nodeType !== 1 ) {\n\t\t\t\t\tnewContext = context;\n\t\t\t\t\tnewSelector = selector;\n\n\t\t\t\t// qSA looks outside Element context, which is not what we want\n\t\t\t\t// Thanks to Andrew Dupont for this workaround technique\n\t\t\t\t// Support: IE <=8\n\t\t\t\t// Exclude object elements\n\t\t\t\t} else if ( context.nodeName.toLowerCase() !== \"object\" ) {\n\n\t\t\t\t\t// Capture the context ID, setting it first if necessary\n\t\t\t\t\tif ( (nid = context.getAttribute( \"id\" )) ) {\n\t\t\t\t\t\tnid = nid.replace( rcssescape, fcssescape );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext.setAttribute( \"id\", (nid = expando) );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prefix every selector in the list\n\t\t\t\t\tgroups = tokenize( selector );\n\t\t\t\t\ti = groups.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tgroups[i] = \"#\" + nid + \" \" + toSelector( groups[i] );\n\t\t\t\t\t}\n\t\t\t\t\tnewSelector = groups.join( \",\" );\n\n\t\t\t\t\t// Expand context for sibling selectors\n\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\n\t\t\t\t\t\tcontext;\n\t\t\t\t}\n\n\t\t\t\tif ( newSelector ) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t} catch ( qsaError ) {\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif ( nid === expando ) {\n\t\t\t\t\t\t\tcontext.removeAttribute( \"id\" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn (cache[ key + \" \" ] = value);\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created element and returns a boolean result\n */\nfunction assert( fn ) {\n\tvar el = document.createElement(\"fieldset\");\n\n\ttry {\n\t\treturn !!fn( el );\n\t} catch (e) {\n\t\treturn false;\n\t} finally {\n\t\t// Remove from its parent by default\n\t\tif ( el.parentNode ) {\n\t\t\tel.parentNode.removeChild( el );\n\t\t}\n\t\t// release memory in IE\n\t\tel = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split(\"|\"),\n\t\ti = arr.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\ta.sourceIndex - b.sourceIndex;\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === \"input\" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for :enabled/:disabled\n * @param {Boolean} disabled true for :disabled; false for :enabled\n */\nfunction createDisabledPseudo( disabled ) {\n\n\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n\treturn function( elem ) {\n\n\t\t// Only certain elements can match :enabled or :disabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n\t\tif ( \"form\" in elem ) {\n\n\t\t\t// Check for inherited disabledness on relevant non-disabled elements:\n\t\t\t// * listed form-associated elements in a disabled fieldset\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n\t\t\t// * option elements in a disabled optgroup\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n\t\t\t// All such elements have a \"form\" property.\n\t\t\tif ( elem.parentNode && elem.disabled === false ) {\n\n\t\t\t\t// Option elements defer to a parent optgroup if present\n\t\t\t\tif ( \"label\" in elem ) {\n\t\t\t\t\tif ( \"label\" in elem.parentNode ) {\n\t\t\t\t\t\treturn elem.parentNode.disabled === disabled;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn elem.disabled === disabled;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Support: IE 6 - 11\n\t\t\t\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\t\t\t\treturn elem.isDisabled === disabled ||\n\n\t\t\t\t\t// Where there is no isDisabled, check manually\n\t\t\t\t\t/* jshint -W018 */\n\t\t\t\t\telem.isDisabled !== !disabled &&\n\t\t\t\t\t\tdisabledAncestor( elem ) === disabled;\n\t\t\t}\n\n\t\t\treturn elem.disabled === disabled;\n\n\t\t// Try to winnow out elements that can't be disabled before trusting the disabled property.\n\t\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n\t\t// even exist on them, let alone have a boolean value.\n\t\t} else if ( \"label\" in elem ) {\n\t\t\treturn elem.disabled === disabled;\n\t\t}\n\n\t\t// Remaining elements are neither :enabled nor :disabled\n\t\treturn false;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction(function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction(function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n\t// documentElement is verified for cases where it doesn't yet exist\n\t// (such as loading iframes in IE - #4833)\n\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar hasCompare, subWindow,\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\n\t// Return early if doc is invalid or already selected\n\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Update global variables\n\tdocument = doc;\n\tdocElem = document.documentElement;\n\tdocumentIsHTML = !isXML( document );\n\n\t// Support: IE 9-11, Edge\n\t// Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n\tif ( preferredDoc !== document &&\n\t\t(subWindow = document.defaultView) && subWindow.top !== subWindow ) {\n\n\t\t// Support: IE 11, Edge\n\t\tif ( subWindow.addEventListener ) {\n\t\t\tsubWindow.addEventListener( \"unload\", unloadHandler, false );\n\n\t\t// Support: IE 9 - 10 only\n\t\t} else if ( subWindow.attachEvent ) {\n\t\t\tsubWindow.attachEvent( \"onunload\", unloadHandler );\n\t\t}\n\t}\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties\n\t// (excepting IE8 booleans)\n\tsupport.attributes = assert(function( el ) {\n\t\tel.className = \"i\";\n\t\treturn !el.getAttribute(\"className\");\n\t});\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName(\"*\") returns only elements\n\tsupport.getElementsByTagName = assert(function( el ) {\n\t\tel.appendChild( document.createComment(\"\") );\n\t\treturn !el.getElementsByTagName(\"*\").length;\n\t});\n\n\t// Support: IE<9\n\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don't pick up programmatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert(function( el ) {\n\t\tdocElem.appendChild( el ).id = expando;\n\t\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\n\t});\n\n\t// ID filter and find\n\tif ( support.getById ) {\n\t\tExpr.filter[\"ID\"] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t};\n\t\t};\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar elem = context.getElementById( id );\n\t\t\t\treturn elem ? [ elem ] : [];\n\t\t\t}\n\t\t};\n\t} else {\n\t\tExpr.filter[\"ID\"] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" &&\n\t\t\t\t\telem.getAttributeNode(\"id\");\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\n\t\t// Support: IE 6 - 7 only\n\t\t// getElementById is not reliable as a find shortcut\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar node, i, elems,\n\t\t\t\t\telem = context.getElementById( id );\n\n\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t// Verify the id attribute\n\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Fall back on getElementsByName\n\t\t\t\t\telems = context.getElementsByName( id );\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile ( (elem = elems[i++]) ) {\n\t\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn [];\n\t\t\t}\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\n\t\t\t// DocumentFragment nodes don't have gEBTN\n\t\t\t} else if ( support.qsa ) {\n\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t}\n\t\t} :\n\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === \"*\" ) {\n\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See https://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( (support.qsa = rnative.test( document.querySelectorAll )) ) {\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert(function( el ) {\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// https://bugs.jquery.com/ticket/12359\n\t\t\tdocElem.appendChild( el ).innerHTML = \"<a id='\" + expando + \"'></a>\" +\n\t\t\t\t\"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" +\n\t\t\t\t\"<option selected=''></option></select>\";\n\n\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\tif ( el.querySelectorAll(\"[msallowcapture^='']\").length ) {\n\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t}\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\tif ( !el.querySelectorAll(\"[selected]\").length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t}\n\n\t\t\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\t\t\tif ( !el.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n\t\t\t\trbuggyQSA.push(\"~=\");\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !el.querySelectorAll(\":checked\").length ) {\n\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t}\n\n\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t// In-page `selector#id sibling-combinator selector` fails\n\t\t\tif ( !el.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n\t\t\t\trbuggyQSA.push(\".#.+[+~]\");\n\t\t\t}\n\t\t});\n\n\t\tassert(function( el ) {\n\t\t\tel.innerHTML = \"<a href='' disabled='disabled'></a>\" +\n\t\t\t\t\"<select disabled='disabled'><option/></select>\";\n\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\tvar input = document.createElement(\"input\");\n\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\tel.appendChild( input ).setAttribute( \"name\", \"D\" );\n\n\t\t\t// Support: IE8\n\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\tif ( el.querySelectorAll(\"[name=d]\").length ) {\n\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( el.querySelectorAll(\":enabled\").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Support: IE9-11+\n\t\t\t// IE's :disabled selector does not pick up the children of disabled fieldsets\n\t\t\tdocElem.appendChild( el ).disabled = true;\n\t\t\tif ( el.querySelectorAll(\":disabled\").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tel.querySelectorAll(\"*,:x\");\n\t\t\trbuggyQSA.push(\",.*:\");\n\t\t});\n\t}\n\n\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n\t\tdocElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector) )) ) {\n\n\t\tassert(function( el ) {\n\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( el, \"*\" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( el, \"[s!='']:x\" );\n\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t});\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n\t// Element contains another\n\t// Purposefully self-exclusive\n\t// As in, an element does not contain itself\n\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t));\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = hasCompare ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\tif ( compare ) {\n\t\t\treturn compare;\n\t\t}\n\n\t\t// Calculate position if both inputs belong to the same document\n\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t// Disconnected nodes\n\t\tif ( compare & 1 ||\n\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n\t\t\t// Choose the first element that is related to our preferred document\n\t\t\tif ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// Maintain original order\n\t\t\treturn sortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\t\t}\n\n\t\treturn compare & 4 ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\tif ( !aup || !bup ) {\n\t\t\treturn a === document ? -1 :\n\t\t\t\tb === document ? 1 :\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[i] === bp[i] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t0;\n\t};\n\n\treturn document;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\t// Make sure that attribute selectors are quoted\n\texpr = expr.replace( rattributeQuotes, \"='$1']\" );\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t!compilerCache[ expr + \" \" ] &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch (e) {}\n\t}\n\n\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\t// Set document vars if needed\n\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val !== undefined ?\n\t\tval :\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull;\n};\n\nSizzle.escape = function( sel ) {\n\treturn (sel + \"\").replace( rcssescape, fcssescape );\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( (elem = results[i++]) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = \"\",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\t\t// If no nodeType, this is expected to be an array\n\t\twhile ( (node = elem[i++]) ) {\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\" \": { dir: \"parentNode\" },\n\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\"~\": { dir: \"previousSibling\" }\n\t},\n\n\tpreFilter: {\n\t\t\"ATTR\": function( match ) {\n\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[3] = ( match[3] || match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\n\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t\"CHILD\": function( match ) {\n\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\n\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[3] ) {\n\t\t\t\tSizzle.error( match[0] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t\"PSEUDO\": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[6] && match[2];\n\n\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[3] ) {\n\t\t\t\tmatch[2] = match[4] || match[5] || \"\";\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\tfunction() { return true; } :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t\"CLASS\": function( className ) {\n\t\t\tvar pattern = classCache[ className + \" \" ];\n\n\t\t\treturn pattern ||\n\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\" );\n\t\t\t\t});\n\t\t},\n\n\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += \"\";\n\n\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\tfalse;\n\t\t\t};\n\t\t},\n\n\t\t\"CHILD\": function( type, what, argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\tofType = what === \"of-type\";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType,\n\t\t\t\t\t\tdiff = false;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) {\n\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\n\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\tnode = parent;\n\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\tdiff = nodeIndex && cache[ 2 ];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\t\tdiff = nodeIndex;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// xml :nth-child(...)\n\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\tif ( diff === false ) {\n\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t\tif ( ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) &&\n\t\t\t\t\t\t\t\t\t\t++diff ) {\n\n\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t\"PSEUDO\": function( pseudo, argument ) {\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf( seed, matched[i] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\t\t// Potentially complex pseudos\n\t\t\"not\": markFunction(function( selector ) {\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) :\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\t// Don't keep the element (issue #299)\n\t\t\t\t\tinput[0] = null;\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t}),\n\n\t\t\"has\": markFunction(function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t}),\n\n\t\t\"contains\": markFunction(function( text ) {\n\t\t\ttext = text.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t}),\n\n\t\t// \"Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element's language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name.\"\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\"lang\": markFunction( function( lang ) {\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test(lang || \"\") ) {\n\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}),\n\n\t\t// Miscellaneous\n\t\t\"target\": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t\"root\": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t\"focus\": function( elem ) {\n\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t},\n\n\t\t// Boolean properties\n\t\t\"enabled\": createDisabledPseudo( false ),\n\t\t\"disabled\": createDisabledPseudo( true ),\n\n\t\t\"checked\": function( elem ) {\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n\t\t},\n\n\t\t\"selected\": function( elem ) {\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t\"empty\": function( elem ) {\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t\"parent\": function( elem ) {\n\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t\"header\": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t\"input\": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t\"button\": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t},\n\n\t\t\"text\": function( elem ) {\n\t\t\tvar attr;\n\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\telem.type === \"text\" &&\n\n\t\t\t\t// Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\" );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t\"first\": createPositionalPseudo(function() {\n\t\t\treturn [ 0 ];\n\t\t}),\n\n\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t}),\n\n\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t}),\n\n\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t})\n\t}\n};\n\nExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + \" \" ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\tif ( match ) {\n\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( (tokens = []) );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push({\n\t\t\t\tvalue: matched,\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[0].replace( rtrim, \" \" )\n\t\t\t});\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we're just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n};\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = \"\";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[i].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tskip = combinator.next,\n\t\tkey = skip || dir,\n\t\tcheckNonElements = base && key === \"parentNode\",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar oldCache, uniqueCache, outerCache,\n\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\n\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\tuniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});\n\n\t\t\t\t\t\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\n\t\t\t\t\t\t\telem = elem[ dir ] || elem;\n\t\t\t\t\t\t} else if ( (oldCache = uniqueCache[ key ]) &&\n\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\tuniqueCache[ key ] = newCache;\n\n\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[0];\n}\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[i], results );\n\t}\n\treturn results;\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (elem = unmatched[i]) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction(function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\n\n\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\tcheckContext = null;\n\t\t\treturn ret;\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\n\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\tvar bySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = \"0\",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\tsetMatched = [],\n\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", outermost ),\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n\t\t\t\tlen = elems.length;\n\n\t\t\tif ( outermost ) {\n\t\t\t\toutermostContext = context === document || context || outermost;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\tif ( !context && elem.ownerDocument !== document ) {\n\t\t\t\t\t\tsetDocument( elem );\n\t\t\t\t\t\txml = !documentIsHTML;\n\t\t\t\t\t}\n\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\tif ( matcher( elem, context || document, xml) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\n\t\t\t// makes the latter nonnegative.\n\t\t\tmatchedCount += i;\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n\t\t\t// equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n\t\t\t// no element matchers and no seed.\n\t\t\t// Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n\t\t\t// case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n\t\t\t// numerically zero.\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + \" \" ];\n\n\tif ( !cached ) {\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !match ) {\n\t\t\tmatch = tokenize( selector );\n\t\t}\n\t\ti = match.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( match[i] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\n\t\t// Save selector and tokenization\n\t\tcached.selector = selector;\n\t}\n\treturn cached;\n};\n\n/**\n * A low-level selection function that works with Sizzle's compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with Sizzle.compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\nselect = Sizzle.select = function( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tcompiled = typeof selector === \"function\" && selector,\n\t\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\n\n\tresults = results || [];\n\n\t// Try to minimize operations if there is only one selector in the list and no seed\n\t// (the latter of which guarantees us context)\n\tif ( match.length === 1 ) {\n\n\t\t// Reduce context if the leading compound selector is an ID\n\t\ttokens = match[0] = match[0].slice( 0 );\n\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n\t\t\t\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {\n\n\t\t\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\tif ( !context ) {\n\t\t\t\treturn results;\n\n\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t} else if ( compiled ) {\n\t\t\t\tcontext = context.parentNode;\n\t\t\t}\n\n\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t}\n\n\t\t// Fetch a seed set for right-to-left matching\n\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n\t\twhile ( i-- ) {\n\t\t\ttoken = tokens[i];\n\n\t\t\t// Abort if we hit a combinator\n\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\tif ( (seed = find(\n\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n\t\t\t\t)) ) {\n\n\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function if one is not provided\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\t( compiled || compile( selector, match ) )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\n\t);\n\treturn results;\n};\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\n\n// Support: Chrome 14-35+\n// Always assume duplicates if they aren't passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert(function( el ) {\n\t// Should return 1, but returns 4 (following)\n\treturn el.compareDocumentPosition( document.createElement(\"fieldset\") ) & 1;\n});\n\n// Support: IE<8\n// Prevent attribute/property \"interpolation\"\n// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert(function( el ) {\n\tel.innerHTML = \"<a href='#'></a>\";\n\treturn el.firstChild.getAttribute(\"href\") === \"#\" ;\n}) ) {\n\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute(\"value\")\nif ( !support.attributes || !assert(function( el ) {\n\tel.innerHTML = \"<input/>\";\n\tel.firstChild.setAttribute( \"value\", \"\" );\n\treturn el.firstChild.getAttribute( \"value\" ) === \"\";\n}) ) {\n\taddHandle( \"value\", function( elem, name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert(function( el ) {\n\treturn el.getAttribute(\"disabled\") == null;\n}) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\tnull;\n\t\t}\n\t});\n}\n\nreturn Sizzle;\n\n})( window );\n\n\n\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\n\n// Deprecated\njQuery.expr[ \":\" ] = jQuery.expr.pseudos;\njQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\njQuery.escapeSelector = Sizzle.escape;\n\n\n\n\nvar dir = function( elem, dir, until ) {\n\tvar matched = [],\n\t\ttruncate = until !== undefined;\n\n\twhile ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\n\t\tif ( elem.nodeType === 1 ) {\n\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmatched.push( elem );\n\t\t}\n\t}\n\treturn matched;\n};\n\n\nvar siblings = function( n, elem ) {\n\tvar matched = [];\n\n\tfor ( ; n; n = n.nextSibling ) {\n\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\tmatched.push( n );\n\t\t}\n\t}\n\n\treturn matched;\n};\n\n\nvar rneedsContext = jQuery.expr.match.needsContext;\n\n\n\nfunction nodeName( elem, name ) {\n\n  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\n};\nvar rsingleTag = ( /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i );\n\n\n\nvar risSimple = /^.[^:#\\[\\.,]*$/;\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, not ) {\n\tif ( jQuery.isFunction( qualifier ) ) {\n\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t} );\n\t}\n\n\t// Single element\n\tif ( qualifier.nodeType ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( elem === qualifier ) !== not;\n\t\t} );\n\t}\n\n\t// Arraylike of elements (jQuery, arguments, Array)\n\tif ( typeof qualifier !== \"string\" ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not;\n\t\t} );\n\t}\n\n\t// Simple selector that can be filtered directly, removing non-Elements\n\tif ( risSimple.test( qualifier ) ) {\n\t\treturn jQuery.filter( qualifier, elements, not );\n\t}\n\n\t// Complex selector, compare the two sets, removing non-Elements\n\tqualifier = jQuery.filter( qualifier, elements );\n\treturn jQuery.grep( elements, function( elem ) {\n\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;\n\t} );\n}\n\njQuery.filter = function( expr, elems, not ) {\n\tvar elem = elems[ 0 ];\n\n\tif ( not ) {\n\t\texpr = \":not(\" + expr + \")\";\n\t}\n\n\tif ( elems.length === 1 && elem.nodeType === 1 ) {\n\t\treturn jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];\n\t}\n\n\treturn jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\treturn elem.nodeType === 1;\n\t} ) );\n};\n\njQuery.fn.extend( {\n\tfind: function( selector ) {\n\t\tvar i, ret,\n\t\t\tlen = this.length,\n\t\t\tself = this;\n\n\t\tif ( typeof selector !== \"string\" ) {\n\t\t\treturn this.pushStack( jQuery( selector ).filter( function() {\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} ) );\n\t\t}\n\n\t\tret = this.pushStack( [] );\n\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t}\n\n\t\treturn len > 1 ? jQuery.uniqueSort( ret ) : ret;\n\t},\n\tfilter: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], false ) );\n\t},\n\tnot: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], true ) );\n\t},\n\tis: function( selector ) {\n\t\treturn !!winnow(\n\t\t\tthis,\n\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\n\t\t\t\tjQuery( selector ) :\n\t\t\t\tselector || [],\n\t\t\tfalse\n\t\t).length;\n\t}\n} );\n\n\n// Initialize a jQuery object\n\n\n// A central reference to the root jQuery(document)\nvar rootjQuery,\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\t// Shortcut simple #id case for speed\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,\n\n\tinit = jQuery.fn.init = function( selector, context, root ) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Method init() accepts an alternate rootjQuery\n\t\t// so migrate can support jQuery.sub (gh-2101)\n\t\troot = root || rootjQuery;\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === \"string\" ) {\n\t\t\tif ( selector[ 0 ] === \"<\" &&\n\t\t\t\tselector[ selector.length - 1 ] === \">\" &&\n\t\t\t\tselector.length >= 3 ) {\n\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif ( match && ( match[ 1 ] || !context ) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[ 1 ] ) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[ 0 ] : context;\n\n\t\t\t\t\t// Option to run scripts is true for back-compat\n\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\tmatch[ 1 ],\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t) );\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\tfor ( match in context ) {\n\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif ( jQuery.isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[ 2 ] );\n\n\t\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\tthis[ 0 ] = elem;\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn ( context || root ).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(DOMElement)\n\t\t} else if ( selector.nodeType ) {\n\t\t\tthis[ 0 ] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( jQuery.isFunction( selector ) ) {\n\t\t\treturn root.ready !== undefined ?\n\t\t\t\troot.ready( selector ) :\n\n\t\t\t\t// Execute immediately if ready is not present\n\t\t\t\tselector( jQuery );\n\t\t}\n\n\t\treturn jQuery.makeArray( selector, this );\n\t};\n\n// Give the init function the jQuery prototype for later instantiation\ninit.prototype = jQuery.fn;\n\n// Initialize central reference\nrootjQuery = jQuery( document );\n\n\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\n\t// Methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\njQuery.fn.extend( {\n\thas: function( target ) {\n\t\tvar targets = jQuery( target, this ),\n\t\t\tl = targets.length;\n\n\t\treturn this.filter( function() {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[ i ] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\tclosest: function( selectors, context ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tmatched = [],\n\t\t\ttargets = typeof selectors !== \"string\" && jQuery( selectors );\n\n\t\t// Positional selectors never match, since there's no _selection_ context\n\t\tif ( !rneedsContext.test( selectors ) ) {\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tfor ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\n\n\t\t\t\t\t// Always skip document fragments\n\t\t\t\t\tif ( cur.nodeType < 11 && ( targets ?\n\t\t\t\t\t\ttargets.index( cur ) > -1 :\n\n\t\t\t\t\t\t// Don't pass non-elements to Sizzle\n\t\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\t\tjQuery.find.matchesSelector( cur, selectors ) ) ) {\n\n\t\t\t\t\t\tmatched.push( cur );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\n\t},\n\n\t// Determine the position of an element within the set\n\tindex: function( elem ) {\n\n\t\t// No argument, return index in parent\n\t\tif ( !elem ) {\n\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n\t\t}\n\n\t\t// Index in selector\n\t\tif ( typeof elem === \"string\" ) {\n\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\n\t\t}\n\n\t\t// Locate the position of the desired element\n\t\treturn indexOf.call( this,\n\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[ 0 ] : elem\n\t\t);\n\t},\n\n\tadd: function( selector, context ) {\n\t\treturn this.pushStack(\n\t\t\tjQuery.uniqueSort(\n\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n\t\t\t)\n\t\t);\n\t},\n\n\taddBack: function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter( selector )\n\t\t);\n\t}\n} );\n\nfunction sibling( cur, dir ) {\n\twhile ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}\n\treturn cur;\n}\n\njQuery.each( {\n\tparent: function( elem ) {\n\t\tvar parent = elem.parentNode;\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t},\n\tparents: function( elem ) {\n\t\treturn dir( elem, \"parentNode\" );\n\t},\n\tparentsUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"parentNode\", until );\n\t},\n\tnext: function( elem ) {\n\t\treturn sibling( elem, \"nextSibling\" );\n\t},\n\tprev: function( elem ) {\n\t\treturn sibling( elem, \"previousSibling\" );\n\t},\n\tnextAll: function( elem ) {\n\t\treturn dir( elem, \"nextSibling\" );\n\t},\n\tprevAll: function( elem ) {\n\t\treturn dir( elem, \"previousSibling\" );\n\t},\n\tnextUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"nextSibling\", until );\n\t},\n\tprevUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"previousSibling\", until );\n\t},\n\tsiblings: function( elem ) {\n\t\treturn siblings( ( elem.parentNode || {} ).firstChild, elem );\n\t},\n\tchildren: function( elem ) {\n\t\treturn siblings( elem.firstChild );\n\t},\n\tcontents: function( elem ) {\n        if ( nodeName( elem, \"iframe\" ) ) {\n            return elem.contentDocument;\n        }\n\n        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only\n        // Treat the template element as a regular one in browsers that\n        // don't support it.\n        if ( nodeName( elem, \"template\" ) ) {\n            elem = elem.content || elem;\n        }\n\n        return jQuery.merge( [], elem.childNodes );\n\t}\n}, function( name, fn ) {\n\tjQuery.fn[ name ] = function( until, selector ) {\n\t\tvar matched = jQuery.map( this, fn, until );\n\n\t\tif ( name.slice( -5 ) !== \"Until\" ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tmatched = jQuery.filter( selector, matched );\n\t\t}\n\n\t\tif ( this.length > 1 ) {\n\n\t\t\t// Remove duplicates\n\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\tjQuery.uniqueSort( matched );\n\t\t\t}\n\n\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\tmatched.reverse();\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched );\n\t};\n} );\nvar rnothtmlwhite = ( /[^\\x20\\t\\r\\n\\f]+/g );\n\n\n\n// Convert String-formatted options into Object-formatted ones\nfunction createOptions( options ) {\n\tvar object = {};\n\tjQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t} );\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\tcreateOptions( options ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Flag to know if list is currently firing\n\t\tfiring,\n\n\t\t// Last fire value for non-forgettable lists\n\t\tmemory,\n\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\n\t\t// Flag to prevent firing\n\t\tlocked,\n\n\t\t// Actual callback list\n\t\tlist = [],\n\n\t\t// Queue of execution data for repeatable lists\n\t\tqueue = [],\n\n\t\t// Index of currently firing callback (modified by add/remove as needed)\n\t\tfiringIndex = -1,\n\n\t\t// Fire callbacks\n\t\tfire = function() {\n\n\t\t\t// Enforce single-firing\n\t\t\tlocked = locked || options.once;\n\n\t\t\t// Execute callbacks for all pending executions,\n\t\t\t// respecting firingIndex overrides and runtime changes\n\t\t\tfired = firing = true;\n\t\t\tfor ( ; queue.length; firingIndex = -1 ) {\n\t\t\t\tmemory = queue.shift();\n\t\t\t\twhile ( ++firingIndex < list.length ) {\n\n\t\t\t\t\t// Run callback and check for early termination\n\t\t\t\t\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\n\t\t\t\t\t\toptions.stopOnFalse ) {\n\n\t\t\t\t\t\t// Jump to end and forget the data so .add doesn't re-fire\n\t\t\t\t\t\tfiringIndex = list.length;\n\t\t\t\t\t\tmemory = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Forget the data if we're done with it\n\t\t\tif ( !options.memory ) {\n\t\t\t\tmemory = false;\n\t\t\t}\n\n\t\t\tfiring = false;\n\n\t\t\t// Clean up if we're done firing for good\n\t\t\tif ( locked ) {\n\n\t\t\t\t// Keep an empty list if we have data for future add calls\n\t\t\t\tif ( memory ) {\n\t\t\t\t\tlist = [];\n\n\t\t\t\t// Otherwise, this object is spent\n\t\t\t\t} else {\n\t\t\t\t\tlist = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Actual Callbacks object\n\t\tself = {\n\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\n\t\t\t\t\t// If we have memory from a past run, we should fire after adding\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfiringIndex = list.length - 1;\n\t\t\t\t\t\tqueue.push( memory );\n\t\t\t\t\t}\n\n\t\t\t\t\t( function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tif ( jQuery.isFunction( arg ) ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && jQuery.type( arg ) !== \"string\" ) {\n\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t} )( arguments );\n\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\tvar index;\n\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\tlist.splice( index, 1 );\n\n\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ?\n\t\t\t\t\tjQuery.inArray( fn, list ) > -1 :\n\t\t\t\t\tlist.length > 0;\n\t\t\t},\n\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Disable .fire and .add\n\t\t\t// Abort any current/pending executions\n\t\t\t// Clear all callbacks and values\n\t\t\tdisable: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tlist = memory = \"\";\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\n\t\t\t// Disable .fire\n\t\t\t// Also disable .add unless we have memory (since it would have no effect)\n\t\t\t// Abort any pending executions\n\t\t\tlock: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tif ( !memory && !firing ) {\n\t\t\t\t\tlist = memory = \"\";\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tlocked: function() {\n\t\t\t\treturn !!locked;\n\t\t\t},\n\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( !locked ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tqueue.push( args );\n\t\t\t\t\tif ( !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\n\nfunction Identity( v ) {\n\treturn v;\n}\nfunction Thrower( ex ) {\n\tthrow ex;\n}\n\nfunction adoptValue( value, resolve, reject, noValue ) {\n\tvar method;\n\n\ttry {\n\n\t\t// Check for promise aspect first to privilege synchronous behavior\n\t\tif ( value && jQuery.isFunction( ( method = value.promise ) ) ) {\n\t\t\tmethod.call( value ).done( resolve ).fail( reject );\n\n\t\t// Other thenables\n\t\t} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {\n\t\t\tmethod.call( value, resolve, reject );\n\n\t\t// Other non-thenables\n\t\t} else {\n\n\t\t\t// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\n\t\t\t// * false: [ value ].slice( 0 ) => resolve( value )\n\t\t\t// * true: [ value ].slice( 1 ) => resolve()\n\t\t\tresolve.apply( undefined, [ value ].slice( noValue ) );\n\t\t}\n\n\t// For Promises/A+, convert exceptions into rejections\n\t// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\n\t// Deferred#then to conditionally suppress rejection.\n\t} catch ( value ) {\n\n\t\t// Support: Android 4.0 only\n\t\t// Strict mode functions invoked without .call/.apply get global-object context\n\t\treject.apply( undefined, [ value ] );\n\t}\n}\n\njQuery.extend( {\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\n\t\t\t\t// action, add listener, callbacks,\n\t\t\t\t// ... .then handlers, argument index, [final state]\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks( \"memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"memory\" ), 2 ],\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 0, \"resolved\" ],\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 1, \"rejected\" ]\n\t\t\t],\n\t\t\tstate = \"pending\",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t\"catch\": function( fn ) {\n\t\t\t\t\treturn promise.then( null, fn );\n\t\t\t\t},\n\n\t\t\t\t// Keep pipe for back-compat\n\t\t\t\tpipe: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\n\t\t\t\t\t\t\t// Map tuples (progress, done, fail) to arguments (done, fail, progress)\n\t\t\t\t\t\t\tvar fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];\n\n\t\t\t\t\t\t\t// deferred.progress(function() { bind to newDefer or newDefer.notify })\n\t\t\t\t\t\t\t// deferred.done(function() { bind to newDefer or newDefer.resolve })\n\t\t\t\t\t\t\t// deferred.fail(function() { bind to newDefer or newDefer.reject })\n\t\t\t\t\t\t\tdeferred[ tuple[ 1 ] ]( function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify )\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ](\n\t\t\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\t\t\tfn ? [ returned ] : arguments\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\t\t\t\tthen: function( onFulfilled, onRejected, onProgress ) {\n\t\t\t\t\tvar maxDepth = 0;\n\t\t\t\t\tfunction resolve( depth, deferred, handler, special ) {\n\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\tvar that = this,\n\t\t\t\t\t\t\t\targs = arguments,\n\t\t\t\t\t\t\t\tmightThrow = function() {\n\t\t\t\t\t\t\t\t\tvar returned, then;\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.3\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-59\n\t\t\t\t\t\t\t\t\t// Ignore double-resolution attempts\n\t\t\t\t\t\t\t\t\tif ( depth < maxDepth ) {\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturned = handler.apply( that, args );\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.1\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-48\n\t\t\t\t\t\t\t\t\tif ( returned === deferred.promise() ) {\n\t\t\t\t\t\t\t\t\t\tthrow new TypeError( \"Thenable self-resolution\" );\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ sections 2.3.3.1, 3.5\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-54\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-75\n\t\t\t\t\t\t\t\t\t// Retrieve `then` only once\n\t\t\t\t\t\t\t\t\tthen = returned &&\n\n\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.4\n\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-64\n\t\t\t\t\t\t\t\t\t\t// Only check objects and functions for thenability\n\t\t\t\t\t\t\t\t\t\t( typeof returned === \"object\" ||\n\t\t\t\t\t\t\t\t\t\t\ttypeof returned === \"function\" ) &&\n\t\t\t\t\t\t\t\t\t\treturned.then;\n\n\t\t\t\t\t\t\t\t\t// Handle a returned thenable\n\t\t\t\t\t\t\t\t\tif ( jQuery.isFunction( then ) ) {\n\n\t\t\t\t\t\t\t\t\t\t// Special processors (notify) just wait for resolution\n\t\t\t\t\t\t\t\t\t\tif ( special ) {\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special )\n\t\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\t// Normal processors (resolve) also hook into progress\n\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t// ...and disregard older resolution values\n\t\t\t\t\t\t\t\t\t\t\tmaxDepth++;\n\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdeferred.notifyWith )\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Handle all other returned values\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\tif ( handler !== Identity ) {\n\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\targs = [ returned ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// Process the value(s)\n\t\t\t\t\t\t\t\t\t\t// Default process is resolve\n\t\t\t\t\t\t\t\t\t\t( special || deferred.resolveWith )( that, args );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t// Only normal processors (resolve) catch and reject exceptions\n\t\t\t\t\t\t\t\tprocess = special ?\n\t\t\t\t\t\t\t\t\tmightThrow :\n\t\t\t\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\tmightThrow();\n\t\t\t\t\t\t\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t\t\t\t\t\t\tif ( jQuery.Deferred.exceptionHook ) {\n\t\t\t\t\t\t\t\t\t\t\t\tjQuery.Deferred.exceptionHook( e,\n\t\t\t\t\t\t\t\t\t\t\t\t\tprocess.stackTrace );\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.4.1\n\t\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-61\n\t\t\t\t\t\t\t\t\t\t\t// Ignore post-resolution exceptions\n\t\t\t\t\t\t\t\t\t\t\tif ( depth + 1 >= maxDepth ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\t\t\tif ( handler !== Thrower ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\t\targs = [ e ];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tdeferred.rejectWith( that, args );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.1\n\t\t\t\t\t\t\t// https://promisesaplus.com/#point-57\n\t\t\t\t\t\t\t// Re-resolve promises immediately to dodge false rejection from\n\t\t\t\t\t\t\t// subsequent errors\n\t\t\t\t\t\t\tif ( depth ) {\n\t\t\t\t\t\t\t\tprocess();\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Call an optional hook to record the stack, in case of exception\n\t\t\t\t\t\t\t\t// since it's otherwise lost when execution goes async\n\t\t\t\t\t\t\t\tif ( jQuery.Deferred.getStackHook ) {\n\t\t\t\t\t\t\t\t\tprocess.stackTrace = jQuery.Deferred.getStackHook();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twindow.setTimeout( process );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\n\t\t\t\t\t\t// progress_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 0 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tjQuery.isFunction( onProgress ) ?\n\t\t\t\t\t\t\t\t\tonProgress :\n\t\t\t\t\t\t\t\t\tIdentity,\n\t\t\t\t\t\t\t\tnewDefer.notifyWith\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// fulfilled_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 1 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tjQuery.isFunction( onFulfilled ) ?\n\t\t\t\t\t\t\t\t\tonFulfilled :\n\t\t\t\t\t\t\t\t\tIdentity\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// rejected_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 2 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tjQuery.isFunction( onRejected ) ?\n\t\t\t\t\t\t\t\t\tonRejected :\n\t\t\t\t\t\t\t\t\tThrower\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 5 ];\n\n\t\t\t// promise.progress = list.add\n\t\t\t// promise.done = list.add\n\t\t\t// promise.fail = list.add\n\t\t\tpromise[ tuple[ 1 ] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(\n\t\t\t\t\tfunction() {\n\n\t\t\t\t\t\t// state = \"resolved\" (i.e., fulfilled)\n\t\t\t\t\t\t// state = \"rejected\"\n\t\t\t\t\t\tstate = stateString;\n\t\t\t\t\t},\n\n\t\t\t\t\t// rejected_callbacks.disable\n\t\t\t\t\t// fulfilled_callbacks.disable\n\t\t\t\t\ttuples[ 3 - i ][ 2 ].disable,\n\n\t\t\t\t\t// progress_callbacks.lock\n\t\t\t\t\ttuples[ 0 ][ 2 ].lock\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// progress_handlers.fire\n\t\t\t// fulfilled_handlers.fire\n\t\t\t// rejected_handlers.fire\n\t\t\tlist.add( tuple[ 3 ].fire );\n\n\t\t\t// deferred.notify = function() { deferred.notifyWith(...) }\n\t\t\t// deferred.resolve = function() { deferred.resolveWith(...) }\n\t\t\t// deferred.reject = function() { deferred.rejectWith(...) }\n\t\t\tdeferred[ tuple[ 0 ] ] = function() {\n\t\t\t\tdeferred[ tuple[ 0 ] + \"With\" ]( this === deferred ? undefined : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\t// deferred.notifyWith = list.fireWith\n\t\t\t// deferred.resolveWith = list.fireWith\n\t\t\t// deferred.rejectWith = list.fireWith\n\t\t\tdeferred[ tuple[ 0 ] + \"With\" ] = list.fireWith;\n\t\t} );\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( singleValue ) {\n\t\tvar\n\n\t\t\t// count of uncompleted subordinates\n\t\t\tremaining = arguments.length,\n\n\t\t\t// count of unprocessed arguments\n\t\t\ti = remaining,\n\n\t\t\t// subordinate fulfillment data\n\t\t\tresolveContexts = Array( i ),\n\t\t\tresolveValues = slice.call( arguments ),\n\n\t\t\t// the master Deferred\n\t\t\tmaster = jQuery.Deferred(),\n\n\t\t\t// subordinate callback factory\n\t\t\tupdateFunc = function( i ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tresolveContexts[ i ] = this;\n\t\t\t\t\tresolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\tif ( !( --remaining ) ) {\n\t\t\t\t\t\tmaster.resolveWith( resolveContexts, resolveValues );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\n\t\t// Single- and empty arguments are adopted like Promise.resolve\n\t\tif ( remaining <= 1 ) {\n\t\t\tadoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,\n\t\t\t\t!remaining );\n\n\t\t\t// Use .then() to unwrap secondary thenables (cf. gh-3000)\n\t\t\tif ( master.state() === \"pending\" ||\n\t\t\t\tjQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {\n\n\t\t\t\treturn master.then();\n\t\t\t}\n\t\t}\n\n\t\t// Multiple arguments are aggregated like Promise.all array elements\n\t\twhile ( i-- ) {\n\t\t\tadoptValue( resolveValues[ i ], updateFunc( i ), master.reject );\n\t\t}\n\n\t\treturn master.promise();\n\t}\n} );\n\n\n// These usually indicate a programmer mistake during development,\n// warn about them ASAP rather than swallowing them by default.\nvar rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\n\njQuery.Deferred.exceptionHook = function( error, stack ) {\n\n\t// Support: IE 8 - 9 only\n\t// Console exists when dev tools are open, which can happen at any time\n\tif ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {\n\t\twindow.console.warn( \"jQuery.Deferred exception: \" + error.message, error.stack, stack );\n\t}\n};\n\n\n\n\njQuery.readyException = function( error ) {\n\twindow.setTimeout( function() {\n\t\tthrow error;\n\t} );\n};\n\n\n\n\n// The deferred used on DOM ready\nvar readyList = jQuery.Deferred();\n\njQuery.fn.ready = function( fn ) {\n\n\treadyList\n\t\t.then( fn )\n\n\t\t// Wrap jQuery.readyException in a function so that the lookup\n\t\t// happens at the time of error handling instead of callback\n\t\t// registration.\n\t\t.catch( function( error ) {\n\t\t\tjQuery.readyException( error );\n\t\t} );\n\n\treturn this;\n};\n\njQuery.extend( {\n\n\t// Is the DOM ready to be used? Set to true once it occurs.\n\tisReady: false,\n\n\t// A counter to track how many items to wait for before\n\t// the ready event fires. See #6781\n\treadyWait: 1,\n\n\t// Handle when the DOM is ready\n\tready: function( wait ) {\n\n\t\t// Abort if there are pending holds or we're already ready\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remember that the DOM is ready\n\t\tjQuery.isReady = true;\n\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are functions bound, to execute\n\t\treadyList.resolveWith( document, [ jQuery ] );\n\t}\n} );\n\njQuery.ready.then = readyList.then;\n\n// The ready event handler and self cleanup method\nfunction completed() {\n\tdocument.removeEventListener( \"DOMContentLoaded\", completed );\n\twindow.removeEventListener( \"load\", completed );\n\tjQuery.ready();\n}\n\n// Catch cases where $(document).ready() is called\n// after the browser event has already occurred.\n// Support: IE <=9 - 10 only\n// Older IE sometimes signals \"interactive\" too soon\nif ( document.readyState === \"complete\" ||\n\t( document.readyState !== \"loading\" && !document.documentElement.doScroll ) ) {\n\n\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\twindow.setTimeout( jQuery.ready );\n\n} else {\n\n\t// Use the handy event callback\n\tdocument.addEventListener( \"DOMContentLoaded\", completed );\n\n\t// A fallback to window.onload, that will always work\n\twindow.addEventListener( \"load\", completed );\n}\n\n\n\n\n// Multifunctional method to get and set values of a collection\n// The value/s can optionally be executed if it's a function\nvar access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\tvar i = 0,\n\t\tlen = elems.length,\n\t\tbulk = key == null;\n\n\t// Sets many values\n\tif ( jQuery.type( key ) === \"object\" ) {\n\t\tchainable = true;\n\t\tfor ( i in key ) {\n\t\t\taccess( elems, fn, i, key[ i ], true, emptyGet, raw );\n\t\t}\n\n\t// Sets one value\n\t} else if ( value !== undefined ) {\n\t\tchainable = true;\n\n\t\tif ( !jQuery.isFunction( value ) ) {\n\t\t\traw = true;\n\t\t}\n\n\t\tif ( bulk ) {\n\n\t\t\t// Bulk operations run against the entire set\n\t\t\tif ( raw ) {\n\t\t\t\tfn.call( elems, value );\n\t\t\t\tfn = null;\n\n\t\t\t// ...except when executing function values\n\t\t\t} else {\n\t\t\t\tbulk = fn;\n\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif ( fn ) {\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\tfn(\n\t\t\t\t\telems[ i ], key, raw ?\n\t\t\t\t\tvalue :\n\t\t\t\t\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( chainable ) {\n\t\treturn elems;\n\t}\n\n\t// Gets\n\tif ( bulk ) {\n\t\treturn fn.call( elems );\n\t}\n\n\treturn len ? fn( elems[ 0 ], key ) : emptyGet;\n};\nvar acceptData = function( owner ) {\n\n\t// Accepts only:\n\t//  - Node\n\t//    - Node.ELEMENT_NODE\n\t//    - Node.DOCUMENT_NODE\n\t//  - Object\n\t//    - Any\n\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n};\n\n\n\n\nfunction Data() {\n\tthis.expando = jQuery.expando + Data.uid++;\n}\n\nData.uid = 1;\n\nData.prototype = {\n\n\tcache: function( owner ) {\n\n\t\t// Check if the owner object already has a cache\n\t\tvar value = owner[ this.expando ];\n\n\t\t// If not, create one\n\t\tif ( !value ) {\n\t\t\tvalue = {};\n\n\t\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t\t// but we should not, see #8335.\n\t\t\t// Always return an empty object.\n\t\t\tif ( acceptData( owner ) ) {\n\n\t\t\t\t// If it is a node unlikely to be stringify-ed or looped over\n\t\t\t\t// use plain assignment\n\t\t\t\tif ( owner.nodeType ) {\n\t\t\t\t\towner[ this.expando ] = value;\n\n\t\t\t\t// Otherwise secure it in a non-enumerable property\n\t\t\t\t// configurable must be true to allow the property to be\n\t\t\t\t// deleted when data is removed\n\t\t\t\t} else {\n\t\t\t\t\tObject.defineProperty( owner, this.expando, {\n\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t},\n\tset: function( owner, data, value ) {\n\t\tvar prop,\n\t\t\tcache = this.cache( owner );\n\n\t\t// Handle: [ owner, key, value ] args\n\t\t// Always use camelCase key (gh-2257)\n\t\tif ( typeof data === \"string\" ) {\n\t\t\tcache[ jQuery.camelCase( data ) ] = value;\n\n\t\t// Handle: [ owner, { properties } ] args\n\t\t} else {\n\n\t\t\t// Copy the properties one-by-one to the cache object\n\t\t\tfor ( prop in data ) {\n\t\t\t\tcache[ jQuery.camelCase( prop ) ] = data[ prop ];\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t},\n\tget: function( owner, key ) {\n\t\treturn key === undefined ?\n\t\t\tthis.cache( owner ) :\n\n\t\t\t// Always use camelCase key (gh-2257)\n\t\t\towner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];\n\t},\n\taccess: function( owner, key, value ) {\n\n\t\t// In cases where either:\n\t\t//\n\t\t//   1. No key was specified\n\t\t//   2. A string key was specified, but no value provided\n\t\t//\n\t\t// Take the \"read\" path and allow the get method to determine\n\t\t// which value to return, respectively either:\n\t\t//\n\t\t//   1. The entire cache object\n\t\t//   2. The data stored at the key\n\t\t//\n\t\tif ( key === undefined ||\n\t\t\t\t( ( key && typeof key === \"string\" ) && value === undefined ) ) {\n\n\t\t\treturn this.get( owner, key );\n\t\t}\n\n\t\t// When the key is not a string, or both a key and value\n\t\t// are specified, set or extend (existing objects) with either:\n\t\t//\n\t\t//   1. An object of properties\n\t\t//   2. A key and value\n\t\t//\n\t\tthis.set( owner, key, value );\n\n\t\t// Since the \"set\" path can have two possible entry points\n\t\t// return the expected data based on which path was taken[*]\n\t\treturn value !== undefined ? value : key;\n\t},\n\tremove: function( owner, key ) {\n\t\tvar i,\n\t\t\tcache = owner[ this.expando ];\n\n\t\tif ( cache === undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( key !== undefined ) {\n\n\t\t\t// Support array or space separated string of keys\n\t\t\tif ( Array.isArray( key ) ) {\n\n\t\t\t\t// If key is an array of keys...\n\t\t\t\t// We always set camelCase keys, so remove that.\n\t\t\t\tkey = key.map( jQuery.camelCase );\n\t\t\t} else {\n\t\t\t\tkey = jQuery.camelCase( key );\n\n\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\tkey = key in cache ?\n\t\t\t\t\t[ key ] :\n\t\t\t\t\t( key.match( rnothtmlwhite ) || [] );\n\t\t\t}\n\n\t\t\ti = key.length;\n\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete cache[ key[ i ] ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if there's no more data\n\t\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\n\n\t\t\t// Support: Chrome <=35 - 45\n\t\t\t// Webkit & Blink performance suffers when deleting properties\n\t\t\t// from DOM nodes, so set to undefined instead\n\t\t\t// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\n\t\t\tif ( owner.nodeType ) {\n\t\t\t\towner[ this.expando ] = undefined;\n\t\t\t} else {\n\t\t\t\tdelete owner[ this.expando ];\n\t\t\t}\n\t\t}\n\t},\n\thasData: function( owner ) {\n\t\tvar cache = owner[ this.expando ];\n\t\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\n\t}\n};\nvar dataPriv = new Data();\n\nvar dataUser = new Data();\n\n\n\n//\tImplementation Summary\n//\n//\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n//\t2. Improve the module's maintainability by reducing the storage\n//\t\tpaths to a single mechanism.\n//\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n//\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n//\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n//\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\nvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\trmultiDash = /[A-Z]/g;\n\nfunction getData( data ) {\n\tif ( data === \"true\" ) {\n\t\treturn true;\n\t}\n\n\tif ( data === \"false\" ) {\n\t\treturn false;\n\t}\n\n\tif ( data === \"null\" ) {\n\t\treturn null;\n\t}\n\n\t// Only convert to a number if it doesn't change the string\n\tif ( data === +data + \"\" ) {\n\t\treturn +data;\n\t}\n\n\tif ( rbrace.test( data ) ) {\n\t\treturn JSON.parse( data );\n\t}\n\n\treturn data;\n}\n\nfunction dataAttr( elem, key, data ) {\n\tvar name;\n\n\t// If nothing was found internally, try to fetch any\n\t// data from the HTML5 data-* attribute\n\tif ( data === undefined && elem.nodeType === 1 ) {\n\t\tname = \"data-\" + key.replace( rmultiDash, \"-$&\" ).toLowerCase();\n\t\tdata = elem.getAttribute( name );\n\n\t\tif ( typeof data === \"string\" ) {\n\t\t\ttry {\n\t\t\t\tdata = getData( data );\n\t\t\t} catch ( e ) {}\n\n\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\tdataUser.set( elem, key, data );\n\t\t} else {\n\t\t\tdata = undefined;\n\t\t}\n\t}\n\treturn data;\n}\n\njQuery.extend( {\n\thasData: function( elem ) {\n\t\treturn dataUser.hasData( elem ) || dataPriv.hasData( elem );\n\t},\n\n\tdata: function( elem, name, data ) {\n\t\treturn dataUser.access( elem, name, data );\n\t},\n\n\tremoveData: function( elem, name ) {\n\t\tdataUser.remove( elem, name );\n\t},\n\n\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t// with direct calls to dataPriv methods, these can be deprecated.\n\t_data: function( elem, name, data ) {\n\t\treturn dataPriv.access( elem, name, data );\n\t},\n\n\t_removeData: function( elem, name ) {\n\t\tdataPriv.remove( elem, name );\n\t}\n} );\n\njQuery.fn.extend( {\n\tdata: function( key, value ) {\n\t\tvar i, name, data,\n\t\t\telem = this[ 0 ],\n\t\t\tattrs = elem && elem.attributes;\n\n\t\t// Gets all values\n\t\tif ( key === undefined ) {\n\t\t\tif ( this.length ) {\n\t\t\t\tdata = dataUser.get( elem );\n\n\t\t\t\tif ( elem.nodeType === 1 && !dataPriv.get( elem, \"hasDataAttrs\" ) ) {\n\t\t\t\t\ti = attrs.length;\n\t\t\t\t\twhile ( i-- ) {\n\n\t\t\t\t\t\t// Support: IE 11 only\n\t\t\t\t\t\t// The attrs elements can be null (#14894)\n\t\t\t\t\t\tif ( attrs[ i ] ) {\n\t\t\t\t\t\t\tname = attrs[ i ].name;\n\t\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n\t\t\t\t\t\t\t\tname = jQuery.camelCase( name.slice( 5 ) );\n\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdataPriv.set( elem, \"hasDataAttrs\", true );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\t// Sets multiple values\n\t\tif ( typeof key === \"object\" ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tdataUser.set( this, key );\n\t\t\t} );\n\t\t}\n\n\t\treturn access( this, function( value ) {\n\t\t\tvar data;\n\n\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\tif ( elem && value === undefined ) {\n\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// The key will always be camelCased in Data\n\t\t\t\tdata = dataUser.get( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to \"discover\" the data in\n\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\tdata = dataAttr( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// We tried really hard, but the data doesn't exist.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set the data...\n\t\t\tthis.each( function() {\n\n\t\t\t\t// We always store the camelCased key\n\t\t\t\tdataUser.set( this, key, value );\n\t\t\t} );\n\t\t}, null, value, arguments.length > 1, null, true );\n\t},\n\n\tremoveData: function( key ) {\n\t\treturn this.each( function() {\n\t\t\tdataUser.remove( this, key );\n\t\t} );\n\t}\n} );\n\n\njQuery.extend( {\n\tqueue: function( elem, type, data ) {\n\t\tvar queue;\n\n\t\tif ( elem ) {\n\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\t\t\tqueue = dataPriv.get( elem, type );\n\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\tif ( data ) {\n\t\t\t\tif ( !queue || Array.isArray( data ) ) {\n\t\t\t\t\tqueue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queue || [];\n\t\t}\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || \"fx\";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tstartLength = queue.length,\n\t\t\tfn = queue.shift(),\n\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\tnext = function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t};\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === \"inprogress\" ) {\n\t\t\tfn = queue.shift();\n\t\t\tstartLength--;\n\t\t}\n\n\t\tif ( fn ) {\n\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === \"fx\" ) {\n\t\t\t\tqueue.unshift( \"inprogress\" );\n\t\t\t}\n\n\t\t\t// Clear up the last queue stop function\n\t\t\tdelete hooks.stop;\n\t\t\tfn.call( elem, next, hooks );\n\t\t}\n\n\t\tif ( !startLength && hooks ) {\n\t\t\thooks.empty.fire();\n\t\t}\n\t},\n\n\t// Not public - generate a queueHooks object, or return the current one\n\t_queueHooks: function( elem, type ) {\n\t\tvar key = type + \"queueHooks\";\n\t\treturn dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\n\t\t\tempty: jQuery.Callbacks( \"once memory\" ).add( function() {\n\t\t\t\tdataPriv.remove( elem, [ type + \"queue\", key ] );\n\t\t\t} )\n\t\t} );\n\t}\n} );\n\njQuery.fn.extend( {\n\tqueue: function( type, data ) {\n\t\tvar setter = 2;\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tdata = type;\n\t\t\ttype = \"fx\";\n\t\t\tsetter--;\n\t\t}\n\n\t\tif ( arguments.length < setter ) {\n\t\t\treturn jQuery.queue( this[ 0 ], type );\n\t\t}\n\n\t\treturn data === undefined ?\n\t\t\tthis :\n\t\t\tthis.each( function() {\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t// Ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\tif ( type === \"fx\" && queue[ 0 ] !== \"inprogress\" ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t} );\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t} );\n\t},\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || \"fx\", [] );\n\t},\n\n\t// Get a promise resolved when queues of a certain type\n\t// are emptied (fx is the type by default)\n\tpromise: function( type, obj ) {\n\t\tvar tmp,\n\t\t\tcount = 1,\n\t\t\tdefer = jQuery.Deferred(),\n\t\t\telements = this,\n\t\t\ti = this.length,\n\t\t\tresolve = function() {\n\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tobj = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\ttype = type || \"fx\";\n\n\t\twhile ( i-- ) {\n\t\t\ttmp = dataPriv.get( elements[ i ], type + \"queueHooks\" );\n\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\tcount++;\n\t\t\t\ttmp.empty.add( resolve );\n\t\t\t}\n\t\t}\n\t\tresolve();\n\t\treturn defer.promise( obj );\n\t}\n} );\nvar pnum = ( /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/ ).source;\n\nvar rcssNum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" );\n\n\nvar cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\n\nvar isHiddenWithinTree = function( elem, el ) {\n\n\t\t// isHiddenWithinTree might be called from jQuery#filter function;\n\t\t// in that case, element will be second argument\n\t\telem = el || elem;\n\n\t\t// Inline style trumps all\n\t\treturn elem.style.display === \"none\" ||\n\t\t\telem.style.display === \"\" &&\n\n\t\t\t// Otherwise, check computed style\n\t\t\t// Support: Firefox <=43 - 45\n\t\t\t// Disconnected elements can have computed display: none, so first confirm that elem is\n\t\t\t// in the document.\n\t\t\tjQuery.contains( elem.ownerDocument, elem ) &&\n\n\t\t\tjQuery.css( elem, \"display\" ) === \"none\";\n\t};\n\nvar swap = function( elem, options, callback, args ) {\n\tvar ret, name,\n\t\told = {};\n\n\t// Remember the old values, and insert the new ones\n\tfor ( name in options ) {\n\t\told[ name ] = elem.style[ name ];\n\t\telem.style[ name ] = options[ name ];\n\t}\n\n\tret = callback.apply( elem, args || [] );\n\n\t// Revert the old values\n\tfor ( name in options ) {\n\t\telem.style[ name ] = old[ name ];\n\t}\n\n\treturn ret;\n};\n\n\n\n\nfunction adjustCSS( elem, prop, valueParts, tween ) {\n\tvar adjusted,\n\t\tscale = 1,\n\t\tmaxIterations = 20,\n\t\tcurrentValue = tween ?\n\t\t\tfunction() {\n\t\t\t\treturn tween.cur();\n\t\t\t} :\n\t\t\tfunction() {\n\t\t\t\treturn jQuery.css( elem, prop, \"\" );\n\t\t\t},\n\t\tinitial = currentValue(),\n\t\tunit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n\n\t\t// Starting value computation is required for potential unit mismatches\n\t\tinitialInUnit = ( jQuery.cssNumber[ prop ] || unit !== \"px\" && +initial ) &&\n\t\t\trcssNum.exec( jQuery.css( elem, prop ) );\n\n\tif ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\n\n\t\t// Trust units reported by jQuery.css\n\t\tunit = unit || initialInUnit[ 3 ];\n\n\t\t// Make sure we update the tween properties later on\n\t\tvalueParts = valueParts || [];\n\n\t\t// Iteratively approximate from a nonzero starting point\n\t\tinitialInUnit = +initial || 1;\n\n\t\tdo {\n\n\t\t\t// If previous iteration zeroed out, double until we get *something*.\n\t\t\t// Use string for doubling so we don't accidentally see scale as unchanged below\n\t\t\tscale = scale || \".5\";\n\n\t\t\t// Adjust and apply\n\t\t\tinitialInUnit = initialInUnit / scale;\n\t\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\n\t\t// Update scale, tolerating zero or NaN from tween.cur()\n\t\t// Break the loop if scale is unchanged or perfect, or if we've just had enough.\n\t\t} while (\n\t\t\tscale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations\n\t\t);\n\t}\n\n\tif ( valueParts ) {\n\t\tinitialInUnit = +initialInUnit || +initial || 0;\n\n\t\t// Apply relative offset (+=/-=) if specified\n\t\tadjusted = valueParts[ 1 ] ?\n\t\t\tinitialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\n\t\t\t+valueParts[ 2 ];\n\t\tif ( tween ) {\n\t\t\ttween.unit = unit;\n\t\t\ttween.start = initialInUnit;\n\t\t\ttween.end = adjusted;\n\t\t}\n\t}\n\treturn adjusted;\n}\n\n\nvar defaultDisplayMap = {};\n\nfunction getDefaultDisplay( elem ) {\n\tvar temp,\n\t\tdoc = elem.ownerDocument,\n\t\tnodeName = elem.nodeName,\n\t\tdisplay = defaultDisplayMap[ nodeName ];\n\n\tif ( display ) {\n\t\treturn display;\n\t}\n\n\ttemp = doc.body.appendChild( doc.createElement( nodeName ) );\n\tdisplay = jQuery.css( temp, \"display\" );\n\n\ttemp.parentNode.removeChild( temp );\n\n\tif ( display === \"none\" ) {\n\t\tdisplay = \"block\";\n\t}\n\tdefaultDisplayMap[ nodeName ] = display;\n\n\treturn display;\n}\n\nfunction showHide( elements, show ) {\n\tvar display, elem,\n\t\tvalues = [],\n\t\tindex = 0,\n\t\tlength = elements.length;\n\n\t// Determine new display value for elements that need to change\n\tfor ( ; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdisplay = elem.style.display;\n\t\tif ( show ) {\n\n\t\t\t// Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n\t\t\t// check is required in this first loop unless we have a nonempty display value (either\n\t\t\t// inline or about-to-be-restored)\n\t\t\tif ( display === \"none\" ) {\n\t\t\t\tvalues[ index ] = dataPriv.get( elem, \"display\" ) || null;\n\t\t\t\tif ( !values[ index ] ) {\n\t\t\t\t\telem.style.display = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( elem.style.display === \"\" && isHiddenWithinTree( elem ) ) {\n\t\t\t\tvalues[ index ] = getDefaultDisplay( elem );\n\t\t\t}\n\t\t} else {\n\t\t\tif ( display !== \"none\" ) {\n\t\t\t\tvalues[ index ] = \"none\";\n\n\t\t\t\t// Remember what we're overwriting\n\t\t\t\tdataPriv.set( elem, \"display\", display );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the display of the elements in a second loop to avoid constant reflow\n\tfor ( index = 0; index < length; index++ ) {\n\t\tif ( values[ index ] != null ) {\n\t\t\telements[ index ].style.display = values[ index ];\n\t\t}\n\t}\n\n\treturn elements;\n}\n\njQuery.fn.extend( {\n\tshow: function() {\n\t\treturn showHide( this, true );\n\t},\n\thide: function() {\n\t\treturn showHide( this );\n\t},\n\ttoggle: function( state ) {\n\t\tif ( typeof state === \"boolean\" ) {\n\t\t\treturn state ? this.show() : this.hide();\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tif ( isHiddenWithinTree( this ) ) {\n\t\t\t\tjQuery( this ).show();\n\t\t\t} else {\n\t\t\t\tjQuery( this ).hide();\n\t\t\t}\n\t\t} );\n\t}\n} );\nvar rcheckableType = ( /^(?:checkbox|radio)$/i );\n\nvar rtagName = ( /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]+)/i );\n\nvar rscriptType = ( /^$|\\/(?:java|ecma)script/i );\n\n\n\n// We have to close these tags to support XHTML (#13200)\nvar wrapMap = {\n\n\t// Support: IE <=9 only\n\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n\n\t// XHTML parsers do not magically insert elements in the\n\t// same way that tag soup parsers do. So we cannot shorten\n\t// this by omitting <tbody> or other required elements.\n\tthead: [ 1, \"<table>\", \"</table>\" ],\n\tcol: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\n\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\n\t_default: [ 0, \"\", \"\" ]\n};\n\n// Support: IE <=9 only\nwrapMap.optgroup = wrapMap.option;\n\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\n\nfunction getAll( context, tag ) {\n\n\t// Support: IE <=9 - 11 only\n\t// Use typeof to avoid zero-argument method invocation on host objects (#15151)\n\tvar ret;\n\n\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\tret = context.getElementsByTagName( tag || \"*\" );\n\n\t} else if ( typeof context.querySelectorAll !== \"undefined\" ) {\n\t\tret = context.querySelectorAll( tag || \"*\" );\n\n\t} else {\n\t\tret = [];\n\t}\n\n\tif ( tag === undefined || tag && nodeName( context, tag ) ) {\n\t\treturn jQuery.merge( [ context ], ret );\n\t}\n\n\treturn ret;\n}\n\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n\tvar i = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\tdataPriv.set(\n\t\t\telems[ i ],\n\t\t\t\"globalEval\",\n\t\t\t!refElements || dataPriv.get( refElements[ i ], \"globalEval\" )\n\t\t);\n\t}\n}\n\n\nvar rhtml = /<|&#?\\w+;/;\n\nfunction buildFragment( elems, context, scripts, selection, ignored ) {\n\tvar elem, tmp, tag, wrap, contains, j,\n\t\tfragment = context.createDocumentFragment(),\n\t\tnodes = [],\n\t\ti = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\telem = elems[ i ];\n\n\t\tif ( elem || elem === 0 ) {\n\n\t\t\t// Add nodes directly\n\t\t\tif ( jQuery.type( elem ) === \"object\" ) {\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n\t\t\t// Convert non-html into a text node\n\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\n\t\t\t// Convert html into DOM nodes\n\t\t\t} else {\n\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement( \"div\" ) );\n\n\t\t\t\t// Deserialize a standard representation\n\t\t\t\ttag = ( rtagName.exec( elem ) || [ \"\", \"\" ] )[ 1 ].toLowerCase();\n\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\t\t\t\ttmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\n\n\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\tj = wrap[ 0 ];\n\t\t\t\twhile ( j-- ) {\n\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t}\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\n\t\t\t\t// Remember the top-level container\n\t\t\t\ttmp = fragment.firstChild;\n\n\t\t\t\t// Ensure the created nodes are orphaned (#12392)\n\t\t\t\ttmp.textContent = \"\";\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove wrapper from fragment\n\tfragment.textContent = \"\";\n\n\ti = 0;\n\twhile ( ( elem = nodes[ i++ ] ) ) {\n\n\t\t// Skip elements already in the context collection (trac-4087)\n\t\tif ( selection && jQuery.inArray( elem, selection ) > -1 ) {\n\t\t\tif ( ignored ) {\n\t\t\t\tignored.push( elem );\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tcontains = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Append to fragment\n\t\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\n\n\t\t// Preserve script evaluation history\n\t\tif ( contains ) {\n\t\t\tsetGlobalEval( tmp );\n\t\t}\n\n\t\t// Capture executables\n\t\tif ( scripts ) {\n\t\t\tj = 0;\n\t\t\twhile ( ( elem = tmp[ j++ ] ) ) {\n\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n\t\t\t\t\tscripts.push( elem );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn fragment;\n}\n\n\n( function() {\n\tvar fragment = document.createDocumentFragment(),\n\t\tdiv = fragment.appendChild( document.createElement( \"div\" ) ),\n\t\tinput = document.createElement( \"input\" );\n\n\t// Support: Android 4.0 - 4.3 only\n\t// Check state lost if the name is set (#11217)\n\t// Support: Windows Web Apps (WWA)\n\t// `name` and `type` must use .setAttribute for WWA (#14901)\n\tinput.setAttribute( \"type\", \"radio\" );\n\tinput.setAttribute( \"checked\", \"checked\" );\n\tinput.setAttribute( \"name\", \"t\" );\n\n\tdiv.appendChild( input );\n\n\t// Support: Android <=4.1 only\n\t// Older WebKit doesn't clone checked state correctly in fragments\n\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t// Support: IE <=11 only\n\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\tdiv.innerHTML = \"<textarea>x</textarea>\";\n\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n} )();\nvar documentElement = document.documentElement;\n\n\n\nvar\n\trkeyEvent = /^key/,\n\trmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n\trtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n\nfunction returnTrue() {\n\treturn true;\n}\n\nfunction returnFalse() {\n\treturn false;\n}\n\n// Support: IE <=9 only\n// See #13393 for more info\nfunction safeActiveElement() {\n\ttry {\n\t\treturn document.activeElement;\n\t} catch ( err ) { }\n}\n\nfunction on( elem, types, selector, data, fn, one ) {\n\tvar origFn, type;\n\n\t// Types can be a map of types/handlers\n\tif ( typeof types === \"object\" ) {\n\n\t\t// ( types-Object, selector, data )\n\t\tif ( typeof selector !== \"string\" ) {\n\n\t\t\t// ( types-Object, data )\n\t\t\tdata = data || selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tfor ( type in types ) {\n\t\t\ton( elem, type, selector, data, types[ type ], one );\n\t\t}\n\t\treturn elem;\n\t}\n\n\tif ( data == null && fn == null ) {\n\n\t\t// ( types, fn )\n\t\tfn = selector;\n\t\tdata = selector = undefined;\n\t} else if ( fn == null ) {\n\t\tif ( typeof selector === \"string\" ) {\n\n\t\t\t// ( types, selector, fn )\n\t\t\tfn = data;\n\t\t\tdata = undefined;\n\t\t} else {\n\n\t\t\t// ( types, data, fn )\n\t\t\tfn = data;\n\t\t\tdata = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t}\n\tif ( fn === false ) {\n\t\tfn = returnFalse;\n\t} else if ( !fn ) {\n\t\treturn elem;\n\t}\n\n\tif ( one === 1 ) {\n\t\torigFn = fn;\n\t\tfn = function( event ) {\n\n\t\t\t// Can use an empty set, since event contains the info\n\t\t\tjQuery().off( event );\n\t\t\treturn origFn.apply( this, arguments );\n\t\t};\n\n\t\t// Use same guid so caller can remove using origFn\n\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t}\n\treturn elem.each( function() {\n\t\tjQuery.event.add( this, types, fn, data, selector );\n\t} );\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n\tglobal: {},\n\n\tadd: function( elem, types, handler, data, selector ) {\n\n\t\tvar handleObjIn, eventHandle, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.get( elem );\n\n\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\n\t\tif ( !elemData ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\tif ( handler.handler ) {\n\t\t\thandleObjIn = handler;\n\t\t\thandler = handleObjIn.handler;\n\t\t\tselector = handleObjIn.selector;\n\t\t}\n\n\t\t// Ensure that invalid selectors throw exceptions at attach time\n\t\t// Evaluate against documentElement in case elem is a non-element node (e.g., document)\n\t\tif ( selector ) {\n\t\t\tjQuery.find.matchesSelector( documentElement, selector );\n\t\t}\n\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = jQuery.guid++;\n\t\t}\n\n\t\t// Init the element's event structure and main handler, if this is the first\n\t\tif ( !( events = elemData.events ) ) {\n\t\t\tevents = elemData.events = {};\n\t\t}\n\t\tif ( !( eventHandle = elemData.handle ) ) {\n\t\t\teventHandle = elemData.handle = function( e ) {\n\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== \"undefined\" && jQuery.event.triggered !== e.type ?\n\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\n\t\t\t};\n\t\t}\n\n\t\t// Handle multiple events separated by a space\n\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\tif ( !type ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t// Update special based on newly reset type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// handleObj is passed to all event handlers\n\t\t\thandleObj = jQuery.extend( {\n\t\t\t\ttype: type,\n\t\t\t\torigType: origType,\n\t\t\t\tdata: data,\n\t\t\t\thandler: handler,\n\t\t\t\tguid: handler.guid,\n\t\t\t\tselector: selector,\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\tnamespace: namespaces.join( \".\" )\n\t\t\t}, handleObjIn );\n\n\t\t\t// Init the event handler queue if we're the first\n\t\t\tif ( !( handlers = events[ type ] ) ) {\n\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\tif ( !special.setup ||\n\t\t\t\t\tspecial.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, eventHandle );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( special.add ) {\n\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to the element's handler list, delegates in front\n\t\t\tif ( selector ) {\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t} else {\n\t\t\t\thandlers.push( handleObj );\n\t\t\t}\n\n\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\tjQuery.event.global[ type ] = true;\n\t\t}\n\n\t},\n\n\t// Detach an event or set of events from an element\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\n\t\tvar j, origCount, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.hasData( elem ) && dataPriv.get( elem );\n\n\t\tif ( !elemData || !( events = elemData.events ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Once for each type.namespace in types; type may be omitted\n\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\tif ( !type ) {\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\thandlers = events[ type ] || [];\n\t\t\ttmp = tmp[ 2 ] &&\n\t\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" );\n\n\t\t\t// Remove matching events\n\t\t\torigCount = j = handlers.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\thandleObj = handlers[ j ];\n\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t( !selector || selector === handleObj.selector ||\n\t\t\t\t\t\tselector === \"**\" && handleObj.selector ) ) {\n\t\t\t\t\thandlers.splice( j, 1 );\n\n\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\tif ( !special.teardown ||\n\t\t\t\t\tspecial.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t}\n\n\t\t\t\tdelete events[ type ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove data and the expando if it's no longer used\n\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\tdataPriv.remove( elem, \"handle events\" );\n\t\t}\n\t},\n\n\tdispatch: function( nativeEvent ) {\n\n\t\t// Make a writable jQuery.Event from the native event object\n\t\tvar event = jQuery.event.fix( nativeEvent );\n\n\t\tvar i, j, ret, matched, handleObj, handlerQueue,\n\t\t\targs = new Array( arguments.length ),\n\t\t\thandlers = ( dataPriv.get( this, \"events\" ) || {} )[ event.type ] || [],\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\targs[ 0 ] = event;\n\n\t\tfor ( i = 1; i < arguments.length; i++ ) {\n\t\t\targs[ i ] = arguments[ i ];\n\t\t}\n\n\t\tevent.delegateTarget = this;\n\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine handlers\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\ti = 0;\n\t\twhile ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\tj = 0;\n\t\t\twhile ( ( handleObj = matched.handlers[ j++ ] ) &&\n\t\t\t\t!event.isImmediatePropagationStopped() ) {\n\n\t\t\t\t// Triggered event must either 1) have no namespace, or 2) have namespace(s)\n\t\t\t\t// a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\tif ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {\n\n\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\tret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\n\t\t\t\t\t\thandleObj.handler ).apply( matched.elem, args );\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\tif ( ( event.result = ret ) === false ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Call the postDispatch hook for the mapped type\n\t\tif ( special.postDispatch ) {\n\t\t\tspecial.postDispatch.call( this, event );\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\thandlers: function( event, handlers ) {\n\t\tvar i, handleObj, sel, matchedHandlers, matchedSelectors,\n\t\t\thandlerQueue = [],\n\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\tcur = event.target;\n\n\t\t// Find delegate handlers\n\t\tif ( delegateCount &&\n\n\t\t\t// Support: IE <=9\n\t\t\t// Black-hole SVG <use> instance trees (trac-13180)\n\t\t\tcur.nodeType &&\n\n\t\t\t// Support: Firefox <=42\n\t\t\t// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n\t\t\t// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n\t\t\t// Support: IE 11 only\n\t\t\t// ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n\t\t\t!( event.type === \"click\" && event.button >= 1 ) ) {\n\n\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n\n\t\t\t\t// Don't check non-elements (#13208)\n\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\tif ( cur.nodeType === 1 && !( event.type === \"click\" && cur.disabled === true ) ) {\n\t\t\t\t\tmatchedHandlers = [];\n\t\t\t\t\tmatchedSelectors = {};\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\thandleObj = handlers[ i ];\n\n\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] === undefined ) {\n\t\t\t\t\t\t\tmatchedSelectors[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) > -1 :\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] ) {\n\t\t\t\t\t\t\tmatchedHandlers.push( handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( matchedHandlers.length ) {\n\t\t\t\t\t\thandlerQueue.push( { elem: cur, handlers: matchedHandlers } );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add the remaining (directly-bound) handlers\n\t\tcur = this;\n\t\tif ( delegateCount < handlers.length ) {\n\t\t\thandlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );\n\t\t}\n\n\t\treturn handlerQueue;\n\t},\n\n\taddProp: function( name, hook ) {\n\t\tObject.defineProperty( jQuery.Event.prototype, name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\n\t\t\tget: jQuery.isFunction( hook ) ?\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\treturn hook( this.originalEvent );\n\t\t\t\t\t}\n\t\t\t\t} :\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\treturn this.originalEvent[ name ];\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\tset: function( value ) {\n\t\t\t\tObject.defineProperty( this, name, {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\twritable: true,\n\t\t\t\t\tvalue: value\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\t},\n\n\tfix: function( originalEvent ) {\n\t\treturn originalEvent[ jQuery.expando ] ?\n\t\t\toriginalEvent :\n\t\t\tnew jQuery.Event( originalEvent );\n\t},\n\n\tspecial: {\n\t\tload: {\n\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\tnoBubble: true\n\t\t},\n\t\tfocus: {\n\n\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this !== safeActiveElement() && this.focus ) {\n\t\t\t\t\tthis.focus();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusin\"\n\t\t},\n\t\tblur: {\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this === safeActiveElement() && this.blur ) {\n\t\t\t\t\tthis.blur();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusout\"\n\t\t},\n\t\tclick: {\n\n\t\t\t// For checkbox, fire native event so checked state will be right\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this.type === \"checkbox\" && this.click && nodeName( this, \"input\" ) ) {\n\t\t\t\t\tthis.click();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// For cross-browser consistency, don't fire native .click() on links\n\t\t\t_default: function( event ) {\n\t\t\t\treturn nodeName( event.target, \"a\" );\n\t\t\t}\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t// Support: Firefox 20+\n\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\njQuery.removeEvent = function( elem, type, handle ) {\n\n\t// This \"if\" is needed for plain objects\n\tif ( elem.removeEventListener ) {\n\t\telem.removeEventListener( type, handle );\n\t}\n};\n\njQuery.Event = function( src, props ) {\n\n\t// Allow instantiation without the 'new' keyword\n\tif ( !( this instanceof jQuery.Event ) ) {\n\t\treturn new jQuery.Event( src, props );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n\t\t\t\tsrc.defaultPrevented === undefined &&\n\n\t\t\t\t// Support: Android <=2.3 only\n\t\t\t\tsrc.returnValue === false ?\n\t\t\treturnTrue :\n\t\t\treturnFalse;\n\n\t\t// Create target properties\n\t\t// Support: Safari <=6 - 7 only\n\t\t// Target should not be a text node (#504, #13143)\n\t\tthis.target = ( src.target && src.target.nodeType === 3 ) ?\n\t\t\tsrc.target.parentNode :\n\t\t\tsrc.target;\n\n\t\tthis.currentTarget = src.currentTarget;\n\t\tthis.relatedTarget = src.relatedTarget;\n\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// Put explicitly provided properties onto the event object\n\tif ( props ) {\n\t\tjQuery.extend( this, props );\n\t}\n\n\t// Create a timestamp if incoming event doesn't have one\n\tthis.timeStamp = src && src.timeStamp || jQuery.now();\n\n\t// Mark it as fixed\n\tthis[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tconstructor: jQuery.Event,\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse,\n\tisSimulated: false,\n\n\tpreventDefault: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isDefaultPrevented = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.preventDefault();\n\t\t}\n\t},\n\tstopPropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isPropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopPropagation();\n\t\t}\n\t},\n\tstopImmediatePropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopImmediatePropagation();\n\t\t}\n\n\t\tthis.stopPropagation();\n\t}\n};\n\n// Includes all common event props including KeyEvent and MouseEvent specific props\njQuery.each( {\n\taltKey: true,\n\tbubbles: true,\n\tcancelable: true,\n\tchangedTouches: true,\n\tctrlKey: true,\n\tdetail: true,\n\teventPhase: true,\n\tmetaKey: true,\n\tpageX: true,\n\tpageY: true,\n\tshiftKey: true,\n\tview: true,\n\t\"char\": true,\n\tcharCode: true,\n\tkey: true,\n\tkeyCode: true,\n\tbutton: true,\n\tbuttons: true,\n\tclientX: true,\n\tclientY: true,\n\toffsetX: true,\n\toffsetY: true,\n\tpointerId: true,\n\tpointerType: true,\n\tscreenX: true,\n\tscreenY: true,\n\ttargetTouches: true,\n\ttoElement: true,\n\ttouches: true,\n\n\twhich: function( event ) {\n\t\tvar button = event.button;\n\n\t\t// Add which for key events\n\t\tif ( event.which == null && rkeyEvent.test( event.type ) ) {\n\t\t\treturn event.charCode != null ? event.charCode : event.keyCode;\n\t\t}\n\n\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\tif ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {\n\t\t\tif ( button & 1 ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif ( button & 2 ) {\n\t\t\t\treturn 3;\n\t\t\t}\n\n\t\t\tif ( button & 4 ) {\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn event.which;\n\t}\n}, jQuery.event.addProp );\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\n// so that event delegation works in jQuery.\n// Do the same for pointerenter/pointerleave and pointerover/pointerout\n//\n// Support: Safari 7 only\n// Safari sends mouseenter too often; see:\n// https://bugs.chromium.org/p/chromium/issues/detail?id=470258\n// for the description of the bug (it existed in older Chrome versions as well).\njQuery.each( {\n\tmouseenter: \"mouseover\",\n\tmouseleave: \"mouseout\",\n\tpointerenter: \"pointerover\",\n\tpointerleave: \"pointerout\"\n}, function( orig, fix ) {\n\tjQuery.event.special[ orig ] = {\n\t\tdelegateType: fix,\n\t\tbindType: fix,\n\n\t\thandle: function( event ) {\n\t\t\tvar ret,\n\t\t\t\ttarget = this,\n\t\t\t\trelated = event.relatedTarget,\n\t\t\t\thandleObj = event.handleObj;\n\n\t\t\t// For mouseenter/leave call the handler if related is outside the target.\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\tif ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\n\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\tevent.type = fix;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n} );\n\njQuery.fn.extend( {\n\n\ton: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn );\n\t},\n\tone: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn, 1 );\n\t},\n\toff: function( types, selector, fn ) {\n\t\tvar handleObj, type;\n\t\tif ( types && types.preventDefault && types.handleObj ) {\n\n\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\thandleObj = types.handleObj;\n\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\thandleObj.namespace ?\n\t\t\t\t\thandleObj.origType + \".\" + handleObj.namespace :\n\t\t\t\t\thandleObj.origType,\n\t\t\t\thandleObj.selector,\n\t\t\t\thandleObj.handler\n\t\t\t);\n\t\t\treturn this;\n\t\t}\n\t\tif ( typeof types === \"object\" ) {\n\n\t\t\t// ( types-object [, selector] )\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tif ( selector === false || typeof selector === \"function\" ) {\n\n\t\t\t// ( types [, fn] )\n\t\t\tfn = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t} );\n\t}\n} );\n\n\nvar\n\n\t/* eslint-disable max-len */\n\n\t// See https://github.com/eslint/eslint/issues/3229\n\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)[^>]*)\\/>/gi,\n\n\t/* eslint-enable */\n\n\t// Support: IE <=10 - 11, Edge 12 - 13\n\t// In IE/Edge using regex groups here causes severe slowdowns.\n\t// See https://connect.microsoft.com/IE/feedback/details/1736512/\n\trnoInnerhtml = /<script|<style|<link/i,\n\n\t// checked=\"checked\" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\trscriptTypeMasked = /^true\\/(.*)/,\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;\n\n// Prefer a tbody over its parent table for containing new rows\nfunction manipulationTarget( elem, content ) {\n\tif ( nodeName( elem, \"table\" ) &&\n\t\tnodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ) {\n\n\t\treturn jQuery( \">tbody\", elem )[ 0 ] || elem;\n\t}\n\n\treturn elem;\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n\telem.type = ( elem.getAttribute( \"type\" ) !== null ) + \"/\" + elem.type;\n\treturn elem;\n}\nfunction restoreScript( elem ) {\n\tvar match = rscriptTypeMasked.exec( elem.type );\n\n\tif ( match ) {\n\t\telem.type = match[ 1 ];\n\t} else {\n\t\telem.removeAttribute( \"type\" );\n\t}\n\n\treturn elem;\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\n\tif ( dest.nodeType !== 1 ) {\n\t\treturn;\n\t}\n\n\t// 1. Copy private data: events, handlers, etc.\n\tif ( dataPriv.hasData( src ) ) {\n\t\tpdataOld = dataPriv.access( src );\n\t\tpdataCur = dataPriv.set( dest, pdataOld );\n\t\tevents = pdataOld.events;\n\n\t\tif ( events ) {\n\t\t\tdelete pdataCur.handle;\n\t\t\tpdataCur.events = {};\n\n\t\t\tfor ( type in events ) {\n\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 2. Copy user data\n\tif ( dataUser.hasData( src ) ) {\n\t\tudataOld = dataUser.access( src );\n\t\tudataCur = jQuery.extend( {}, udataOld );\n\n\t\tdataUser.set( dest, udataCur );\n\t}\n}\n\n// Fix IE bugs, see support tests\nfunction fixInput( src, dest ) {\n\tvar nodeName = dest.nodeName.toLowerCase();\n\n\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\tif ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\n\t\tdest.checked = src.checked;\n\n\t// Fails to return the selected option to the default selected state when cloning options\n\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\t\tdest.defaultValue = src.defaultValue;\n\t}\n}\n\nfunction domManip( collection, args, callback, ignored ) {\n\n\t// Flatten any nested arrays\n\targs = concat.apply( [], args );\n\n\tvar fragment, first, scripts, hasScripts, node, doc,\n\t\ti = 0,\n\t\tl = collection.length,\n\t\tiNoClone = l - 1,\n\t\tvalue = args[ 0 ],\n\t\tisFunction = jQuery.isFunction( value );\n\n\t// We can't cloneNode fragments that contain checked, in WebKit\n\tif ( isFunction ||\n\t\t\t( l > 1 && typeof value === \"string\" &&\n\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n\t\treturn collection.each( function( index ) {\n\t\t\tvar self = collection.eq( index );\n\t\t\tif ( isFunction ) {\n\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n\t\t\t}\n\t\t\tdomManip( self, args, callback, ignored );\n\t\t} );\n\t}\n\n\tif ( l ) {\n\t\tfragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\n\t\tfirst = fragment.firstChild;\n\n\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\tfragment = first;\n\t\t}\n\n\t\t// Require either new content or an interest in ignored elements to invoke the callback\n\t\tif ( first || ignored ) {\n\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n\t\t\thasScripts = scripts.length;\n\n\t\t\t// Use the original fragment for the last item\n\t\t\t// instead of the first because it can end up\n\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tnode = fragment;\n\n\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\n\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\tif ( hasScripts ) {\n\n\t\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcallback.call( collection[ i ], node, i );\n\t\t\t}\n\n\t\t\tif ( hasScripts ) {\n\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\n\t\t\t\t// Reenable scripts\n\t\t\t\tjQuery.map( scripts, restoreScript );\n\n\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n\t\t\t\t\t\t!dataPriv.access( node, \"globalEval\" ) &&\n\t\t\t\t\t\tjQuery.contains( doc, node ) ) {\n\n\t\t\t\t\t\tif ( node.src ) {\n\n\t\t\t\t\t\t\t// Optional AJAX dependency, but won't run scripts if not present\n\t\t\t\t\t\t\tif ( jQuery._evalUrl ) {\n\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDOMEval( node.textContent.replace( rcleanScript, \"\" ), doc );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn collection;\n}\n\nfunction remove( elem, selector, keepData ) {\n\tvar node,\n\t\tnodes = selector ? jQuery.filter( selector, elem ) : elem,\n\t\ti = 0;\n\n\tfor ( ; ( node = nodes[ i ] ) != null; i++ ) {\n\t\tif ( !keepData && node.nodeType === 1 ) {\n\t\t\tjQuery.cleanData( getAll( node ) );\n\t\t}\n\n\t\tif ( node.parentNode ) {\n\t\t\tif ( keepData && jQuery.contains( node.ownerDocument, node ) ) {\n\t\t\t\tsetGlobalEval( getAll( node, \"script\" ) );\n\t\t\t}\n\t\t\tnode.parentNode.removeChild( node );\n\t\t}\n\t}\n\n\treturn elem;\n}\n\njQuery.extend( {\n\thtmlPrefilter: function( html ) {\n\t\treturn html.replace( rxhtmlTag, \"<$1></$2>\" );\n\t},\n\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\tvar i, l, srcElements, destElements,\n\t\t\tclone = elem.cloneNode( true ),\n\t\t\tinPage = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Fix IE cloning issues\n\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\n\t\t\tdestElements = getAll( clone );\n\t\t\tsrcElements = getAll( elem );\n\n\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n\t\t\t}\n\t\t}\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( dataAndEvents ) {\n\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\tdestElements = destElements || getAll( clone );\n\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t}\n\t\t}\n\n\t\t// Preserve script evaluation history\n\t\tdestElements = getAll( clone, \"script\" );\n\t\tif ( destElements.length > 0 ) {\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n\t\t}\n\n\t\t// Return the cloned set\n\t\treturn clone;\n\t},\n\n\tcleanData: function( elems ) {\n\t\tvar data, elem, type,\n\t\t\tspecial = jQuery.event.special,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\n\t\t\tif ( acceptData( elem ) ) {\n\t\t\t\tif ( ( data = elem[ dataPriv.expando ] ) ) {\n\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataPriv.expando ] = undefined;\n\t\t\t\t}\n\t\t\t\tif ( elem[ dataUser.expando ] ) {\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataUser.expando ] = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} );\n\njQuery.fn.extend( {\n\tdetach: function( selector ) {\n\t\treturn remove( this, selector, true );\n\t},\n\n\tremove: function( selector ) {\n\t\treturn remove( this, selector );\n\t},\n\n\ttext: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\treturn value === undefined ?\n\t\t\t\tjQuery.text( this ) :\n\t\t\t\tthis.empty().each( function() {\n\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\t\tthis.textContent = value;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t}, null, value, arguments.length );\n\t},\n\n\tappend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.appendChild( elem );\n\t\t\t}\n\t\t} );\n\t},\n\n\tprepend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t}\n\t\t} );\n\t},\n\n\tbefore: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t}\n\t\t} );\n\t},\n\n\tafter: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t}\n\t\t} );\n\t},\n\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\n\t\t\t\t// Prevent memory leaks\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\n\t\t\t\t// Remove any remaining nodes\n\t\t\t\telem.textContent = \"\";\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\treturn this.map( function() {\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t} );\n\t},\n\n\thtml: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n\t\t\t\treturn elem.innerHTML;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\n\n\t\t\t\tvalue = jQuery.htmlPrefilter( value );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\telem = this[ i ] || {};\n\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch ( e ) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t},\n\n\treplaceWith: function() {\n\t\tvar ignored = [];\n\n\t\t// Make the changes, replacing each non-ignored context element with the new content\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tvar parent = this.parentNode;\n\n\t\t\tif ( jQuery.inArray( this, ignored ) < 0 ) {\n\t\t\t\tjQuery.cleanData( getAll( this ) );\n\t\t\t\tif ( parent ) {\n\t\t\t\t\tparent.replaceChild( elem, this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Force callback invocation\n\t\t}, ignored );\n\t}\n} );\n\njQuery.each( {\n\tappendTo: \"append\",\n\tprependTo: \"prepend\",\n\tinsertBefore: \"before\",\n\tinsertAfter: \"after\",\n\treplaceAll: \"replaceWith\"\n}, function( name, original ) {\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar elems,\n\t\t\tret = [],\n\t\t\tinsert = jQuery( selector ),\n\t\t\tlast = insert.length - 1,\n\t\t\ti = 0;\n\n\t\tfor ( ; i <= last; i++ ) {\n\t\t\telems = i === last ? this : this.clone( true );\n\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n\n\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t// .get() because push.apply(_, arraylike) throws on ancient WebKit\n\t\t\tpush.apply( ret, elems.get() );\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n} );\nvar rmargin = ( /^margin/ );\n\nvar rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\n\nvar getStyles = function( elem ) {\n\n\t\t// Support: IE <=11 only, Firefox <=30 (#15098, #14150)\n\t\t// IE throws on elements created in popups\n\t\t// FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n\t\tvar view = elem.ownerDocument.defaultView;\n\n\t\tif ( !view || !view.opener ) {\n\t\t\tview = window;\n\t\t}\n\n\t\treturn view.getComputedStyle( elem );\n\t};\n\n\n\n( function() {\n\n\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n\t// so they're executed at the same time to save the second computation.\n\tfunction computeStyleTests() {\n\n\t\t// This is a singleton, we need to execute it only once\n\t\tif ( !div ) {\n\t\t\treturn;\n\t\t}\n\n\t\tdiv.style.cssText =\n\t\t\t\"box-sizing:border-box;\" +\n\t\t\t\"position:relative;display:block;\" +\n\t\t\t\"margin:auto;border:1px;padding:1px;\" +\n\t\t\t\"top:1%;width:50%\";\n\t\tdiv.innerHTML = \"\";\n\t\tdocumentElement.appendChild( container );\n\n\t\tvar divStyle = window.getComputedStyle( div );\n\t\tpixelPositionVal = divStyle.top !== \"1%\";\n\n\t\t// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n\t\treliableMarginLeftVal = divStyle.marginLeft === \"2px\";\n\t\tboxSizingReliableVal = divStyle.width === \"4px\";\n\n\t\t// Support: Android 4.0 - 4.3 only\n\t\t// Some styles come back with percentage values, even though they shouldn't\n\t\tdiv.style.marginRight = \"50%\";\n\t\tpixelMarginRightVal = divStyle.marginRight === \"4px\";\n\n\t\tdocumentElement.removeChild( container );\n\n\t\t// Nullify the div so it wouldn't be stored in the memory and\n\t\t// it will also be a sign that checks already performed\n\t\tdiv = null;\n\t}\n\n\tvar pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,\n\t\tcontainer = document.createElement( \"div\" ),\n\t\tdiv = document.createElement( \"div\" );\n\n\t// Finish early in limited (non-browser) environments\n\tif ( !div.style ) {\n\t\treturn;\n\t}\n\n\t// Support: IE <=9 - 11 only\n\t// Style of cloned element affects source element cloned (#8908)\n\tdiv.style.backgroundClip = \"content-box\";\n\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\n\tcontainer.style.cssText = \"border:0;width:8px;height:0;top:0;left:-9999px;\" +\n\t\t\"padding:0;margin-top:1px;position:absolute\";\n\tcontainer.appendChild( div );\n\n\tjQuery.extend( support, {\n\t\tpixelPosition: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelPositionVal;\n\t\t},\n\t\tboxSizingReliable: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn boxSizingReliableVal;\n\t\t},\n\t\tpixelMarginRight: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelMarginRightVal;\n\t\t},\n\t\treliableMarginLeft: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn reliableMarginLeftVal;\n\t\t}\n\t} );\n} )();\n\n\nfunction curCSS( elem, name, computed ) {\n\tvar width, minWidth, maxWidth, ret,\n\n\t\t// Support: Firefox 51+\n\t\t// Retrieving style before computed somehow\n\t\t// fixes an issue with getting wrong values\n\t\t// on detached elements\n\t\tstyle = elem.style;\n\n\tcomputed = computed || getStyles( elem );\n\n\t// getPropertyValue is needed for:\n\t//   .css('filter') (IE 9 only, #12537)\n\t//   .css('--customProperty) (#3144)\n\tif ( computed ) {\n\t\tret = computed.getPropertyValue( name ) || computed[ name ];\n\n\t\tif ( ret === \"\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\tret = jQuery.style( elem, name );\n\t\t}\n\n\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t// Android Browser returns percentage for some values,\n\t\t// but width seems to be reliably pixels.\n\t\t// This is against the CSSOM draft spec:\n\t\t// https://drafts.csswg.org/cssom/#resolved-values\n\t\tif ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {\n\n\t\t\t// Remember the original values\n\t\t\twidth = style.width;\n\t\t\tminWidth = style.minWidth;\n\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\tret = computed.width;\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.width = width;\n\t\t\tstyle.minWidth = minWidth;\n\t\t\tstyle.maxWidth = maxWidth;\n\t\t}\n\t}\n\n\treturn ret !== undefined ?\n\n\t\t// Support: IE <=9 - 11 only\n\t\t// IE returns zIndex value as an integer.\n\t\tret + \"\" :\n\t\tret;\n}\n\n\nfunction addGetHookIf( conditionFn, hookFn ) {\n\n\t// Define the hook, we'll check on the first run if it's really needed.\n\treturn {\n\t\tget: function() {\n\t\t\tif ( conditionFn() ) {\n\n\t\t\t\t// Hook not needed (or it's not possible to use it due\n\t\t\t\t// to missing dependency), remove it.\n\t\t\t\tdelete this.get;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\t\t\treturn ( this.get = hookFn ).apply( this, arguments );\n\t\t}\n\t};\n}\n\n\nvar\n\n\t// Swappable if display is none or starts with table\n\t// except \"table\", \"table-cell\", or \"table-caption\"\n\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\trcustomProp = /^--/,\n\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\tcssNormalTransform = {\n\t\tletterSpacing: \"0\",\n\t\tfontWeight: \"400\"\n\t},\n\n\tcssPrefixes = [ \"Webkit\", \"Moz\", \"ms\" ],\n\temptyStyle = document.createElement( \"div\" ).style;\n\n// Return a css property mapped to a potentially vendor prefixed property\nfunction vendorPropName( name ) {\n\n\t// Shortcut for names that are not vendor prefixed\n\tif ( name in emptyStyle ) {\n\t\treturn name;\n\t}\n\n\t// Check for vendor prefixed names\n\tvar capName = name[ 0 ].toUpperCase() + name.slice( 1 ),\n\t\ti = cssPrefixes.length;\n\n\twhile ( i-- ) {\n\t\tname = cssPrefixes[ i ] + capName;\n\t\tif ( name in emptyStyle ) {\n\t\t\treturn name;\n\t\t}\n\t}\n}\n\n// Return a property mapped along what jQuery.cssProps suggests or to\n// a vendor prefixed property.\nfunction finalPropName( name ) {\n\tvar ret = jQuery.cssProps[ name ];\n\tif ( !ret ) {\n\t\tret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;\n\t}\n\treturn ret;\n}\n\nfunction setPositiveNumber( elem, value, subtract ) {\n\n\t// Any relative (+/-) values have already been\n\t// normalized at this point\n\tvar matches = rcssNum.exec( value );\n\treturn matches ?\n\n\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\tMath.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || \"px\" ) :\n\t\tvalue;\n}\n\nfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\n\tvar i,\n\t\tval = 0;\n\n\t// If we already have the right measurement, avoid augmentation\n\tif ( extra === ( isBorderBox ? \"border\" : \"content\" ) ) {\n\t\ti = 4;\n\n\t// Otherwise initialize for horizontal or vertical properties\n\t} else {\n\t\ti = name === \"width\" ? 1 : 0;\n\t}\n\n\tfor ( ; i < 4; i += 2 ) {\n\n\t\t// Both box models exclude margin, so add it if we want it\n\t\tif ( extra === \"margin\" ) {\n\t\t\tval += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\n\t\t}\n\n\t\tif ( isBorderBox ) {\n\n\t\t\t// border-box includes padding, so remove it if we want content\n\t\t\tif ( extra === \"content\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\t\t}\n\n\t\t\t// At this point, extra isn't border nor margin, so remove border\n\t\t\tif ( extra !== \"margin\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t} else {\n\n\t\t\t// At this point, extra isn't content, so add padding\n\t\t\tval += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\n\t\t\t// At this point, extra isn't content nor padding, so add border\n\t\t\tif ( extra !== \"padding\" ) {\n\t\t\t\tval += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn val;\n}\n\nfunction getWidthOrHeight( elem, name, extra ) {\n\n\t// Start with computed style\n\tvar valueIsBorderBox,\n\t\tstyles = getStyles( elem ),\n\t\tval = curCSS( elem, name, styles ),\n\t\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\n\n\t// Computed unit is not pixels. Stop here and return.\n\tif ( rnumnonpx.test( val ) ) {\n\t\treturn val;\n\t}\n\n\t// Check for style in case a browser which returns unreliable values\n\t// for getComputedStyle silently falls back to the reliable elem.style\n\tvalueIsBorderBox = isBorderBox &&\n\t\t( support.boxSizingReliable() || val === elem.style[ name ] );\n\n\t// Fall back to offsetWidth/Height when value is \"auto\"\n\t// This happens for inline elements with no explicit setting (gh-3571)\n\tif ( val === \"auto\" ) {\n\t\tval = elem[ \"offset\" + name[ 0 ].toUpperCase() + name.slice( 1 ) ];\n\t}\n\n\t// Normalize \"\", auto, and prepare for extra\n\tval = parseFloat( val ) || 0;\n\n\t// Use the active box-sizing model to add/subtract irrelevant styles\n\treturn ( val +\n\t\taugmentWidthOrHeight(\n\t\t\telem,\n\t\t\tname,\n\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n\t\t\tvalueIsBorderBox,\n\t\t\tstyles\n\t\t)\n\t) + \"px\";\n}\n\njQuery.extend( {\n\n\t// Add in style property hooks for overriding the default\n\t// behavior of getting and setting a style property\n\tcssHooks: {\n\t\topacity: {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\n\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Don't automatically add \"px\" to these possibly-unitless properties\n\tcssNumber: {\n\t\t\"animationIterationCount\": true,\n\t\t\"columnCount\": true,\n\t\t\"fillOpacity\": true,\n\t\t\"flexGrow\": true,\n\t\t\"flexShrink\": true,\n\t\t\"fontWeight\": true,\n\t\t\"lineHeight\": true,\n\t\t\"opacity\": true,\n\t\t\"order\": true,\n\t\t\"orphans\": true,\n\t\t\"widows\": true,\n\t\t\"zIndex\": true,\n\t\t\"zoom\": true\n\t},\n\n\t// Add in properties whose names you wish to fix before\n\t// setting or getting the value\n\tcssProps: {\n\t\t\"float\": \"cssFloat\"\n\t},\n\n\t// Get and set the style property on a DOM Node\n\tstyle: function( elem, name, value, extra ) {\n\n\t\t// Don't set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure that we're working with the right name\n\t\tvar ret, type, hooks,\n\t\t\torigName = jQuery.camelCase( name ),\n\t\t\tisCustomProp = rcustomProp.test( name ),\n\t\t\tstyle = elem.style;\n\n\t\t// Make sure that we're working with the right name. We don't\n\t\t// want to query the value if it is a CSS custom property\n\t\t// since they are user-defined.\n\t\tif ( !isCustomProp ) {\n\t\t\tname = finalPropName( origName );\n\t\t}\n\n\t\t// Gets hook for the prefixed version, then unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// Check if we're setting a value\n\t\tif ( value !== undefined ) {\n\t\t\ttype = typeof value;\n\n\t\t\t// Convert \"+=\" or \"-=\" to relative numbers (#7345)\n\t\t\tif ( type === \"string\" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\n\t\t\t\tvalue = adjustCSS( elem, name, ret );\n\n\t\t\t\t// Fixes bug #9237\n\t\t\t\ttype = \"number\";\n\t\t\t}\n\n\t\t\t// Make sure that null and NaN values aren't set (#7116)\n\t\t\tif ( value == null || value !== value ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a number was passed in, add the unit (except for certain CSS properties)\n\t\t\tif ( type === \"number\" ) {\n\t\t\t\tvalue += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? \"\" : \"px\" );\n\t\t\t}\n\n\t\t\t// background-* props affect original clone's values\n\t\t\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf( \"background\" ) === 0 ) {\n\t\t\t\tstyle[ name ] = \"inherit\";\n\t\t\t}\n\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\tif ( !hooks || !( \"set\" in hooks ) ||\n\t\t\t\t( value = hooks.set( elem, value, extra ) ) !== undefined ) {\n\n\t\t\t\tif ( isCustomProp ) {\n\t\t\t\t\tstyle.setProperty( name, value );\n\t\t\t\t} else {\n\t\t\t\t\tstyle[ name ] = value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\tif ( hooks && \"get\" in hooks &&\n\t\t\t\t( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\n\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Otherwise just get the value from the style object\n\t\t\treturn style[ name ];\n\t\t}\n\t},\n\n\tcss: function( elem, name, extra, styles ) {\n\t\tvar val, num, hooks,\n\t\t\torigName = jQuery.camelCase( name ),\n\t\t\tisCustomProp = rcustomProp.test( name );\n\n\t\t// Make sure that we're working with the right name. We don't\n\t\t// want to modify the value if it is a CSS custom property\n\t\t// since they are user-defined.\n\t\tif ( !isCustomProp ) {\n\t\t\tname = finalPropName( origName );\n\t\t}\n\n\t\t// Try prefixed name followed by the unprefixed name\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// If a hook was provided get the computed value from there\n\t\tif ( hooks && \"get\" in hooks ) {\n\t\t\tval = hooks.get( elem, true, extra );\n\t\t}\n\n\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\tif ( val === undefined ) {\n\t\t\tval = curCSS( elem, name, styles );\n\t\t}\n\n\t\t// Convert \"normal\" to computed value\n\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n\t\t\tval = cssNormalTransform[ name ];\n\t\t}\n\n\t\t// Make numeric if forced or a qualifier was provided and val looks numeric\n\t\tif ( extra === \"\" || extra ) {\n\t\t\tnum = parseFloat( val );\n\t\t\treturn extra === true || isFinite( num ) ? num || 0 : val;\n\t\t}\n\n\t\treturn val;\n\t}\n} );\n\njQuery.each( [ \"height\", \"width\" ], function( i, name ) {\n\tjQuery.cssHooks[ name ] = {\n\t\tget: function( elem, computed, extra ) {\n\t\t\tif ( computed ) {\n\n\t\t\t\t// Certain elements can have dimension info if we invisibly show them\n\t\t\t\t// but it must have a current display style that would benefit\n\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, \"display\" ) ) &&\n\n\t\t\t\t\t// Support: Safari 8+\n\t\t\t\t\t// Table columns in Safari have non-zero offsetWidth & zero\n\t\t\t\t\t// getBoundingClientRect().width unless display is changed.\n\t\t\t\t\t// Support: IE <=11 only\n\t\t\t\t\t// Running getBoundingClientRect on a disconnected node\n\t\t\t\t\t// in IE throws an error.\n\t\t\t\t\t( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?\n\t\t\t\t\t\tswap( elem, cssShow, function() {\n\t\t\t\t\t\t\treturn getWidthOrHeight( elem, name, extra );\n\t\t\t\t\t\t} ) :\n\t\t\t\t\t\tgetWidthOrHeight( elem, name, extra );\n\t\t\t}\n\t\t},\n\n\t\tset: function( elem, value, extra ) {\n\t\t\tvar matches,\n\t\t\t\tstyles = extra && getStyles( elem ),\n\t\t\t\tsubtract = extra && augmentWidthOrHeight(\n\t\t\t\t\telem,\n\t\t\t\t\tname,\n\t\t\t\t\textra,\n\t\t\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\t\t\t\tstyles\n\t\t\t\t);\n\n\t\t\t// Convert to pixels if value adjustment is needed\n\t\t\tif ( subtract && ( matches = rcssNum.exec( value ) ) &&\n\t\t\t\t( matches[ 3 ] || \"px\" ) !== \"px\" ) {\n\n\t\t\t\telem.style[ name ] = value;\n\t\t\t\tvalue = jQuery.css( elem, name );\n\t\t\t}\n\n\t\t\treturn setPositiveNumber( elem, value, subtract );\n\t\t}\n\t};\n} );\n\njQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\n\tfunction( elem, computed ) {\n\t\tif ( computed ) {\n\t\t\treturn ( parseFloat( curCSS( elem, \"marginLeft\" ) ) ||\n\t\t\t\telem.getBoundingClientRect().left -\n\t\t\t\t\tswap( elem, { marginLeft: 0 }, function() {\n\t\t\t\t\t\treturn elem.getBoundingClientRect().left;\n\t\t\t\t\t} )\n\t\t\t\t) + \"px\";\n\t\t}\n\t}\n);\n\n// These hooks are used by animate to expand properties\njQuery.each( {\n\tmargin: \"\",\n\tpadding: \"\",\n\tborder: \"Width\"\n}, function( prefix, suffix ) {\n\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\texpand: function( value ) {\n\t\t\tvar i = 0,\n\t\t\t\texpanded = {},\n\n\t\t\t\t// Assumes a single number if not a string\n\t\t\t\tparts = typeof value === \"string\" ? value.split( \" \" ) : [ value ];\n\n\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t}\n\n\t\t\treturn expanded;\n\t\t}\n\t};\n\n\tif ( !rmargin.test( prefix ) ) {\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t}\n} );\n\njQuery.fn.extend( {\n\tcss: function( name, value ) {\n\t\treturn access( this, function( elem, name, value ) {\n\t\t\tvar styles, len,\n\t\t\t\tmap = {},\n\t\t\t\ti = 0;\n\n\t\t\tif ( Array.isArray( name ) ) {\n\t\t\t\tstyles = getStyles( elem );\n\t\t\t\tlen = name.length;\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\treturn value !== undefined ?\n\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\tjQuery.css( elem, name );\n\t\t}, name, value, arguments.length > 1 );\n\t}\n} );\n\n\nfunction Tween( elem, options, prop, end, easing ) {\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n\tconstructor: Tween,\n\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\t\tthis.easing = easing || jQuery.easing._default;\n\t\tthis.options = options;\n\t\tthis.start = this.now = this.cur();\n\t\tthis.end = end;\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\t},\n\tcur: function() {\n\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\treturn hooks && hooks.get ?\n\t\t\thooks.get( this ) :\n\t\t\tTween.propHooks._default.get( this );\n\t},\n\trun: function( percent ) {\n\t\tvar eased,\n\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\tif ( this.options.duration ) {\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pos = eased = percent;\n\t\t}\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\tif ( this.options.step ) {\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t}\n\n\t\tif ( hooks && hooks.set ) {\n\t\t\thooks.set( this );\n\t\t} else {\n\t\t\tTween.propHooks._default.set( this );\n\t\t}\n\t\treturn this;\n\t}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n\t_default: {\n\t\tget: function( tween ) {\n\t\t\tvar result;\n\n\t\t\t// Use a property on the element directly when it is not a DOM element,\n\t\t\t// or when there is no matching style property that exists.\n\t\t\tif ( tween.elem.nodeType !== 1 ||\n\t\t\t\ttween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\n\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t}\n\n\t\t\t// Passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails.\n\t\t\t// Simple values such as \"10px\" are parsed to Float;\n\t\t\t// complex values such as \"rotate(1rad)\" are returned as-is.\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n\n\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t},\n\t\tset: function( tween ) {\n\n\t\t\t// Use step hook for back compat.\n\t\t\t// Use cssHook if its there.\n\t\t\t// Use .style if available and use plain properties where available.\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t} else if ( tween.elem.nodeType === 1 &&\n\t\t\t\t( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||\n\t\t\t\t\tjQuery.cssHooks[ tween.prop ] ) ) {\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t} else {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Support: IE <=9 only\n// Panic based approach to setting things on disconnected nodes\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\tset: function( tween ) {\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t}\n\t}\n};\n\njQuery.easing = {\n\tlinear: function( p ) {\n\t\treturn p;\n\t},\n\tswing: function( p ) {\n\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n\t},\n\t_default: \"swing\"\n};\n\njQuery.fx = Tween.prototype.init;\n\n// Back compat <1.8 extension point\njQuery.fx.step = {};\n\n\n\n\nvar\n\tfxNow, inProgress,\n\trfxtypes = /^(?:toggle|show|hide)$/,\n\trrun = /queueHooks$/;\n\nfunction schedule() {\n\tif ( inProgress ) {\n\t\tif ( document.hidden === false && window.requestAnimationFrame ) {\n\t\t\twindow.requestAnimationFrame( schedule );\n\t\t} else {\n\t\t\twindow.setTimeout( schedule, jQuery.fx.interval );\n\t\t}\n\n\t\tjQuery.fx.tick();\n\t}\n}\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n\twindow.setTimeout( function() {\n\t\tfxNow = undefined;\n\t} );\n\treturn ( fxNow = jQuery.now() );\n}\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n\tvar which,\n\t\ti = 0,\n\t\tattrs = { height: type };\n\n\t// If we include width, step value is 1 to do all cssExpand values,\n\t// otherwise step value is 2 to skip over Left and Right\n\tincludeWidth = includeWidth ? 1 : 0;\n\tfor ( ; i < 4; i += 2 - includeWidth ) {\n\t\twhich = cssExpand[ i ];\n\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n\t}\n\n\tif ( includeWidth ) {\n\t\tattrs.opacity = attrs.width = type;\n\t}\n\n\treturn attrs;\n}\n\nfunction createTween( value, prop, animation ) {\n\tvar tween,\n\t\tcollection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ \"*\" ] ),\n\t\tindex = 0,\n\t\tlength = collection.length;\n\tfor ( ; index < length; index++ ) {\n\t\tif ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\n\n\t\t\t// We're done with this property\n\t\t\treturn tween;\n\t\t}\n\t}\n}\n\nfunction defaultPrefilter( elem, props, opts ) {\n\tvar prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,\n\t\tisBox = \"width\" in props || \"height\" in props,\n\t\tanim = this,\n\t\torig = {},\n\t\tstyle = elem.style,\n\t\thidden = elem.nodeType && isHiddenWithinTree( elem ),\n\t\tdataShow = dataPriv.get( elem, \"fxshow\" );\n\n\t// Queue-skipping animations hijack the fx hooks\n\tif ( !opts.queue ) {\n\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n\t\tif ( hooks.unqueued == null ) {\n\t\t\thooks.unqueued = 0;\n\t\t\toldfire = hooks.empty.fire;\n\t\t\thooks.empty.fire = function() {\n\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\toldfire();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\thooks.unqueued++;\n\n\t\tanim.always( function() {\n\n\t\t\t// Ensure the complete handler is called before this completes\n\t\t\tanim.always( function() {\n\t\t\t\thooks.unqueued--;\n\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n\t\t\t\t\thooks.empty.fire();\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t}\n\n\t// Detect show/hide animations\n\tfor ( prop in props ) {\n\t\tvalue = props[ prop ];\n\t\tif ( rfxtypes.test( value ) ) {\n\t\t\tdelete props[ prop ];\n\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\n\t\t\t\t// Pretend to be hidden if this is a \"show\" and\n\t\t\t\t// there is still data from a stopped show/hide\n\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\thidden = true;\n\n\t\t\t\t// Ignore all other no-op show/hide data\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\t\t}\n\t}\n\n\t// Bail out if this is a no-op like .hide().hide()\n\tpropTween = !jQuery.isEmptyObject( props );\n\tif ( !propTween && jQuery.isEmptyObject( orig ) ) {\n\t\treturn;\n\t}\n\n\t// Restrict \"overflow\" and \"display\" styles during box animations\n\tif ( isBox && elem.nodeType === 1 ) {\n\n\t\t// Support: IE <=9 - 11, Edge 12 - 13\n\t\t// Record all 3 overflow attributes because IE does not infer the shorthand\n\t\t// from identically-valued overflowX and overflowY\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t// Identify a display type, preferring old show/hide data over the CSS cascade\n\t\trestoreDisplay = dataShow && dataShow.display;\n\t\tif ( restoreDisplay == null ) {\n\t\t\trestoreDisplay = dataPriv.get( elem, \"display\" );\n\t\t}\n\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\tif ( display === \"none\" ) {\n\t\t\tif ( restoreDisplay ) {\n\t\t\t\tdisplay = restoreDisplay;\n\t\t\t} else {\n\n\t\t\t\t// Get nonempty value(s) by temporarily forcing visibility\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t\trestoreDisplay = elem.style.display || restoreDisplay;\n\t\t\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\t\t\tshowHide( [ elem ] );\n\t\t\t}\n\t\t}\n\n\t\t// Animate inline elements as inline-block\n\t\tif ( display === \"inline\" || display === \"inline-block\" && restoreDisplay != null ) {\n\t\t\tif ( jQuery.css( elem, \"float\" ) === \"none\" ) {\n\n\t\t\t\t// Restore the original display value at the end of pure show/hide animations\n\t\t\t\tif ( !propTween ) {\n\t\t\t\t\tanim.done( function() {\n\t\t\t\t\t\tstyle.display = restoreDisplay;\n\t\t\t\t\t} );\n\t\t\t\t\tif ( restoreDisplay == null ) {\n\t\t\t\t\t\tdisplay = style.display;\n\t\t\t\t\t\trestoreDisplay = display === \"none\" ? \"\" : display;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstyle.display = \"inline-block\";\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( opts.overflow ) {\n\t\tstyle.overflow = \"hidden\";\n\t\tanim.always( function() {\n\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t} );\n\t}\n\n\t// Implement show/hide animations\n\tpropTween = false;\n\tfor ( prop in orig ) {\n\n\t\t// General show/hide setup for this element animation\n\t\tif ( !propTween ) {\n\t\t\tif ( dataShow ) {\n\t\t\t\tif ( \"hidden\" in dataShow ) {\n\t\t\t\t\thidden = dataShow.hidden;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdataShow = dataPriv.access( elem, \"fxshow\", { display: restoreDisplay } );\n\t\t\t}\n\n\t\t\t// Store hidden/visible for toggle so `.stop().toggle()` \"reverses\"\n\t\t\tif ( toggle ) {\n\t\t\t\tdataShow.hidden = !hidden;\n\t\t\t}\n\n\t\t\t// Show elements before animating them\n\t\t\tif ( hidden ) {\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t}\n\n\t\t\t/* eslint-disable no-loop-func */\n\n\t\t\tanim.done( function() {\n\n\t\t\t/* eslint-enable no-loop-func */\n\n\t\t\t\t// The final step of a \"hide\" animation is actually hiding the element\n\t\t\t\tif ( !hidden ) {\n\t\t\t\t\tshowHide( [ elem ] );\n\t\t\t\t}\n\t\t\t\tdataPriv.remove( elem, \"fxshow\" );\n\t\t\t\tfor ( prop in orig ) {\n\t\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\t// Per-property setup\n\t\tpropTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\t\tif ( !( prop in dataShow ) ) {\n\t\t\tdataShow[ prop ] = propTween.start;\n\t\t\tif ( hidden ) {\n\t\t\t\tpropTween.end = propTween.start;\n\t\t\t\tpropTween.start = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction propFilter( props, specialEasing ) {\n\tvar index, name, easing, value, hooks;\n\n\t// camelCase, specialEasing and expand cssHook pass\n\tfor ( index in props ) {\n\t\tname = jQuery.camelCase( index );\n\t\teasing = specialEasing[ name ];\n\t\tvalue = props[ index ];\n\t\tif ( Array.isArray( value ) ) {\n\t\t\teasing = value[ 1 ];\n\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t}\n\n\t\tif ( index !== name ) {\n\t\t\tprops[ name ] = value;\n\t\t\tdelete props[ index ];\n\t\t}\n\n\t\thooks = jQuery.cssHooks[ name ];\n\t\tif ( hooks && \"expand\" in hooks ) {\n\t\t\tvalue = hooks.expand( value );\n\t\t\tdelete props[ name ];\n\n\t\t\t// Not quite $.extend, this won't overwrite existing keys.\n\t\t\t// Reusing 'index' because we have the correct \"name\"\n\t\t\tfor ( index in value ) {\n\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tspecialEasing[ name ] = easing;\n\t\t}\n\t}\n}\n\nfunction Animation( elem, properties, options ) {\n\tvar result,\n\t\tstopped,\n\t\tindex = 0,\n\t\tlength = Animation.prefilters.length,\n\t\tdeferred = jQuery.Deferred().always( function() {\n\n\t\t\t// Don't match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t} ),\n\t\ttick = function() {\n\t\t\tif ( stopped ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\n\t\t\t\t// Support: Android 2.3 only\n\t\t\t\t// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\tpercent = 1 - temp,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = animation.tweens.length;\n\n\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t}\n\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ] );\n\n\t\t\t// If there's more to do, yield\n\t\t\tif ( percent < 1 && length ) {\n\t\t\t\treturn remaining;\n\t\t\t}\n\n\t\t\t// If this was an empty animation, synthesize a final progress notification\n\t\t\tif ( !length ) {\n\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t}\n\n\t\t\t// Resolve the animation and report its conclusion\n\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\treturn false;\n\t\t},\n\t\tanimation = deferred.promise( {\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\topts: jQuery.extend( true, {\n\t\t\t\tspecialEasing: {},\n\t\t\t\teasing: jQuery.easing._default\n\t\t\t}, options ),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function( gotoEnd ) {\n\t\t\t\tvar index = 0,\n\n\t\t\t\t\t// If we are going to the end, we want to run all the tweens\n\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t}\n\n\t\t\t\t// Resolve when we played the last frame; otherwise, reject\n\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t} ),\n\t\tprops = animation.props;\n\n\tpropFilter( props, animation.opts.specialEasing );\n\n\tfor ( ; index < length; index++ ) {\n\t\tresult = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\n\t\tif ( result ) {\n\t\t\tif ( jQuery.isFunction( result.stop ) ) {\n\t\t\t\tjQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\n\t\t\t\t\tjQuery.proxy( result.stop, result );\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tjQuery.map( props, createTween, animation );\n\n\tif ( jQuery.isFunction( animation.opts.start ) ) {\n\t\tanimation.opts.start.call( elem, animation );\n\t}\n\n\t// Attach callbacks from options\n\tanimation\n\t\t.progress( animation.opts.progress )\n\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t.fail( animation.opts.fail )\n\t\t.always( animation.opts.always );\n\n\tjQuery.fx.timer(\n\t\tjQuery.extend( tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t} )\n\t);\n\n\treturn animation;\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\n\ttweeners: {\n\t\t\"*\": [ function( prop, value ) {\n\t\t\tvar tween = this.createTween( prop, value );\n\t\t\tadjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\n\t\t\treturn tween;\n\t\t} ]\n\t},\n\n\ttweener: function( props, callback ) {\n\t\tif ( jQuery.isFunction( props ) ) {\n\t\t\tcallback = props;\n\t\t\tprops = [ \"*\" ];\n\t\t} else {\n\t\t\tprops = props.match( rnothtmlwhite );\n\t\t}\n\n\t\tvar prop,\n\t\t\tindex = 0,\n\t\t\tlength = props.length;\n\n\t\tfor ( ; index < length; index++ ) {\n\t\t\tprop = props[ index ];\n\t\t\tAnimation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\n\t\t\tAnimation.tweeners[ prop ].unshift( callback );\n\t\t}\n\t},\n\n\tprefilters: [ defaultPrefilter ],\n\n\tprefilter: function( callback, prepend ) {\n\t\tif ( prepend ) {\n\t\t\tAnimation.prefilters.unshift( callback );\n\t\t} else {\n\t\t\tAnimation.prefilters.push( callback );\n\t\t}\n\t}\n} );\n\njQuery.speed = function( speed, easing, fn ) {\n\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n\t\tcomplete: fn || !fn && easing ||\n\t\t\tjQuery.isFunction( speed ) && speed,\n\t\tduration: speed,\n\t\teasing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\n\t};\n\n\t// Go to the end state if fx are off\n\tif ( jQuery.fx.off ) {\n\t\topt.duration = 0;\n\n\t} else {\n\t\tif ( typeof opt.duration !== \"number\" ) {\n\t\t\tif ( opt.duration in jQuery.fx.speeds ) {\n\t\t\t\topt.duration = jQuery.fx.speeds[ opt.duration ];\n\n\t\t\t} else {\n\t\t\t\topt.duration = jQuery.fx.speeds._default;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Normalize opt.queue - true/undefined/null -> \"fx\"\n\tif ( opt.queue == null || opt.queue === true ) {\n\t\topt.queue = \"fx\";\n\t}\n\n\t// Queueing\n\topt.old = opt.complete;\n\n\topt.complete = function() {\n\t\tif ( jQuery.isFunction( opt.old ) ) {\n\t\t\topt.old.call( this );\n\t\t}\n\n\t\tif ( opt.queue ) {\n\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t}\n\t};\n\n\treturn opt;\n};\n\njQuery.fn.extend( {\n\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t// Show any hidden elements after setting opacity to 0\n\t\treturn this.filter( isHiddenWithinTree ).css( \"opacity\", 0 ).show()\n\n\t\t\t// Animate to the value specified\n\t\t\t.end().animate( { opacity: to }, speed, easing, callback );\n\t},\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\tdoAnimation = function() {\n\n\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif ( empty || dataPriv.get( this, \"finish\" ) ) {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t}\n\t\t\t};\n\t\t\tdoAnimation.finish = doAnimation;\n\n\t\treturn empty || optall.queue === false ?\n\t\t\tthis.each( doAnimation ) :\n\t\t\tthis.queue( optall.queue, doAnimation );\n\t},\n\tstop: function( type, clearQueue, gotoEnd ) {\n\t\tvar stopQueue = function( hooks ) {\n\t\t\tvar stop = hooks.stop;\n\t\t\tdelete hooks.stop;\n\t\t\tstop( gotoEnd );\n\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tgotoEnd = clearQueue;\n\t\t\tclearQueue = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\tif ( clearQueue && type !== false ) {\n\t\t\tthis.queue( type || \"fx\", [] );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar dequeue = true,\n\t\t\t\tindex = type != null && type + \"queueHooks\",\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tdata = dataPriv.get( this );\n\n\t\t\tif ( index ) {\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( index in data ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this &&\n\t\t\t\t\t( type == null || timers[ index ].queue === type ) ) {\n\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\tdequeue = false;\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Start the next in the queue if the last step wasn't forced.\n\t\t\t// Timers currently will call their complete callbacks, which\n\t\t\t// will dequeue but only if they were gotoEnd.\n\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t} );\n\t},\n\tfinish: function( type ) {\n\t\tif ( type !== false ) {\n\t\t\ttype = type || \"fx\";\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tvar index,\n\t\t\t\tdata = dataPriv.get( this ),\n\t\t\t\tqueue = data[ type + \"queue\" ],\n\t\t\t\thooks = data[ type + \"queueHooks\" ],\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tlength = queue ? queue.length : 0;\n\n\t\t\t// Enable finishing flag on private data\n\t\t\tdata.finish = true;\n\n\t\t\t// Empty the queue first\n\t\t\tjQuery.queue( this, type, [] );\n\n\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\thooks.stop.call( this, true );\n\t\t\t}\n\n\t\t\t// Look for any active animations, and finish them\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Look for any animations in the old queue and finish them\n\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Turn off finishing flag\n\t\t\tdelete data.finish;\n\t\t} );\n\t}\n} );\n\njQuery.each( [ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\n\tvar cssFn = jQuery.fn[ name ];\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn speed == null || typeof speed === \"boolean\" ?\n\t\t\tcssFn.apply( this, arguments ) :\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t};\n} );\n\n// Generate shortcuts for custom animations\njQuery.each( {\n\tslideDown: genFx( \"show\" ),\n\tslideUp: genFx( \"hide\" ),\n\tslideToggle: genFx( \"toggle\" ),\n\tfadeIn: { opacity: \"show\" },\n\tfadeOut: { opacity: \"hide\" },\n\tfadeToggle: { opacity: \"toggle\" }\n}, function( name, props ) {\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn this.animate( props, speed, easing, callback );\n\t};\n} );\n\njQuery.timers = [];\njQuery.fx.tick = function() {\n\tvar timer,\n\t\ti = 0,\n\t\ttimers = jQuery.timers;\n\n\tfxNow = jQuery.now();\n\n\tfor ( ; i < timers.length; i++ ) {\n\t\ttimer = timers[ i ];\n\n\t\t// Run the timer and safely remove it when done (allowing for external removal)\n\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\ttimers.splice( i--, 1 );\n\t\t}\n\t}\n\n\tif ( !timers.length ) {\n\t\tjQuery.fx.stop();\n\t}\n\tfxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n\tjQuery.timers.push( timer );\n\tjQuery.fx.start();\n};\n\njQuery.fx.interval = 13;\njQuery.fx.start = function() {\n\tif ( inProgress ) {\n\t\treturn;\n\t}\n\n\tinProgress = true;\n\tschedule();\n};\n\njQuery.fx.stop = function() {\n\tinProgress = null;\n};\n\njQuery.fx.speeds = {\n\tslow: 600,\n\tfast: 200,\n\n\t// Default speed\n\t_default: 400\n};\n\n\n// Based off of the plugin by Clint Helfers, with permission.\n// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\njQuery.fn.delay = function( time, type ) {\n\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\ttype = type || \"fx\";\n\n\treturn this.queue( type, function( next, hooks ) {\n\t\tvar timeout = window.setTimeout( next, time );\n\t\thooks.stop = function() {\n\t\t\twindow.clearTimeout( timeout );\n\t\t};\n\t} );\n};\n\n\n( function() {\n\tvar input = document.createElement( \"input\" ),\n\t\tselect = document.createElement( \"select\" ),\n\t\topt = select.appendChild( document.createElement( \"option\" ) );\n\n\tinput.type = \"checkbox\";\n\n\t// Support: Android <=4.3 only\n\t// Default value for a checkbox should be \"on\"\n\tsupport.checkOn = input.value !== \"\";\n\n\t// Support: IE <=11 only\n\t// Must access selectedIndex to make default options select\n\tsupport.optSelected = opt.selected;\n\n\t// Support: IE <=11 only\n\t// An input loses its value after becoming a radio\n\tinput = document.createElement( \"input\" );\n\tinput.value = \"t\";\n\tinput.type = \"radio\";\n\tsupport.radioValue = input.value === \"t\";\n} )();\n\n\nvar boolHook,\n\tattrHandle = jQuery.expr.attrHandle;\n\njQuery.fn.extend( {\n\tattr: function( name, value ) {\n\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t},\n\n\tremoveAttr: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.removeAttr( this, name );\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tattr: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set attributes on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fallback to prop when attributes are not supported\n\t\tif ( typeof elem.getAttribute === \"undefined\" ) {\n\t\t\treturn jQuery.prop( elem, name, value );\n\t\t}\n\n\t\t// Attribute hooks are determined by the lowercase version\n\t\t// Grab necessary hook if one is defined\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\thooks = jQuery.attrHooks[ name.toLowerCase() ] ||\n\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( value === null ) {\n\t\t\t\tjQuery.removeAttr( elem, name );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\telem.setAttribute( name, value + \"\" );\n\t\t\treturn value;\n\t\t}\n\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = jQuery.find.attr( elem, name );\n\n\t\t// Non-existent attributes return null, we normalize to undefined\n\t\treturn ret == null ? undefined : ret;\n\t},\n\n\tattrHooks: {\n\t\ttype: {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( !support.radioValue && value === \"radio\" &&\n\t\t\t\t\tnodeName( elem, \"input\" ) ) {\n\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\telem.setAttribute( \"type\", value );\n\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tremoveAttr: function( elem, value ) {\n\t\tvar name,\n\t\t\ti = 0,\n\n\t\t\t// Attribute names can contain non-HTML whitespace characters\n\t\t\t// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n\t\t\tattrNames = value && value.match( rnothtmlwhite );\n\n\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\twhile ( ( name = attrNames[ i++ ] ) ) {\n\t\t\t\telem.removeAttribute( name );\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Hooks for boolean attributes\nboolHook = {\n\tset: function( elem, value, name ) {\n\t\tif ( value === false ) {\n\n\t\t\t// Remove boolean attributes when set to false\n\t\t\tjQuery.removeAttr( elem, name );\n\t\t} else {\n\t\t\telem.setAttribute( name, name );\n\t\t}\n\t\treturn name;\n\t}\n};\n\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n\n\tattrHandle[ name ] = function( elem, name, isXML ) {\n\t\tvar ret, handle,\n\t\t\tlowercaseName = name.toLowerCase();\n\n\t\tif ( !isXML ) {\n\n\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\thandle = attrHandle[ lowercaseName ];\n\t\t\tattrHandle[ lowercaseName ] = ret;\n\t\t\tret = getter( elem, name, isXML ) != null ?\n\t\t\t\tlowercaseName :\n\t\t\t\tnull;\n\t\t\tattrHandle[ lowercaseName ] = handle;\n\t\t}\n\t\treturn ret;\n\t};\n} );\n\n\n\n\nvar rfocusable = /^(?:input|select|textarea|button)$/i,\n\trclickable = /^(?:a|area)$/i;\n\njQuery.fn.extend( {\n\tprop: function( name, value ) {\n\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t},\n\n\tremoveProp: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tprop: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set properties on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// Fix name and attach hooks\n\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\thooks = jQuery.propHooks[ name ];\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\treturn ( elem[ name ] = value );\n\t\t}\n\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn elem[ name ];\n\t},\n\n\tpropHooks: {\n\t\ttabIndex: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\t// Support: IE <=9 - 11 only\n\t\t\t\t// elem.tabIndex doesn't always return the\n\t\t\t\t// correct value when it hasn't been explicitly set\n\t\t\t\t// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\t\t\t\t// Use proper attribute retrieval(#12072)\n\t\t\t\tvar tabindex = jQuery.find.attr( elem, \"tabindex\" );\n\n\t\t\t\tif ( tabindex ) {\n\t\t\t\t\treturn parseInt( tabindex, 10 );\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\trfocusable.test( elem.nodeName ) ||\n\t\t\t\t\trclickable.test( elem.nodeName ) &&\n\t\t\t\t\telem.href\n\t\t\t\t) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t},\n\n\tpropFix: {\n\t\t\"for\": \"htmlFor\",\n\t\t\"class\": \"className\"\n\t}\n} );\n\n// Support: IE <=11 only\n// Accessing the selectedIndex property\n// forces the browser to respect setting selected\n// on the option\n// The getter ensures a default option is selected\n// when in an optgroup\n// eslint rule \"no-unused-expressions\" is disabled for this code\n// since it considers such accessions noop\nif ( !support.optSelected ) {\n\tjQuery.propHooks.selected = {\n\t\tget: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: \"off\" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent && parent.parentNode ) {\n\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\tset: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: \"off\" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent ) {\n\t\t\t\tparent.selectedIndex;\n\n\t\t\t\tif ( parent.parentNode ) {\n\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\njQuery.each( [\n\t\"tabIndex\",\n\t\"readOnly\",\n\t\"maxLength\",\n\t\"cellSpacing\",\n\t\"cellPadding\",\n\t\"rowSpan\",\n\t\"colSpan\",\n\t\"useMap\",\n\t\"frameBorder\",\n\t\"contentEditable\"\n], function() {\n\tjQuery.propFix[ this.toLowerCase() ] = this;\n} );\n\n\n\n\n\t// Strip and collapse whitespace according to HTML spec\n\t// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace\n\tfunction stripAndCollapse( value ) {\n\t\tvar tokens = value.match( rnothtmlwhite ) || [];\n\t\treturn tokens.join( \" \" );\n\t}\n\n\nfunction getClass( elem ) {\n\treturn elem.getAttribute && elem.getAttribute( \"class\" ) || \"\";\n}\n\njQuery.fn.extend( {\n\taddClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tif ( typeof value === \"string\" && value ) {\n\t\t\tclasses = value.match( rnothtmlwhite ) || [];\n\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n\t\t\t\t\t\t\tcur += clazz + \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tif ( !arguments.length ) {\n\t\t\treturn this.attr( \"class\", \"\" );\n\t\t}\n\n\t\tif ( typeof value === \"string\" && value ) {\n\t\t\tclasses = value.match( rnothtmlwhite ) || [];\n\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\n\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\n\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) > -1 ) {\n\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttoggleClass: function( value, stateVal ) {\n\t\tvar type = typeof value;\n\n\t\tif ( typeof stateVal === \"boolean\" && type === \"string\" ) {\n\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t}\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).toggleClass(\n\t\t\t\t\tvalue.call( this, i, getClass( this ), stateVal ),\n\t\t\t\t\tstateVal\n\t\t\t\t);\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar className, i, self, classNames;\n\n\t\t\tif ( type === \"string\" ) {\n\n\t\t\t\t// Toggle individual class names\n\t\t\t\ti = 0;\n\t\t\t\tself = jQuery( this );\n\t\t\t\tclassNames = value.match( rnothtmlwhite ) || [];\n\n\t\t\t\twhile ( ( className = classNames[ i++ ] ) ) {\n\n\t\t\t\t\t// Check each className given, space separated list\n\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Toggle whole class name\n\t\t\t} else if ( value === undefined || type === \"boolean\" ) {\n\t\t\t\tclassName = getClass( this );\n\t\t\t\tif ( className ) {\n\n\t\t\t\t\t// Store className if set\n\t\t\t\t\tdataPriv.set( this, \"__className__\", className );\n\t\t\t\t}\n\n\t\t\t\t// If the element has a class name or if we're passed `false`,\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\tif ( this.setAttribute ) {\n\t\t\t\t\tthis.setAttribute( \"class\",\n\t\t\t\t\t\tclassName || value === false ?\n\t\t\t\t\t\t\"\" :\n\t\t\t\t\t\tdataPriv.get( this, \"__className__\" ) || \"\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\thasClass: function( selector ) {\n\t\tvar className, elem,\n\t\t\ti = 0;\n\n\t\tclassName = \" \" + selector + \" \";\n\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\tif ( elem.nodeType === 1 &&\n\t\t\t\t( \" \" + stripAndCollapse( getClass( elem ) ) + \" \" ).indexOf( className ) > -1 ) {\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n} );\n\n\n\n\nvar rreturn = /\\r/g;\n\njQuery.fn.extend( {\n\tval: function( value ) {\n\t\tvar hooks, ret, isFunction,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !arguments.length ) {\n\t\t\tif ( elem ) {\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] ||\n\t\t\t\t\tjQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\tif ( hooks &&\n\t\t\t\t\t\"get\" in hooks &&\n\t\t\t\t\t( ret = hooks.get( elem, \"value\" ) ) !== undefined\n\t\t\t\t) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tret = elem.value;\n\n\t\t\t\t// Handle most common string cases\n\t\t\t\tif ( typeof ret === \"string\" ) {\n\t\t\t\t\treturn ret.replace( rreturn, \"\" );\n\t\t\t\t}\n\n\t\t\t\t// Handle cases where value is null/undef or number\n\t\t\t\treturn ret == null ? \"\" : ret;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tisFunction = jQuery.isFunction( value );\n\n\t\treturn this.each( function( i ) {\n\t\t\tvar val;\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( isFunction ) {\n\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t} else {\n\t\t\t\tval = value;\n\t\t\t}\n\n\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\tif ( val == null ) {\n\t\t\t\tval = \"\";\n\n\t\t\t} else if ( typeof val === \"number\" ) {\n\t\t\t\tval += \"\";\n\n\t\t\t} else if ( Array.isArray( val ) ) {\n\t\t\t\tval = jQuery.map( val, function( value ) {\n\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\tif ( !hooks || !( \"set\" in hooks ) || hooks.set( this, val, \"value\" ) === undefined ) {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tvalHooks: {\n\t\toption: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\tvar val = jQuery.find.attr( elem, \"value\" );\n\t\t\t\treturn val != null ?\n\t\t\t\t\tval :\n\n\t\t\t\t\t// Support: IE <=10 - 11 only\n\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\n\t\t\t\t\t// Strip and collapse whitespace\n\t\t\t\t\t// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n\t\t\t\t\tstripAndCollapse( jQuery.text( elem ) );\n\t\t\t}\n\t\t},\n\t\tselect: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar value, option, i,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\tone = elem.type === \"select-one\",\n\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\tmax = one ? index + 1 : options.length;\n\n\t\t\t\tif ( index < 0 ) {\n\t\t\t\t\ti = max;\n\n\t\t\t\t} else {\n\t\t\t\t\ti = one ? index : 0;\n\t\t\t\t}\n\n\t\t\t\t// Loop through all the selected options\n\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t// IE8-9 doesn't update selected after form reset (#2551)\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\n\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t!option.disabled &&\n\t\t\t\t\t\t\t( !option.parentNode.disabled ||\n\t\t\t\t\t\t\t\t!nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\n\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t},\n\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar optionSet, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\ti = options.length;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t/* eslint-disable no-cond-assign */\n\n\t\t\t\t\tif ( option.selected =\n\t\t\t\t\t\tjQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1\n\t\t\t\t\t) {\n\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* eslint-enable no-cond-assign */\n\t\t\t\t}\n\n\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Radios and checkboxes getter/setter\njQuery.each( [ \"radio\", \"checkbox\" ], function() {\n\tjQuery.valHooks[ this ] = {\n\t\tset: function( elem, value ) {\n\t\t\tif ( Array.isArray( value ) ) {\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\n\t\t\t}\n\t\t}\n\t};\n\tif ( !support.checkOn ) {\n\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\treturn elem.getAttribute( \"value\" ) === null ? \"on\" : elem.value;\n\t\t};\n\t}\n} );\n\n\n\n\n// Return jQuery for attributes-only inclusion\n\n\nvar rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;\n\njQuery.extend( jQuery.event, {\n\n\ttrigger: function( event, data, elem, onlyHandlers ) {\n\n\t\tvar i, cur, tmp, bubbleType, ontype, handle, special,\n\t\t\teventPath = [ elem || document ],\n\t\t\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\n\t\t\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split( \".\" ) : [];\n\n\t\tcur = tmp = elem = elem || document;\n\n\t\t// Don't do events on text and comment nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( type.indexOf( \".\" ) > -1 ) {\n\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\tnamespaces = type.split( \".\" );\n\t\t\ttype = namespaces.shift();\n\t\t\tnamespaces.sort();\n\t\t}\n\t\tontype = type.indexOf( \":\" ) < 0 && \"on\" + type;\n\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\tevent = event[ jQuery.expando ] ?\n\t\t\tevent :\n\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n\n\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\tevent.namespace = namespaces.join( \".\" );\n\t\tevent.rnamespace = event.namespace ?\n\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" ) :\n\t\t\tnull;\n\n\t\t// Clean up the event in case it is being reused\n\t\tevent.result = undefined;\n\t\tif ( !event.target ) {\n\t\t\tevent.target = elem;\n\t\t}\n\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\tdata = data == null ?\n\t\t\t[ event ] :\n\t\t\tjQuery.makeArray( data, [ event ] );\n\n\t\t// Allow special events to draw outside the lines\n\t\tspecial = jQuery.event.special[ type ] || {};\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\tif ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\n\n\t\t\tbubbleType = special.delegateType || type;\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\teventPath.push( cur );\n\t\t\t\ttmp = cur;\n\t\t\t}\n\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\tif ( tmp === ( elem.ownerDocument || document ) ) {\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t}\n\t\t}\n\n\t\t// Fire handlers on the event path\n\t\ti = 0;\n\t\twhile ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\n\n\t\t\tevent.type = i > 1 ?\n\t\t\t\tbubbleType :\n\t\t\t\tspecial.bindType || type;\n\n\t\t\t// jQuery handler\n\t\t\thandle = ( dataPriv.get( cur, \"events\" ) || {} )[ event.type ] &&\n\t\t\t\tdataPriv.get( cur, \"handle\" );\n\t\t\tif ( handle ) {\n\t\t\t\thandle.apply( cur, data );\n\t\t\t}\n\n\t\t\t// Native handler\n\t\t\thandle = ontype && cur[ ontype ];\n\t\t\tif ( handle && handle.apply && acceptData( cur ) ) {\n\t\t\t\tevent.result = handle.apply( cur, data );\n\t\t\t\tif ( event.result === false ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tevent.type = type;\n\n\t\t// If nobody prevented the default action, do it now\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\tif ( ( !special._default ||\n\t\t\t\tspecial._default.apply( eventPath.pop(), data ) === false ) &&\n\t\t\t\tacceptData( elem ) ) {\n\n\t\t\t\t// Call a native DOM method on the target with the same name as the event.\n\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\tif ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {\n\n\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\ttmp = elem[ ontype ];\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\tjQuery.event.triggered = type;\n\t\t\t\t\telem[ type ]();\n\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\t// Piggyback on a donor event to simulate a different one\n\t// Used only for `focus(in | out)` events\n\tsimulate: function( type, elem, event ) {\n\t\tvar e = jQuery.extend(\n\t\t\tnew jQuery.Event(),\n\t\t\tevent,\n\t\t\t{\n\t\t\t\ttype: type,\n\t\t\t\tisSimulated: true\n\t\t\t}\n\t\t);\n\n\t\tjQuery.event.trigger( e, null, elem );\n\t}\n\n} );\n\njQuery.fn.extend( {\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t} );\n\t},\n\ttriggerHandler: function( type, data ) {\n\t\tvar elem = this[ 0 ];\n\t\tif ( elem ) {\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t}\n\t}\n} );\n\n\njQuery.each( ( \"blur focus focusin focusout resize scroll click dblclick \" +\n\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\"change select submit keydown keypress keyup contextmenu\" ).split( \" \" ),\n\tfunction( i, name ) {\n\n\t// Handle event binding\n\tjQuery.fn[ name ] = function( data, fn ) {\n\t\treturn arguments.length > 0 ?\n\t\t\tthis.on( name, null, data, fn ) :\n\t\t\tthis.trigger( name );\n\t};\n} );\n\njQuery.fn.extend( {\n\thover: function( fnOver, fnOut ) {\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t}\n} );\n\n\n\n\nsupport.focusin = \"onfocusin\" in window;\n\n\n// Support: Firefox <=44\n// Firefox doesn't have focus(in | out) events\n// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n//\n// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n// focus(in | out) events fire after focus & blur events,\n// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\nif ( !support.focusin ) {\n\tjQuery.each( { focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\n\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\tvar handler = function( event ) {\n\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );\n\t\t};\n\n\t\tjQuery.event.special[ fix ] = {\n\t\t\tsetup: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix );\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t\tdataPriv.access( doc, fix, ( attaches || 0 ) + 1 );\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix ) - 1;\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n\t\t\t\t\tdataPriv.remove( doc, fix );\n\n\t\t\t\t} else {\n\t\t\t\t\tdataPriv.access( doc, fix, attaches );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t} );\n}\nvar location = window.location;\n\nvar nonce = jQuery.now();\n\nvar rquery = ( /\\?/ );\n\n\n\n// Cross-browser xml parsing\njQuery.parseXML = function( data ) {\n\tvar xml;\n\tif ( !data || typeof data !== \"string\" ) {\n\t\treturn null;\n\t}\n\n\t// Support: IE 9 - 11 only\n\t// IE throws on parseFromString with invalid input.\n\ttry {\n\t\txml = ( new window.DOMParser() ).parseFromString( data, \"text/xml\" );\n\t} catch ( e ) {\n\t\txml = undefined;\n\t}\n\n\tif ( !xml || xml.getElementsByTagName( \"parsererror\" ).length ) {\n\t\tjQuery.error( \"Invalid XML: \" + data );\n\t}\n\treturn xml;\n};\n\n\nvar\n\trbracket = /\\[\\]$/,\n\trCRLF = /\\r?\\n/g,\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\nfunction buildParams( prefix, obj, traditional, add ) {\n\tvar name;\n\n\tif ( Array.isArray( obj ) ) {\n\n\t\t// Serialize array item.\n\t\tjQuery.each( obj, function( i, v ) {\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\n\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\tadd( prefix, v );\n\n\t\t\t} else {\n\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\tbuildParams(\n\t\t\t\t\tprefix + \"[\" + ( typeof v === \"object\" && v != null ? i : \"\" ) + \"]\",\n\t\t\t\t\tv,\n\t\t\t\t\ttraditional,\n\t\t\t\t\tadd\n\t\t\t\t);\n\t\t\t}\n\t\t} );\n\n\t} else if ( !traditional && jQuery.type( obj ) === \"object\" ) {\n\n\t\t// Serialize object item.\n\t\tfor ( name in obj ) {\n\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\t\t}\n\n\t} else {\n\n\t\t// Serialize scalar item.\n\t\tadd( prefix, obj );\n\t}\n}\n\n// Serialize an array of form elements or a set of\n// key/values into a query string\njQuery.param = function( a, traditional ) {\n\tvar prefix,\n\t\ts = [],\n\t\tadd = function( key, valueOrFunction ) {\n\n\t\t\t// If value is a function, invoke it and use its return value\n\t\t\tvar value = jQuery.isFunction( valueOrFunction ) ?\n\t\t\t\tvalueOrFunction() :\n\t\t\t\tvalueOrFunction;\n\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" +\n\t\t\t\tencodeURIComponent( value == null ? \"\" : value );\n\t\t};\n\n\t// If an array was passed in, assume that it is an array of form elements.\n\tif ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\n\t\t// Serialize the form elements\n\t\tjQuery.each( a, function() {\n\t\t\tadd( this.name, this.value );\n\t\t} );\n\n\t} else {\n\n\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t// did it), otherwise encode params recursively.\n\t\tfor ( prefix in a ) {\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t}\n\t}\n\n\t// Return the resulting serialization\n\treturn s.join( \"&\" );\n};\n\njQuery.fn.extend( {\n\tserialize: function() {\n\t\treturn jQuery.param( this.serializeArray() );\n\t},\n\tserializeArray: function() {\n\t\treturn this.map( function() {\n\n\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t} )\n\t\t.filter( function() {\n\t\t\tvar type = this.type;\n\n\t\t\t// Use .is( \":disabled\" ) so that fieldset[disabled] works\n\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n\t\t} )\n\t\t.map( function( i, elem ) {\n\t\t\tvar val = jQuery( this ).val();\n\n\t\t\tif ( val == null ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif ( Array.isArray( val ) ) {\n\t\t\t\treturn jQuery.map( val, function( val ) {\n\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t} ).get();\n\t}\n} );\n\n\nvar\n\tr20 = /%20/g,\n\trhash = /#.*$/,\n\trantiCache = /([?&])_=[^&]*/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol \"*\" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol \"*\" can be used\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = \"*/\".concat( \"*\" ),\n\n\t// Anchor tag for parsing the document origin\n\toriginAnchor = document.createElement( \"a\" );\n\toriginAnchor.href = location.href;\n\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to \"*\"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = \"*\";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];\n\n\t\tif ( jQuery.isFunction( func ) ) {\n\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\n\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType[ 0 ] === \"+\" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif ( typeof dataTypeOrTransport === \"string\" &&\n\t\t\t\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t} );\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n}\n\n// A special extend for ajax options\n// that takes \"flat\" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n\tvar key, deep,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n\n\treturn target;\n}\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\n\tvar ct, type, finalDataType, firstDataType,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes;\n\n\t// Remove auto dataType and get content-type in the process\n\twhile ( dataTypes[ 0 ] === \"*\" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader( \"Content-Type\" );\n\t\t}\n\t}\n\n\t// Check if we're dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[ 0 ] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\tvar conv2, current, conv, tmp, prev,\n\t\tconverters = {},\n\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\tcurrent = dataTypes.shift();\n\n\t// Convert to each sequential dataType\n\twhile ( current ) {\n\n\t\tif ( s.responseFields[ current ] ) {\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t}\n\n\t\t// Apply the dataFilter if provided\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t}\n\n\t\tprev = current;\n\t\tcurrent = dataTypes.shift();\n\n\t\tif ( current ) {\n\n\t\t\t// There's only work to do if current dataType is non-auto\n\t\t\tif ( current === \"*\" ) {\n\n\t\t\t\tcurrent = prev;\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split( \" \" );\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s.throws ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tstate: \"parsererror\",\n\t\t\t\t\t\t\t\terror: conv ? e : \"No conversion from \" + prev + \" to \" + current\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { state: \"success\", data: response };\n}\n\njQuery.extend( {\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: location.href,\n\t\ttype: \"GET\",\n\t\tisLocal: rlocalProtocol.test( location.protocol ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t\"*\": allTypes,\n\t\t\ttext: \"text/plain\",\n\t\t\thtml: \"text/html\",\n\t\t\txml: \"application/xml, text/xml\",\n\t\t\tjson: \"application/json, text/javascript\"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /\\bxml\\b/,\n\t\t\thtml: /\\bhtml/,\n\t\t\tjson: /\\bjson\\b/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: \"responseXML\",\n\t\t\ttext: \"responseText\",\n\t\t\tjson: \"responseJSON\"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t\"* text\": String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t\"text html\": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t\"text json\": JSON.parse,\n\n\t\t\t// Parse text as xml\n\t\t\t\"text xml\": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn't be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn't be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === \"object\" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar transport,\n\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\n\t\t\t// Response headers\n\t\t\tresponseHeadersString,\n\t\t\tresponseHeaders,\n\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\n\t\t\t// Url cleanup var\n\t\t\turlAnchor,\n\n\t\t\t// Request state (becomes false upon send and true upon completion)\n\t\t\tcompleted,\n\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\n\t\t\t// Loop variable\n\t\t\ti,\n\n\t\t\t// uncached part of the url\n\t\t\tuncached,\n\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context &&\n\t\t\t\t( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\t\tjQuery.event,\n\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks( \"once memory\" ),\n\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\n\t\t\t// Default abort message\n\t\t\tstrAbort = \"canceled\",\n\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( completed ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn completed ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\tname = requestHeadersNames[ name.toLowerCase() ] =\n\t\t\t\t\t\t\trequestHeadersNames[ name.toLowerCase() ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\tif ( completed ) {\n\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Lazy-add the new callbacks in a way that preserves old ones\n\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR );\n\n\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url || location.href ) + \"\" )\n\t\t\t.replace( rprotocol, location.protocol + \"//\" );\n\n\t\t// Alias method option to type as per ticket #12004\n\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = ( s.dataType || \"*\" ).toLowerCase().match( rnothtmlwhite ) || [ \"\" ];\n\n\t\t// A cross-domain request is in order when the origin doesn't match the current origin.\n\t\tif ( s.crossDomain == null ) {\n\t\t\turlAnchor = document.createElement( \"a\" );\n\n\t\t\t// Support: IE <=8 - 11, Edge 12 - 13\n\t\t\t// IE throws exception on accessing the href property if url is malformed,\n\t\t\t// e.g. http://example.com:80x/\n\t\t\ttry {\n\t\t\t\turlAnchor.href = s.url;\n\n\t\t\t\t// Support: IE <=8 - 11 only\n\t\t\t\t// Anchor's host property isn't correctly set when s.url is relative\n\t\t\t\turlAnchor.href = urlAnchor.href;\n\t\t\t\ts.crossDomain = originAnchor.protocol + \"//\" + originAnchor.host !==\n\t\t\t\t\turlAnchor.protocol + \"//\" + urlAnchor.host;\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// If there is an error parsing the URL, assume it is crossDomain,\n\t\t\t\t// it can be rejected by the transport if it is invalid\n\t\t\t\ts.crossDomain = true;\n\t\t\t}\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( completed ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\tfireGlobals = jQuery.event && s.global;\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger( \"ajaxStart\" );\n\t\t}\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t// and/or If-None-Match header later on\n\t\t// Remove hash to simplify url manipulation\n\t\tcacheURL = s.url.replace( rhash, \"\" );\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// Remember the hash so we can put it back\n\t\t\tuncached = s.url.slice( cacheURL.length );\n\n\t\t\t// If data is available, append data to url\n\t\t\tif ( s.data ) {\n\t\t\t\tcacheURL += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data;\n\n\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Add or update anti-cache param if needed\n\t\t\tif ( s.cache === false ) {\n\t\t\t\tcacheURL = cacheURL.replace( rantiCache, \"$1\" );\n\t\t\t\tuncached = ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + ( nonce++ ) + uncached;\n\t\t\t}\n\n\t\t\t// Put hash and anti-cache on the URL that will be requested (gh-1732)\n\t\t\ts.url = cacheURL + uncached;\n\n\t\t// Change '%20' to '+' if this is encoded form body content (gh-2658)\n\t\t} else if ( s.data && s.processData &&\n\t\t\t( s.contentType || \"\" ).indexOf( \"application/x-www-form-urlencoded\" ) === 0 ) {\n\t\t\ts.data = s.data.replace( r20, \"+\" );\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t\"Accept\",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[ 0 ] ] +\n\t\t\t\t\t( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\ts.accepts[ \"*\" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend &&\n\t\t\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {\n\n\t\t\t// Abort if not done already and return\n\t\t\treturn jqXHR.abort();\n\t\t}\n\n\t\t// Aborting is no longer a cancellation\n\t\tstrAbort = \"abort\";\n\n\t\t// Install callbacks on deferreds\n\t\tcompleteDeferred.add( s.complete );\n\t\tjqXHR.done( s.success );\n\t\tjqXHR.fail( s.error );\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, \"No Transport\" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t}\n\n\t\t\t// If request was aborted inside ajaxSend, stop there\n\t\t\tif ( completed ) {\n\t\t\t\treturn jqXHR;\n\t\t\t}\n\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = window.setTimeout( function() {\n\t\t\t\t\tjqXHR.abort( \"timeout\" );\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tcompleted = false;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// Rethrow post-completion exceptions\n\t\t\t\tif ( completed ) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\n\t\t\t\t// Propagate others as results\n\t\t\t\tdone( -1, e );\n\t\t\t}\n\t\t}\n\n\t\t// Callback for when everything is done\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Ignore repeat invocations\n\t\t\tif ( completed ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcompleted = true;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\twindow.clearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || \"\";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Determine if successful\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( isSuccess ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"Last-Modified\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"etag\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if no content\n\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n\t\t\t\t\tstatusText = \"nocontent\";\n\n\t\t\t\t// if not modified\n\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\tstatusText = \"notmodified\";\n\n\t\t\t\t// If we have data, let's convert it\n\t\t\t\t} else {\n\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\terror = response.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// Extract error from statusText and normalize for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger( \"ajaxStop\" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t}\n} );\n\njQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\n\t\t// Shift arguments if data argument was omitted\n\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\t// The url can be an options object (which then must have .url)\n\t\treturn jQuery.ajax( jQuery.extend( {\n\t\t\turl: url,\n\t\t\ttype: method,\n\t\t\tdataType: type,\n\t\t\tdata: data,\n\t\t\tsuccess: callback\n\t\t}, jQuery.isPlainObject( url ) && url ) );\n\t};\n} );\n\n\njQuery._evalUrl = function( url ) {\n\treturn jQuery.ajax( {\n\t\turl: url,\n\n\t\t// Make this explicit, since user can override this through ajaxSetup (#11264)\n\t\ttype: \"GET\",\n\t\tdataType: \"script\",\n\t\tcache: true,\n\t\tasync: false,\n\t\tglobal: false,\n\t\t\"throws\": true\n\t} );\n};\n\n\njQuery.fn.extend( {\n\twrapAll: function( html ) {\n\t\tvar wrap;\n\n\t\tif ( this[ 0 ] ) {\n\t\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\t\thtml = html.call( this[ 0 ] );\n\t\t\t}\n\n\t\t\t// The elements to wrap the target around\n\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\n\t\t\tif ( this[ 0 ].parentNode ) {\n\t\t\t\twrap.insertBefore( this[ 0 ] );\n\t\t\t}\n\n\t\t\twrap.map( function() {\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstElementChild ) {\n\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t} ).append( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).wrapInner( html.call( this, i ) );\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar self = jQuery( this ),\n\t\t\t\tcontents = self.contents();\n\n\t\t\tif ( contents.length ) {\n\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t} else {\n\t\t\t\tself.append( html );\n\t\t\t}\n\t\t} );\n\t},\n\n\twrap: function( html ) {\n\t\tvar isFunction = jQuery.isFunction( html );\n\n\t\treturn this.each( function( i ) {\n\t\t\tjQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );\n\t\t} );\n\t},\n\n\tunwrap: function( selector ) {\n\t\tthis.parent( selector ).not( \"body\" ).each( function() {\n\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t} );\n\t\treturn this;\n\t}\n} );\n\n\njQuery.expr.pseudos.hidden = function( elem ) {\n\treturn !jQuery.expr.pseudos.visible( elem );\n};\njQuery.expr.pseudos.visible = function( elem ) {\n\treturn !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );\n};\n\n\n\n\njQuery.ajaxSettings.xhr = function() {\n\ttry {\n\t\treturn new window.XMLHttpRequest();\n\t} catch ( e ) {}\n};\n\nvar xhrSuccessStatus = {\n\n\t\t// File protocol always yields status code 0, assume 200\n\t\t0: 200,\n\n\t\t// Support: IE <=9 only\n\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t1223: 204\n\t},\n\txhrSupported = jQuery.ajaxSettings.xhr();\n\nsupport.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\nsupport.ajax = xhrSupported = !!xhrSupported;\n\njQuery.ajaxTransport( function( options ) {\n\tvar callback, errorCallback;\n\n\t// Cross domain only allowed if supported through XMLHttpRequest\n\tif ( support.cors || xhrSupported && !options.crossDomain ) {\n\t\treturn {\n\t\t\tsend: function( headers, complete ) {\n\t\t\t\tvar i,\n\t\t\t\t\txhr = options.xhr();\n\n\t\t\t\txhr.open(\n\t\t\t\t\toptions.type,\n\t\t\t\t\toptions.url,\n\t\t\t\t\toptions.async,\n\t\t\t\t\toptions.username,\n\t\t\t\t\toptions.password\n\t\t\t\t);\n\n\t\t\t\t// Apply custom fields if provided\n\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Override mime type if needed\n\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t}\n\n\t\t\t\t// X-Requested-With header\n\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\tif ( !options.crossDomain && !headers[ \"X-Requested-With\" ] ) {\n\t\t\t\t\theaders[ \"X-Requested-With\" ] = \"XMLHttpRequest\";\n\t\t\t\t}\n\n\t\t\t\t// Set headers\n\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t}\n\n\t\t\t\t// Callback\n\t\t\t\tcallback = function( type ) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tcallback = errorCallback = xhr.onload =\n\t\t\t\t\t\t\t\txhr.onerror = xhr.onabort = xhr.onreadystatechange = null;\n\n\t\t\t\t\t\t\tif ( type === \"abort\" ) {\n\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t} else if ( type === \"error\" ) {\n\n\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t// On a manual native abort, IE9 throws\n\t\t\t\t\t\t\t\t// errors on any property access that is not readyState\n\t\t\t\t\t\t\t\tif ( typeof xhr.status !== \"number\" ) {\n\t\t\t\t\t\t\t\t\tcomplete( 0, \"error\" );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcomplete(\n\n\t\t\t\t\t\t\t\t\t\t// File: protocol always yields status 0; see #8605, #14207\n\t\t\t\t\t\t\t\t\t\txhr.status,\n\t\t\t\t\t\t\t\t\t\txhr.statusText\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText,\n\n\t\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t\t// IE9 has no XHR2 but throws on binary (trac-11426)\n\t\t\t\t\t\t\t\t\t// For XHR2 non-text, let the caller handle it (gh-2498)\n\t\t\t\t\t\t\t\t\t( xhr.responseType || \"text\" ) !== \"text\"  ||\n\t\t\t\t\t\t\t\t\ttypeof xhr.responseText !== \"string\" ?\n\t\t\t\t\t\t\t\t\t\t{ binary: xhr.response } :\n\t\t\t\t\t\t\t\t\t\t{ text: xhr.responseText },\n\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\t// Listen to events\n\t\t\t\txhr.onload = callback();\n\t\t\t\terrorCallback = xhr.onerror = callback( \"error\" );\n\n\t\t\t\t// Support: IE 9 only\n\t\t\t\t// Use onreadystatechange to replace onabort\n\t\t\t\t// to handle uncaught aborts\n\t\t\t\tif ( xhr.onabort !== undefined ) {\n\t\t\t\t\txhr.onabort = errorCallback;\n\t\t\t\t} else {\n\t\t\t\t\txhr.onreadystatechange = function() {\n\n\t\t\t\t\t\t// Check readyState before timeout as it changes\n\t\t\t\t\t\tif ( xhr.readyState === 4 ) {\n\n\t\t\t\t\t\t\t// Allow onerror to be called first,\n\t\t\t\t\t\t\t// but that will not handle a native abort\n\t\t\t\t\t\t\t// Also, save errorCallback to a variable\n\t\t\t\t\t\t\t// as xhr.onerror cannot be accessed\n\t\t\t\t\t\t\twindow.setTimeout( function() {\n\t\t\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\t\t\terrorCallback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Create the abort callback\n\t\t\t\tcallback = callback( \"abort\" );\n\n\t\t\t\ttry {\n\n\t\t\t\t\t// Do send the request (this may raise an exception)\n\t\t\t\t\txhr.send( options.hasContent && options.data || null );\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t// #14683: Only rethrow if this hasn't been notified as an error yet\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\n// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\njQuery.ajaxPrefilter( function( s ) {\n\tif ( s.crossDomain ) {\n\t\ts.contents.script = false;\n\t}\n} );\n\n// Install script dataType\njQuery.ajaxSetup( {\n\taccepts: {\n\t\tscript: \"text/javascript, application/javascript, \" +\n\t\t\t\"application/ecmascript, application/x-ecmascript\"\n\t},\n\tcontents: {\n\t\tscript: /\\b(?:java|ecma)script\\b/\n\t},\n\tconverters: {\n\t\t\"text script\": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n} );\n\n// Handle cache's special case and crossDomain\njQuery.ajaxPrefilter( \"script\", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = \"GET\";\n\t}\n} );\n\n// Bind script tag hack transport\njQuery.ajaxTransport( \"script\", function( s ) {\n\n\t// This transport only deals with cross domain requests\n\tif ( s.crossDomain ) {\n\t\tvar script, callback;\n\t\treturn {\n\t\t\tsend: function( _, complete ) {\n\t\t\t\tscript = jQuery( \"<script>\" ).prop( {\n\t\t\t\t\tcharset: s.scriptCharset,\n\t\t\t\t\tsrc: s.url\n\t\t\t\t} ).on(\n\t\t\t\t\t\"load error\",\n\t\t\t\t\tcallback = function( evt ) {\n\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\tif ( evt ) {\n\t\t\t\t\t\t\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\t// Use native DOM manipulation to avoid our domManip AJAX trickery\n\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n\t\t\t},\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\nvar oldCallbacks = [],\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup( {\n\tjsonp: \"callback\",\n\tjsonpCallback: function() {\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce++ ) );\n\t\tthis[ callback ] = true;\n\t\treturn callback;\n\t}\n} );\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\n\tvar callbackName, overwritten, responseContainer,\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t\"url\" :\n\t\t\ttypeof s.data === \"string\" &&\n\t\t\t\t( s.contentType || \"\" )\n\t\t\t\t\t.indexOf( \"application/x-www-form-urlencoded\" ) === 0 &&\n\t\t\t\trjsonp.test( s.data ) && \"data\"\n\t\t);\n\n\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\n\t\t// Get callback name, remembering preexisting value associated with it\n\t\tcallbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\n\t\t\ts.jsonpCallback() :\n\t\t\ts.jsonpCallback;\n\n\t\t// Insert callback into url or form data\n\t\tif ( jsonProp ) {\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n\t\t} else if ( s.jsonp !== false ) {\n\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n\t\t}\n\n\t\t// Use data converter to retrieve json after script execution\n\t\ts.converters[ \"script json\" ] = function() {\n\t\t\tif ( !responseContainer ) {\n\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n\t\t\t}\n\t\t\treturn responseContainer[ 0 ];\n\t\t};\n\n\t\t// Force json dataType\n\t\ts.dataTypes[ 0 ] = \"json\";\n\n\t\t// Install callback\n\t\toverwritten = window[ callbackName ];\n\t\twindow[ callbackName ] = function() {\n\t\t\tresponseContainer = arguments;\n\t\t};\n\n\t\t// Clean-up function (fires after converters)\n\t\tjqXHR.always( function() {\n\n\t\t\t// If previous value didn't exist - remove it\n\t\t\tif ( overwritten === undefined ) {\n\t\t\t\tjQuery( window ).removeProp( callbackName );\n\n\t\t\t// Otherwise restore preexisting value\n\t\t\t} else {\n\t\t\t\twindow[ callbackName ] = overwritten;\n\t\t\t}\n\n\t\t\t// Save back as free\n\t\t\tif ( s[ callbackName ] ) {\n\n\t\t\t\t// Make sure that re-using the options doesn't screw things around\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t// Save the callback name for future use\n\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t}\n\n\t\t\t// Call if it was a function and we have a response\n\t\t\tif ( responseContainer && jQuery.isFunction( overwritten ) ) {\n\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t}\n\n\t\t\tresponseContainer = overwritten = undefined;\n\t\t} );\n\n\t\t// Delegate to script\n\t\treturn \"script\";\n\t}\n} );\n\n\n\n\n// Support: Safari 8 only\n// In Safari 8 documents created via document.implementation.createHTMLDocument\n// collapse sibling forms: the second one becomes a child of the first one.\n// Because of that, this security measure has to be disabled in Safari 8.\n// https://bugs.webkit.org/show_bug.cgi?id=137337\nsupport.createHTMLDocument = ( function() {\n\tvar body = document.implementation.createHTMLDocument( \"\" ).body;\n\tbody.innerHTML = \"<form></form><form></form>\";\n\treturn body.childNodes.length === 2;\n} )();\n\n\n// Argument \"data\" should be string of html\n// context (optional): If specified, the fragment will be created in this context,\n// defaults to document\n// keepScripts (optional): If true, will include scripts passed in the html string\njQuery.parseHTML = function( data, context, keepScripts ) {\n\tif ( typeof data !== \"string\" ) {\n\t\treturn [];\n\t}\n\tif ( typeof context === \"boolean\" ) {\n\t\tkeepScripts = context;\n\t\tcontext = false;\n\t}\n\n\tvar base, parsed, scripts;\n\n\tif ( !context ) {\n\n\t\t// Stop scripts or inline event handlers from being executed immediately\n\t\t// by using document.implementation\n\t\tif ( support.createHTMLDocument ) {\n\t\t\tcontext = document.implementation.createHTMLDocument( \"\" );\n\n\t\t\t// Set the base href for the created document\n\t\t\t// so any parsed elements with URLs\n\t\t\t// are based on the document's URL (gh-2965)\n\t\t\tbase = context.createElement( \"base\" );\n\t\t\tbase.href = document.location.href;\n\t\t\tcontext.head.appendChild( base );\n\t\t} else {\n\t\t\tcontext = document;\n\t\t}\n\t}\n\n\tparsed = rsingleTag.exec( data );\n\tscripts = !keepScripts && [];\n\n\t// Single tag\n\tif ( parsed ) {\n\t\treturn [ context.createElement( parsed[ 1 ] ) ];\n\t}\n\n\tparsed = buildFragment( [ data ], context, scripts );\n\n\tif ( scripts && scripts.length ) {\n\t\tjQuery( scripts ).remove();\n\t}\n\n\treturn jQuery.merge( [], parsed.childNodes );\n};\n\n\n/**\n * Load a url into a page\n */\njQuery.fn.load = function( url, params, callback ) {\n\tvar selector, type, response,\n\t\tself = this,\n\t\toff = url.indexOf( \" \" );\n\n\tif ( off > -1 ) {\n\t\tselector = stripAndCollapse( url.slice( off ) );\n\t\turl = url.slice( 0, off );\n\t}\n\n\t// If it's a function\n\tif ( jQuery.isFunction( params ) ) {\n\n\t\t// We assume that it's the callback\n\t\tcallback = params;\n\t\tparams = undefined;\n\n\t// Otherwise, build a param string\n\t} else if ( params && typeof params === \"object\" ) {\n\t\ttype = \"POST\";\n\t}\n\n\t// If we have elements to modify, make the request\n\tif ( self.length > 0 ) {\n\t\tjQuery.ajax( {\n\t\t\turl: url,\n\n\t\t\t// If \"type\" variable is undefined, then \"GET\" method will be used.\n\t\t\t// Make value of this field explicit since\n\t\t\t// user can override it through ajaxSetup method\n\t\t\ttype: type || \"GET\",\n\t\t\tdataType: \"html\",\n\t\t\tdata: params\n\t\t} ).done( function( responseText ) {\n\n\t\t\t// Save response for use in complete callback\n\t\t\tresponse = arguments;\n\n\t\t\tself.html( selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\tjQuery( \"<div>\" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText );\n\n\t\t// If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\n\t\t// but they are ignored because response was set above.\n\t\t// If it fails, this function gets \"jqXHR\", \"status\", \"error\"\n\t\t} ).always( callback && function( jqXHR, status ) {\n\t\t\tself.each( function() {\n\t\t\t\tcallback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t\t} );\n\t\t} );\n\t}\n\n\treturn this;\n};\n\n\n\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( [\n\t\"ajaxStart\",\n\t\"ajaxStop\",\n\t\"ajaxComplete\",\n\t\"ajaxError\",\n\t\"ajaxSuccess\",\n\t\"ajaxSend\"\n], function( i, type ) {\n\tjQuery.fn[ type ] = function( fn ) {\n\t\treturn this.on( type, fn );\n\t};\n} );\n\n\n\n\njQuery.expr.pseudos.animated = function( elem ) {\n\treturn jQuery.grep( jQuery.timers, function( fn ) {\n\t\treturn elem === fn.elem;\n\t} ).length;\n};\n\n\n\n\njQuery.offset = {\n\tsetOffset: function( elem, options, i ) {\n\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\tposition = jQuery.css( elem, \"position\" ),\n\t\t\tcurElem = jQuery( elem ),\n\t\t\tprops = {};\n\n\t\t// Set position first, in-case top/left are set even on static elem\n\t\tif ( position === \"static\" ) {\n\t\t\telem.style.position = \"relative\";\n\t\t}\n\n\t\tcurOffset = curElem.offset();\n\t\tcurCSSTop = jQuery.css( elem, \"top\" );\n\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\n\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\n\t\t\t( curCSSTop + curCSSLeft ).indexOf( \"auto\" ) > -1;\n\n\t\t// Need to be able to calculate position if either\n\t\t// top or left is auto and position is either absolute or fixed\n\t\tif ( calculatePosition ) {\n\t\t\tcurPosition = curElem.position();\n\t\t\tcurTop = curPosition.top;\n\t\t\tcurLeft = curPosition.left;\n\n\t\t} else {\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t}\n\n\t\tif ( jQuery.isFunction( options ) ) {\n\n\t\t\t// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n\t\t\toptions = options.call( elem, i, jQuery.extend( {}, curOffset ) );\n\t\t}\n\n\t\tif ( options.top != null ) {\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t}\n\t\tif ( options.left != null ) {\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t}\n\n\t\tif ( \"using\" in options ) {\n\t\t\toptions.using.call( elem, props );\n\n\t\t} else {\n\t\t\tcurElem.css( props );\n\t\t}\n\t}\n};\n\njQuery.fn.extend( {\n\toffset: function( options ) {\n\n\t\t// Preserve chaining for setter\n\t\tif ( arguments.length ) {\n\t\t\treturn options === undefined ?\n\t\t\t\tthis :\n\t\t\t\tthis.each( function( i ) {\n\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t\t} );\n\t\t}\n\n\t\tvar doc, docElem, rect, win,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !elem ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Return zeros for disconnected and hidden (display: none) elements (gh-2310)\n\t\t// Support: IE <=11 only\n\t\t// Running getBoundingClientRect on a\n\t\t// disconnected node in IE throws an error\n\t\tif ( !elem.getClientRects().length ) {\n\t\t\treturn { top: 0, left: 0 };\n\t\t}\n\n\t\trect = elem.getBoundingClientRect();\n\n\t\tdoc = elem.ownerDocument;\n\t\tdocElem = doc.documentElement;\n\t\twin = doc.defaultView;\n\n\t\treturn {\n\t\t\ttop: rect.top + win.pageYOffset - docElem.clientTop,\n\t\t\tleft: rect.left + win.pageXOffset - docElem.clientLeft\n\t\t};\n\t},\n\n\tposition: function() {\n\t\tif ( !this[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar offsetParent, offset,\n\t\t\telem = this[ 0 ],\n\t\t\tparentOffset = { top: 0, left: 0 };\n\n\t\t// Fixed elements are offset from window (parentOffset = {top:0, left: 0},\n\t\t// because it is its only offset parent\n\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n\n\t\t\t// Assume getBoundingClientRect is there when computed position is fixed\n\t\t\toffset = elem.getBoundingClientRect();\n\n\t\t} else {\n\n\t\t\t// Get *real* offsetParent\n\t\t\toffsetParent = this.offsetParent();\n\n\t\t\t// Get correct offsets\n\t\t\toffset = this.offset();\n\t\t\tif ( !nodeName( offsetParent[ 0 ], \"html\" ) ) {\n\t\t\t\tparentOffset = offsetParent.offset();\n\t\t\t}\n\n\t\t\t// Add offsetParent borders\n\t\t\tparentOffset = {\n\t\t\t\ttop: parentOffset.top + jQuery.css( offsetParent[ 0 ], \"borderTopWidth\", true ),\n\t\t\t\tleft: parentOffset.left + jQuery.css( offsetParent[ 0 ], \"borderLeftWidth\", true )\n\t\t\t};\n\t\t}\n\n\t\t// Subtract parent offsets and element margins\n\t\treturn {\n\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\n\t\t};\n\t},\n\n\t// This method will return documentElement in the following cases:\n\t// 1) For the element inside the iframe without offsetParent, this method will return\n\t//    documentElement of the parent window\n\t// 2) For the hidden or detached element\n\t// 3) For body or html element, i.e. in case of the html node - it will return itself\n\t//\n\t// but those exceptions were never presented as a real life use-cases\n\t// and might be considered as more preferable results.\n\t//\n\t// This logic, however, is not guaranteed and can change at any point in the future\n\toffsetParent: function() {\n\t\treturn this.map( function() {\n\t\t\tvar offsetParent = this.offsetParent;\n\n\t\t\twhile ( offsetParent && jQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\n\t\t\treturn offsetParent || documentElement;\n\t\t} );\n\t}\n} );\n\n// Create scrollLeft and scrollTop methods\njQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\n\tvar top = \"pageYOffset\" === prop;\n\n\tjQuery.fn[ method ] = function( val ) {\n\t\treturn access( this, function( elem, method, val ) {\n\n\t\t\t// Coalesce documents and windows\n\t\t\tvar win;\n\t\t\tif ( jQuery.isWindow( elem ) ) {\n\t\t\t\twin = elem;\n\t\t\t} else if ( elem.nodeType === 9 ) {\n\t\t\t\twin = elem.defaultView;\n\t\t\t}\n\n\t\t\tif ( val === undefined ) {\n\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n\t\t\t}\n\n\t\t\tif ( win ) {\n\t\t\t\twin.scrollTo(\n\t\t\t\t\t!top ? val : win.pageXOffset,\n\t\t\t\t\ttop ? val : win.pageYOffset\n\t\t\t\t);\n\n\t\t\t} else {\n\t\t\t\telem[ method ] = val;\n\t\t\t}\n\t\t}, method, val, arguments.length );\n\t};\n} );\n\n// Support: Safari <=7 - 9.1, Chrome <=37 - 49\n// Add the top/left cssHooks using jQuery.fn.position\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\n// getComputedStyle returns percent when specified for top/left/bottom/right;\n// rather than make the css module depend on the offset module, just check for it here\njQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\n\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n\t\tfunction( elem, computed ) {\n\t\t\tif ( computed ) {\n\t\t\t\tcomputed = curCSS( elem, prop );\n\n\t\t\t\t// If curCSS returns percentage, fallback to offset\n\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n\t\t\t\t\tcomputed;\n\t\t\t}\n\t\t}\n\t);\n} );\n\n\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name },\n\t\tfunction( defaultExtra, funcName ) {\n\n\t\t// Margin is only for outerHeight, outerWidth\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\n\t\t\treturn access( this, function( elem, type, value ) {\n\t\t\t\tvar doc;\n\n\t\t\t\tif ( jQuery.isWindow( elem ) ) {\n\n\t\t\t\t\t// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\n\t\t\t\t\treturn funcName.indexOf( \"outer\" ) === 0 ?\n\t\t\t\t\t\telem[ \"inner\" + name ] :\n\t\t\t\t\t\telem.document.documentElement[ \"client\" + name ];\n\t\t\t\t}\n\n\t\t\t\t// Get document width or height\n\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t// whichever is greatest\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n\t\t\t\t\t\tdoc[ \"client\" + name ]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn value === undefined ?\n\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t}, type, chainable ? margin : undefined, chainable );\n\t\t};\n\t} );\n} );\n\n\njQuery.fn.extend( {\n\n\tbind: function( types, data, fn ) {\n\t\treturn this.on( types, null, data, fn );\n\t},\n\tunbind: function( types, fn ) {\n\t\treturn this.off( types, null, fn );\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.on( types, selector, data, fn );\n\t},\n\tundelegate: function( selector, types, fn ) {\n\n\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\treturn arguments.length === 1 ?\n\t\t\tthis.off( selector, \"**\" ) :\n\t\t\tthis.off( types, selector || \"**\", fn );\n\t}\n} );\n\njQuery.holdReady = function( hold ) {\n\tif ( hold ) {\n\t\tjQuery.readyWait++;\n\t} else {\n\t\tjQuery.ready( true );\n\t}\n};\njQuery.isArray = Array.isArray;\njQuery.parseJSON = JSON.parse;\njQuery.nodeName = nodeName;\n\n\n\n\n// Register as a named AMD module, since jQuery can be concatenated with other\n// files that may use define, but not via a proper concatenation script that\n// understands anonymous AMD modules. A named AMD is safest and most robust\n// way to register. Lowercase jquery is used because AMD module names are\n// derived from file names, and jQuery is normally delivered in a lowercase\n// file name. Do this after creating the global so that if an AMD module wants\n// to call noConflict to hide this version of jQuery, it will work.\n\n// Note that for maximum portability, libraries that are not jQuery should\n// declare themselves as anonymous modules, and avoid setting a global if an\n// AMD loader is present. jQuery is a special case. For more information, see\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\nif ( typeof define === \"function\" && define.amd ) {\n\tdefine( \"jquery\", [], function() {\n\t\treturn jQuery;\n\t} );\n}\n\n\n\n\nvar\n\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$;\n\njQuery.noConflict = function( deep ) {\n\tif ( window.$ === jQuery ) {\n\t\twindow.$ = _$;\n\t}\n\n\tif ( deep && window.jQuery === jQuery ) {\n\t\twindow.jQuery = _jQuery;\n\t}\n\n\treturn jQuery;\n};\n\n// Expose jQuery and $ identifiers, even in AMD\n// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n// and CommonJS for browser emulators (#13566)\nif ( !noGlobal ) {\n\twindow.jQuery = window.$ = jQuery;\n}\n\n\n\n\nreturn jQuery;\n} );\n  })();\n});","\nrequire.register(\"phoenix/priv/static/phoenix.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"phoenix\");\n  (function() {\n    (function (global, factory) {\ntypeof exports === 'object' ? factory(exports) :\ntypeof define === 'function' && define.amd ? define(['exports'], factory) :\nfactory(global.Phoenix = global.Phoenix || {});\n}(this, (function (exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Phoenix Channels JavaScript client\n *\n * ## Socket Connection\n *\n * A single connection is established to the server and\n * channels are multiplexed over the connection.\n * Connect to the server using the `Socket` class:\n *\n * ```javascript\n *     let socket = new Socket(\"/socket\", {params: {userToken: \"123\"}})\n *     socket.connect()\n * ```\n *\n * The `Socket` constructor takes the mount point of the socket,\n * the authentication params, as well as options that can be found in\n * the Socket docs, such as configuring the `LongPoll` transport, and\n * heartbeat.\n *\n * ## Channels\n *\n * Channels are isolated, concurrent processes on the server that\n * subscribe to topics and broker events between the client and server.\n * To join a channel, you must provide the topic, and channel params for\n * authorization. Here's an example chat room example where `\"new_msg\"`\n * events are listened for, messages are pushed to the server, and\n * the channel is joined with ok/error/timeout matches:\n *\n * ```javascript\n *     let channel = socket.channel(\"room:123\", {token: roomToken})\n *     channel.on(\"new_msg\", msg => console.log(\"Got message\", msg) )\n *     $input.onEnter( e => {\n *       channel.push(\"new_msg\", {body: e.target.val}, 10000)\n *        .receive(\"ok\", (msg) => console.log(\"created message\", msg) )\n *        .receive(\"error\", (reasons) => console.log(\"create failed\", reasons) )\n *        .receive(\"timeout\", () => console.log(\"Networking issue...\") )\n *     })\n *     channel.join()\n *       .receive(\"ok\", ({messages}) => console.log(\"catching up\", messages) )\n *       .receive(\"error\", ({reason}) => console.log(\"failed join\", reason) )\n *       .receive(\"timeout\", () => console.log(\"Networking issue. Still waiting...\") )\n *```\n *\n * ## Joining\n *\n * Creating a channel with `socket.channel(topic, params)`, binds the params to\n * `channel.params`, which are sent up on `channel.join()`.\n * Subsequent rejoins will send up the modified params for\n * updating authorization params, or passing up last_message_id information.\n * Successful joins receive an \"ok\" status, while unsuccessful joins\n * receive \"error\".\n *\n * ## Duplicate Join Subscriptions\n *\n * While the client may join any number of topics on any number of channels,\n * the client may only hold a single subscription for each unique topic at any\n * given time. When attempting to create a duplicate subscription,\n * the server will close the existing channel, log a warning, and\n * spawn a new channel for the topic. The client will have their\n * `channel.onClose` callbacks fired for the existing channel, and the new\n * channel join will have its receive hooks processed as normal.\n *\n * ## Pushing Messages\n *\n * From the previous example, we can see that pushing messages to the server\n * can be done with `channel.push(eventName, payload)` and we can optionally\n * receive responses from the push. Additionally, we can use\n * `receive(\"timeout\", callback)` to abort waiting for our other `receive` hooks\n *  and take action after some period of waiting. The default timeout is 5000ms.\n *\n *\n * ## Socket Hooks\n *\n * Lifecycle events of the multiplexed connection can be hooked into via\n * `socket.onError()` and `socket.onClose()` events, ie:\n *\n * ```javascript\n *     socket.onError( () => console.log(\"there was an error with the connection!\") )\n *     socket.onClose( () => console.log(\"the connection dropped\") )\n * ```\n *\n *\n * ## Channel Hooks\n *\n * For each joined channel, you can bind to `onError` and `onClose` events\n * to monitor the channel lifecycle, ie:\n *\n * ```javascript\n *     channel.onError( () => console.log(\"there was an error!\") )\n *     channel.onClose( () => console.log(\"the channel has gone away gracefully\") )\n * ```\n *\n * ### onError hooks\n *\n * `onError` hooks are invoked if the socket connection drops, or the channel\n * crashes on the server. In either case, a channel rejoin is attempted\n * automatically in an exponential backoff manner.\n *\n * ### onClose hooks\n *\n * `onClose` hooks are invoked only in two cases. 1) the channel explicitly\n * closed on the server, or 2). The client explicitly closed, by calling\n * `channel.leave()`\n *\n *\n * ## Presence\n *\n * The `Presence` object provides features for syncing presence information\n * from the server with the client and handling presences joining and leaving.\n *\n * ### Syncing initial state from the server\n *\n * `Presence.syncState` is used to sync the list of presences on the server\n * with the client's state. An optional `onJoin` and `onLeave` callback can\n * be provided to react to changes in the client's local presences across\n * disconnects and reconnects with the server.\n *\n * `Presence.syncDiff` is used to sync a diff of presence join and leave\n * events from the server, as they happen. Like `syncState`, `syncDiff`\n * accepts optional `onJoin` and `onLeave` callbacks to react to a user\n * joining or leaving from a device.\n *\n * ### Listing Presences\n *\n * `Presence.list` is used to return a list of presence information\n * based on the local state of metadata. By default, all presence\n * metadata is returned, but a `listBy` function can be supplied to\n * allow the client to select which metadata to use for a given presence.\n * For example, you may have a user online from different devices with\n * a metadata status of \"online\", but they have set themselves to \"away\"\n * on another device. In this case, the app may choose to use the \"away\"\n * status for what appears on the UI. The example below defines a `listBy`\n * function which prioritizes the first metadata which was registered for\n * each user. This could be the first tab they opened, or the first device\n * they came online from:\n *\n * ```javascript\n *     let state = {}\n *     state = Presence.syncState(state, stateFromServer)\n *     let listBy = (id, {metas: [first, ...rest]}) => {\n *       first.count = rest.length + 1 // count of this user's presences\n *       first.id = id\n *       return first\n *     }\n *     let onlineUsers = Presence.list(state, listBy)\n * ```\n *\n *\n * ### Example Usage\n *```javascript\n *     // detect if user has joined for the 1st time or from another tab/device\n *     let onJoin = (id, current, newPres) => {\n *       if(!current){\n *         console.log(\"user has entered for the first time\", newPres)\n *       } else {\n *         console.log(\"user additional presence\", newPres)\n *       }\n *     }\n *     // detect if user has left from all tabs/devices, or is still present\n *     let onLeave = (id, current, leftPres) => {\n *       if(current.metas.length === 0){\n *         console.log(\"user has left from all devices\", leftPres)\n *       } else {\n *         console.log(\"user left from a device\", leftPres)\n *       }\n *     }\n *     let presences = {} // client's initial empty presence state\n *     // receive initial presence data from server, sent after join\n *     myChannel.on(\"presence_state\", state => {\n *       presences = Presence.syncState(presences, state, onJoin, onLeave)\n *       displayUsers(Presence.list(presences))\n *     })\n *     // receive \"presence_diff\" from server, containing join/leave events\n *     myChannel.on(\"presence_diff\", diff => {\n *       presences = Presence.syncDiff(presences, diff, onJoin, onLeave)\n *       this.setState({users: Presence.list(room.presences, listBy)})\n *     })\n * ```\n * @module phoenix\n */\n\nvar VSN = \"2.0.0\";\nvar SOCKET_STATES = { connecting: 0, open: 1, closing: 2, closed: 3 };\nvar DEFAULT_TIMEOUT = 10000;\nvar WS_CLOSE_NORMAL = 1000;\nvar CHANNEL_STATES = {\n  closed: \"closed\",\n  errored: \"errored\",\n  joined: \"joined\",\n  joining: \"joining\",\n  leaving: \"leaving\"\n};\nvar CHANNEL_EVENTS = {\n  close: \"phx_close\",\n  error: \"phx_error\",\n  join: \"phx_join\",\n  reply: \"phx_reply\",\n  leave: \"phx_leave\"\n};\nvar CHANNEL_LIFECYCLE_EVENTS = [CHANNEL_EVENTS.close, CHANNEL_EVENTS.error, CHANNEL_EVENTS.join, CHANNEL_EVENTS.reply, CHANNEL_EVENTS.leave];\nvar TRANSPORTS = {\n  longpoll: \"longpoll\",\n  websocket: \"websocket\"\n};\n\n/**\n * Initializes the Push\n * @param {Channel} channel - The Channel\n * @param {string} event - The event, for example `\"phx_join\"`\n * @param {Object} payload - The payload, for example `{user_id: 123}`\n * @param {number} timeout - The push timeout in milliseconds\n */\n\nvar Push = function () {\n  function Push(channel, event, payload, timeout) {\n    _classCallCheck(this, Push);\n\n    this.channel = channel;\n    this.event = event;\n    this.payload = payload || {};\n    this.receivedResp = null;\n    this.timeout = timeout;\n    this.timeoutTimer = null;\n    this.recHooks = [];\n    this.sent = false;\n  }\n\n  /**\n   *\n   * @param {number} timeout\n   */\n\n\n  _createClass(Push, [{\n    key: \"resend\",\n    value: function resend(timeout) {\n      this.timeout = timeout;\n      this.reset();\n      this.send();\n    }\n\n    /**\n     *\n     */\n\n  }, {\n    key: \"send\",\n    value: function send() {\n      if (this.hasReceived(\"timeout\")) {\n        return;\n      }\n      this.startTimeout();\n      this.sent = true;\n      this.channel.socket.push({\n        topic: this.channel.topic,\n        event: this.event,\n        payload: this.payload,\n        ref: this.ref,\n        join_ref: this.channel.joinRef()\n      });\n    }\n\n    /**\n     *\n     * @param {*} status\n     * @param {*} callback\n     */\n\n  }, {\n    key: \"receive\",\n    value: function receive(status, callback) {\n      if (this.hasReceived(status)) {\n        callback(this.receivedResp.response);\n      }\n\n      this.recHooks.push({ status: status, callback: callback });\n      return this;\n    }\n\n    // private\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.cancelRefEvent();\n      this.ref = null;\n      this.refEvent = null;\n      this.receivedResp = null;\n      this.sent = false;\n    }\n  }, {\n    key: \"matchReceive\",\n    value: function matchReceive(_ref) {\n      var status = _ref.status,\n          response = _ref.response,\n          ref = _ref.ref;\n\n      this.recHooks.filter(function (h) {\n        return h.status === status;\n      }).forEach(function (h) {\n        return h.callback(response);\n      });\n    }\n  }, {\n    key: \"cancelRefEvent\",\n    value: function cancelRefEvent() {\n      if (!this.refEvent) {\n        return;\n      }\n      this.channel.off(this.refEvent);\n    }\n  }, {\n    key: \"cancelTimeout\",\n    value: function cancelTimeout() {\n      clearTimeout(this.timeoutTimer);\n      this.timeoutTimer = null;\n    }\n  }, {\n    key: \"startTimeout\",\n    value: function startTimeout() {\n      var _this = this;\n\n      if (this.timeoutTimer) {\n        this.cancelTimeout();\n      }\n      this.ref = this.channel.socket.makeRef();\n      this.refEvent = this.channel.replyEventName(this.ref);\n\n      this.channel.on(this.refEvent, function (payload) {\n        _this.cancelRefEvent();\n        _this.cancelTimeout();\n        _this.receivedResp = payload;\n        _this.matchReceive(payload);\n      });\n\n      this.timeoutTimer = setTimeout(function () {\n        _this.trigger(\"timeout\", {});\n      }, this.timeout);\n    }\n  }, {\n    key: \"hasReceived\",\n    value: function hasReceived(status) {\n      return this.receivedResp && this.receivedResp.status === status;\n    }\n  }, {\n    key: \"trigger\",\n    value: function trigger(status, response) {\n      this.channel.trigger(this.refEvent, { status: status, response: response });\n    }\n  }]);\n\n  return Push;\n}();\n\n/**\n *\n * @param {string} topic\n * @param {Object} params\n * @param {Socket} socket\n */\n\n\nvar Channel = exports.Channel = function () {\n  function Channel(topic, params, socket) {\n    var _this2 = this;\n\n    _classCallCheck(this, Channel);\n\n    this.state = CHANNEL_STATES.closed;\n    this.topic = topic;\n    this.params = params || {};\n    this.socket = socket;\n    this.bindings = [];\n    this.timeout = this.socket.timeout;\n    this.joinedOnce = false;\n    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n    this.pushBuffer = [];\n    this.rejoinTimer = new Timer(function () {\n      return _this2.rejoinUntilConnected();\n    }, this.socket.reconnectAfterMs);\n    this.joinPush.receive(\"ok\", function () {\n      _this2.state = CHANNEL_STATES.joined;\n      _this2.rejoinTimer.reset();\n      _this2.pushBuffer.forEach(function (pushEvent) {\n        return pushEvent.send();\n      });\n      _this2.pushBuffer = [];\n    });\n    this.onClose(function () {\n      _this2.rejoinTimer.reset();\n      _this2.socket.log(\"channel\", \"close \" + _this2.topic + \" \" + _this2.joinRef());\n      _this2.state = CHANNEL_STATES.closed;\n      _this2.socket.remove(_this2);\n    });\n    this.onError(function (reason) {\n      if (_this2.isLeaving() || _this2.isClosed()) {\n        return;\n      }\n      _this2.socket.log(\"channel\", \"error \" + _this2.topic, reason);\n      _this2.state = CHANNEL_STATES.errored;\n      _this2.rejoinTimer.scheduleTimeout();\n    });\n    this.joinPush.receive(\"timeout\", function () {\n      if (!_this2.isJoining()) {\n        return;\n      }\n      _this2.socket.log(\"channel\", \"timeout \" + _this2.topic + \" (\" + _this2.joinRef() + \")\", _this2.joinPush.timeout);\n      var leavePush = new Push(_this2, CHANNEL_EVENTS.leave, {}, _this2.timeout);\n      leavePush.send();\n      _this2.state = CHANNEL_STATES.errored;\n      _this2.joinPush.reset();\n      _this2.rejoinTimer.scheduleTimeout();\n    });\n    this.on(CHANNEL_EVENTS.reply, function (payload, ref) {\n      _this2.trigger(_this2.replyEventName(ref), payload);\n    });\n  }\n\n  _createClass(Channel, [{\n    key: \"rejoinUntilConnected\",\n    value: function rejoinUntilConnected() {\n      this.rejoinTimer.scheduleTimeout();\n      if (this.socket.isConnected()) {\n        this.rejoin();\n      }\n    }\n  }, {\n    key: \"join\",\n    value: function join() {\n      var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n\n      if (this.joinedOnce) {\n        throw \"tried to join multiple times. 'join' can only be called a single time per channel instance\";\n      } else {\n        this.joinedOnce = true;\n        this.rejoin(timeout);\n        return this.joinPush;\n      }\n    }\n  }, {\n    key: \"onClose\",\n    value: function onClose(callback) {\n      this.on(CHANNEL_EVENTS.close, callback);\n    }\n  }, {\n    key: \"onError\",\n    value: function onError(callback) {\n      this.on(CHANNEL_EVENTS.error, function (reason) {\n        return callback(reason);\n      });\n    }\n  }, {\n    key: \"on\",\n    value: function on(event, callback) {\n      this.bindings.push({ event: event, callback: callback });\n    }\n  }, {\n    key: \"off\",\n    value: function off(event) {\n      this.bindings = this.bindings.filter(function (bind) {\n        return bind.event !== event;\n      });\n    }\n  }, {\n    key: \"canPush\",\n    value: function canPush() {\n      return this.socket.isConnected() && this.isJoined();\n    }\n  }, {\n    key: \"push\",\n    value: function push(event, payload) {\n      var timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.timeout;\n\n      if (!this.joinedOnce) {\n        throw \"tried to push '\" + event + \"' to '\" + this.topic + \"' before joining. Use channel.join() before pushing events\";\n      }\n      var pushEvent = new Push(this, event, payload, timeout);\n      if (this.canPush()) {\n        pushEvent.send();\n      } else {\n        pushEvent.startTimeout();\n        this.pushBuffer.push(pushEvent);\n      }\n\n      return pushEvent;\n    }\n\n    /** Leaves the channel\n     *\n     * Unsubscribes from server events, and\n     * instructs channel to terminate on server\n     *\n     * Triggers onClose() hooks\n     *\n     * To receive leave acknowledgements, use the a `receive`\n     * hook to bind to the server ack, ie:\n     *\n     * ```javascript\n     *     channel.leave().receive(\"ok\", () => alert(\"left!\") )\n     * ```\n     */\n\n  }, {\n    key: \"leave\",\n    value: function leave() {\n      var _this3 = this;\n\n      var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n\n      this.state = CHANNEL_STATES.leaving;\n      var onClose = function onClose() {\n        _this3.socket.log(\"channel\", \"leave \" + _this3.topic);\n        _this3.trigger(CHANNEL_EVENTS.close, \"leave\");\n      };\n      var leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);\n      leavePush.receive(\"ok\", function () {\n        return onClose();\n      }).receive(\"timeout\", function () {\n        return onClose();\n      });\n      leavePush.send();\n      if (!this.canPush()) {\n        leavePush.trigger(\"ok\", {});\n      }\n\n      return leavePush;\n    }\n\n    /**\n     * Overridable message hook\n     *\n     * Receives all events for specialized message handling\n     * before dispatching to the channel callbacks.\n     *\n     * Must return the payload, modified or unmodified\n     */\n\n  }, {\n    key: \"onMessage\",\n    value: function onMessage(event, payload, ref) {\n      return payload;\n    }\n\n    // private\n\n  }, {\n    key: \"isMember\",\n    value: function isMember(topic, event, payload, joinRef) {\n      if (this.topic !== topic) {\n        return false;\n      }\n      var isLifecycleEvent = CHANNEL_LIFECYCLE_EVENTS.indexOf(event) >= 0;\n\n      if (joinRef && isLifecycleEvent && joinRef !== this.joinRef()) {\n        this.socket.log(\"channel\", \"dropping outdated message\", { topic: topic, event: event, payload: payload, joinRef: joinRef });\n        return false;\n      } else {\n        return true;\n      }\n    }\n  }, {\n    key: \"joinRef\",\n    value: function joinRef() {\n      return this.joinPush.ref;\n    }\n  }, {\n    key: \"sendJoin\",\n    value: function sendJoin(timeout) {\n      this.state = CHANNEL_STATES.joining;\n      this.joinPush.resend(timeout);\n    }\n  }, {\n    key: \"rejoin\",\n    value: function rejoin() {\n      var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n      if (this.isLeaving()) {\n        return;\n      }\n      this.sendJoin(timeout);\n    }\n  }, {\n    key: \"trigger\",\n    value: function trigger(event, payload, ref, joinRef) {\n      var _this4 = this;\n\n      var handledPayload = this.onMessage(event, payload, ref, joinRef);\n      if (payload && !handledPayload) {\n        throw \"channel onMessage callbacks must return the payload, modified or unmodified\";\n      }\n\n      this.bindings.filter(function (bind) {\n        return bind.event === event;\n      }).map(function (bind) {\n        return bind.callback(handledPayload, ref, joinRef || _this4.joinRef());\n      });\n    }\n  }, {\n    key: \"replyEventName\",\n    value: function replyEventName(ref) {\n      return \"chan_reply_\" + ref;\n    }\n  }, {\n    key: \"isClosed\",\n    value: function isClosed() {\n      return this.state === CHANNEL_STATES.closed;\n    }\n  }, {\n    key: \"isErrored\",\n    value: function isErrored() {\n      return this.state === CHANNEL_STATES.errored;\n    }\n  }, {\n    key: \"isJoined\",\n    value: function isJoined() {\n      return this.state === CHANNEL_STATES.joined;\n    }\n  }, {\n    key: \"isJoining\",\n    value: function isJoining() {\n      return this.state === CHANNEL_STATES.joining;\n    }\n  }, {\n    key: \"isLeaving\",\n    value: function isLeaving() {\n      return this.state === CHANNEL_STATES.leaving;\n    }\n  }]);\n\n  return Channel;\n}();\n\nvar Serializer = {\n  encode: function encode(msg, callback) {\n    var payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload];\n    return callback(JSON.stringify(payload));\n  },\n  decode: function decode(rawPayload, callback) {\n    var _JSON$parse = JSON.parse(rawPayload),\n        _JSON$parse2 = _slicedToArray(_JSON$parse, 5),\n        join_ref = _JSON$parse2[0],\n        ref = _JSON$parse2[1],\n        topic = _JSON$parse2[2],\n        event = _JSON$parse2[3],\n        payload = _JSON$parse2[4];\n\n    return callback({ join_ref: join_ref, ref: ref, topic: topic, event: event, payload: payload });\n  }\n};\n\n/** Initializes the Socket\n *\n *\n * For IE8 support use an ES5-shim (https://github.com/es-shims/es5-shim)\n *\n * @param {string} endPoint - The string WebSocket endpoint, ie, `\"ws://example.com/socket\"`,\n *                                               `\"wss://example.com\"`\n *                                               `\"/socket\"` (inherited host & protocol)\n * @param {Object} opts - Optional configuration\n * @param {string} opts.transport - The Websocket Transport, for example WebSocket or Phoenix.LongPoll.\n *\n * Defaults to WebSocket with automatic LongPoll fallback.\n * @param {Function} opts.encode - The function to encode outgoing messages.\n *\n * Defaults to JSON:\n *\n * ```javascript\n * (payload, callback) => callback(JSON.stringify(payload))\n * ```\n *\n * @param {Function} opts.decode - The function to decode incoming messages.\n *\n * Defaults to JSON:\n *\n * ```javascript\n * (payload, callback) => callback(JSON.parse(payload))\n * ```\n *\n * @param {number} opts.timeout - The default timeout in milliseconds to trigger push timeouts.\n *\n * Defaults `DEFAULT_TIMEOUT`\n * @param {number} opts.heartbeatIntervalMs - The millisec interval to send a heartbeat message\n * @param {number} opts.reconnectAfterMs - The optional function that returns the millsec reconnect interval.\n *\n * Defaults to stepped backoff of:\n *\n * ```javascript\n *  function(tries){\n *    return [1000, 5000, 10000][tries - 1] || 10000\n *  }\n * ```\n * @param {Function} opts.logger - The optional function for specialized logging, ie:\n * ```javascript\n * logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n * ```\n *\n * @param {number}  opts.longpollerTimeout - The maximum timeout of a long poll AJAX request.\n *\n * Defaults to 20s (double the server long poll timer).\n *\n * @param {Object}  opts.params - The optional params to pass when connecting\n *\n *\n*/\n\nvar Socket = exports.Socket = function () {\n  function Socket(endPoint) {\n    var _this5 = this;\n\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Socket);\n\n    this.stateChangeCallbacks = { open: [], close: [], error: [], message: [] };\n    this.channels = [];\n    this.sendBuffer = [];\n    this.ref = 0;\n    this.timeout = opts.timeout || DEFAULT_TIMEOUT;\n    this.transport = opts.transport || window.WebSocket || LongPoll;\n    this.defaultEncoder = Serializer.encode;\n    this.defaultDecoder = Serializer.decode;\n    if (this.transport !== LongPoll) {\n      this.encode = opts.encode || this.defaultEncoder;\n      this.decode = opts.decode || this.defaultDecoder;\n    } else {\n      this.encode = this.defaultEncoder;\n      this.decode = this.defaultDecoder;\n    }\n    this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 30000;\n    this.reconnectAfterMs = opts.reconnectAfterMs || function (tries) {\n      return [1000, 2000, 5000, 10000][tries - 1] || 10000;\n    };\n    this.logger = opts.logger || function () {}; // noop\n    this.longpollerTimeout = opts.longpollerTimeout || 20000;\n    this.params = opts.params || {};\n    this.endPoint = endPoint + \"/\" + TRANSPORTS.websocket;\n    this.heartbeatTimer = null;\n    this.pendingHeartbeatRef = null;\n    this.reconnectTimer = new Timer(function () {\n      _this5.disconnect(function () {\n        return _this5.connect();\n      });\n    }, this.reconnectAfterMs);\n  }\n\n  _createClass(Socket, [{\n    key: \"protocol\",\n    value: function protocol() {\n      return location.protocol.match(/^https/) ? \"wss\" : \"ws\";\n    }\n  }, {\n    key: \"endPointURL\",\n    value: function endPointURL() {\n      var uri = Ajax.appendParams(Ajax.appendParams(this.endPoint, this.params), { vsn: VSN });\n      if (uri.charAt(0) !== \"/\") {\n        return uri;\n      }\n      if (uri.charAt(1) === \"/\") {\n        return this.protocol() + \":\" + uri;\n      }\n\n      return this.protocol() + \"://\" + location.host + uri;\n    }\n  }, {\n    key: \"disconnect\",\n    value: function disconnect(callback, code, reason) {\n      if (this.conn) {\n        this.conn.onclose = function () {}; // noop\n        if (code) {\n          this.conn.close(code, reason || \"\");\n        } else {\n          this.conn.close();\n        }\n        this.conn = null;\n      }\n      callback && callback();\n    }\n\n    /**\n     *\n     * @param {Object} params - The params to send when connecting, for example `{user_id: userToken}`\n     */\n\n  }, {\n    key: \"connect\",\n    value: function connect(params) {\n      var _this6 = this;\n\n      if (params) {\n        console && console.log(\"passing params to connect is deprecated. Instead pass :params to the Socket constructor\");\n        this.params = params;\n      }\n      if (this.conn) {\n        return;\n      }\n\n      this.conn = new this.transport(this.endPointURL());\n      this.conn.timeout = this.longpollerTimeout;\n      this.conn.onopen = function () {\n        return _this6.onConnOpen();\n      };\n      this.conn.onerror = function (error) {\n        return _this6.onConnError(error);\n      };\n      this.conn.onmessage = function (event) {\n        return _this6.onConnMessage(event);\n      };\n      this.conn.onclose = function (event) {\n        return _this6.onConnClose(event);\n      };\n    }\n\n    /**\n     * Logs the message. Override `this.logger` for specialized logging. noops by default\n     * @param {string} kind\n     * @param {string} msg\n     * @param {Object} data\n     */\n\n  }, {\n    key: \"log\",\n    value: function log(kind, msg, data) {\n      this.logger(kind, msg, data);\n    }\n\n    // Registers callbacks for connection state change events\n    //\n    // Examples\n    //\n    //    socket.onError(function(error){ alert(\"An error occurred\") })\n    //\n\n  }, {\n    key: \"onOpen\",\n    value: function onOpen(callback) {\n      this.stateChangeCallbacks.open.push(callback);\n    }\n  }, {\n    key: \"onClose\",\n    value: function onClose(callback) {\n      this.stateChangeCallbacks.close.push(callback);\n    }\n  }, {\n    key: \"onError\",\n    value: function onError(callback) {\n      this.stateChangeCallbacks.error.push(callback);\n    }\n  }, {\n    key: \"onMessage\",\n    value: function onMessage(callback) {\n      this.stateChangeCallbacks.message.push(callback);\n    }\n  }, {\n    key: \"onConnOpen\",\n    value: function onConnOpen() {\n      var _this7 = this;\n\n      this.log(\"transport\", \"connected to \" + this.endPointURL());\n      this.flushSendBuffer();\n      this.reconnectTimer.reset();\n      if (!this.conn.skipHeartbeat) {\n        clearInterval(this.heartbeatTimer);\n        this.heartbeatTimer = setInterval(function () {\n          return _this7.sendHeartbeat();\n        }, this.heartbeatIntervalMs);\n      }\n      this.stateChangeCallbacks.open.forEach(function (callback) {\n        return callback();\n      });\n    }\n  }, {\n    key: \"onConnClose\",\n    value: function onConnClose(event) {\n      this.log(\"transport\", \"close\", event);\n      this.triggerChanError();\n      clearInterval(this.heartbeatTimer);\n      this.reconnectTimer.scheduleTimeout();\n      this.stateChangeCallbacks.close.forEach(function (callback) {\n        return callback(event);\n      });\n    }\n  }, {\n    key: \"onConnError\",\n    value: function onConnError(error) {\n      this.log(\"transport\", error);\n      this.triggerChanError();\n      this.stateChangeCallbacks.error.forEach(function (callback) {\n        return callback(error);\n      });\n    }\n  }, {\n    key: \"triggerChanError\",\n    value: function triggerChanError() {\n      this.channels.forEach(function (channel) {\n        return channel.trigger(CHANNEL_EVENTS.error);\n      });\n    }\n  }, {\n    key: \"connectionState\",\n    value: function connectionState() {\n      switch (this.conn && this.conn.readyState) {\n        case SOCKET_STATES.connecting:\n          return \"connecting\";\n        case SOCKET_STATES.open:\n          return \"open\";\n        case SOCKET_STATES.closing:\n          return \"closing\";\n        default:\n          return \"closed\";\n      }\n    }\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      return this.connectionState() === \"open\";\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(channel) {\n      this.channels = this.channels.filter(function (c) {\n        return c.joinRef() !== channel.joinRef();\n      });\n    }\n  }, {\n    key: \"channel\",\n    value: function channel(topic) {\n      var chanParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var chan = new Channel(topic, chanParams, this);\n      this.channels.push(chan);\n      return chan;\n    }\n  }, {\n    key: \"push\",\n    value: function push(data) {\n      var _this8 = this;\n\n      var topic = data.topic,\n          event = data.event,\n          payload = data.payload,\n          ref = data.ref,\n          join_ref = data.join_ref;\n\n      var callback = function callback() {\n        _this8.encode(data, function (result) {\n          _this8.conn.send(result);\n        });\n      };\n      this.log(\"push\", topic + \" \" + event + \" (\" + join_ref + \", \" + ref + \")\", payload);\n      if (this.isConnected()) {\n        callback();\n      } else {\n        this.sendBuffer.push(callback);\n      }\n    }\n\n    /**\n     * Return the next message ref, accounting for overflows\n     */\n\n  }, {\n    key: \"makeRef\",\n    value: function makeRef() {\n      var newRef = this.ref + 1;\n      if (newRef === this.ref) {\n        this.ref = 0;\n      } else {\n        this.ref = newRef;\n      }\n\n      return this.ref.toString();\n    }\n  }, {\n    key: \"sendHeartbeat\",\n    value: function sendHeartbeat() {\n      if (!this.isConnected()) {\n        return;\n      }\n      if (this.pendingHeartbeatRef) {\n        this.pendingHeartbeatRef = null;\n        this.log(\"transport\", \"heartbeat timeout. Attempting to re-establish connection\");\n        this.conn.close(WS_CLOSE_NORMAL, \"hearbeat timeout\");\n        return;\n      }\n      this.pendingHeartbeatRef = this.makeRef();\n      this.push({ topic: \"phoenix\", event: \"heartbeat\", payload: {}, ref: this.pendingHeartbeatRef });\n    }\n  }, {\n    key: \"flushSendBuffer\",\n    value: function flushSendBuffer() {\n      if (this.isConnected() && this.sendBuffer.length > 0) {\n        this.sendBuffer.forEach(function (callback) {\n          return callback();\n        });\n        this.sendBuffer = [];\n      }\n    }\n  }, {\n    key: \"onConnMessage\",\n    value: function onConnMessage(rawMessage) {\n      var _this9 = this;\n\n      this.decode(rawMessage.data, function (msg) {\n        var topic = msg.topic,\n            event = msg.event,\n            payload = msg.payload,\n            ref = msg.ref,\n            join_ref = msg.join_ref;\n\n        if (ref && ref === _this9.pendingHeartbeatRef) {\n          _this9.pendingHeartbeatRef = null;\n        }\n\n        _this9.log(\"receive\", (payload.status || \"\") + \" \" + topic + \" \" + event + \" \" + (ref && \"(\" + ref + \")\" || \"\"), payload);\n        _this9.channels.filter(function (channel) {\n          return channel.isMember(topic, event, payload, join_ref);\n        }).forEach(function (channel) {\n          return channel.trigger(event, payload, ref, join_ref);\n        });\n        _this9.stateChangeCallbacks.message.forEach(function (callback) {\n          return callback(msg);\n        });\n      });\n    }\n  }]);\n\n  return Socket;\n}();\n\nvar LongPoll = exports.LongPoll = function () {\n  function LongPoll(endPoint) {\n    _classCallCheck(this, LongPoll);\n\n    this.endPoint = null;\n    this.token = null;\n    this.skipHeartbeat = true;\n    this.onopen = function () {}; // noop\n    this.onerror = function () {}; // noop\n    this.onmessage = function () {}; // noop\n    this.onclose = function () {}; // noop\n    this.pollEndpoint = this.normalizeEndpoint(endPoint);\n    this.readyState = SOCKET_STATES.connecting;\n\n    this.poll();\n  }\n\n  _createClass(LongPoll, [{\n    key: \"normalizeEndpoint\",\n    value: function normalizeEndpoint(endPoint) {\n      return endPoint.replace(\"ws://\", \"http://\").replace(\"wss://\", \"https://\").replace(new RegExp(\"(.*)\\/\" + TRANSPORTS.websocket), \"$1/\" + TRANSPORTS.longpoll);\n    }\n  }, {\n    key: \"endpointURL\",\n    value: function endpointURL() {\n      return Ajax.appendParams(this.pollEndpoint, { token: this.token });\n    }\n  }, {\n    key: \"closeAndRetry\",\n    value: function closeAndRetry() {\n      this.close();\n      this.readyState = SOCKET_STATES.connecting;\n    }\n  }, {\n    key: \"ontimeout\",\n    value: function ontimeout() {\n      this.onerror(\"timeout\");\n      this.closeAndRetry();\n    }\n  }, {\n    key: \"poll\",\n    value: function poll() {\n      var _this10 = this;\n\n      if (!(this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting)) {\n        return;\n      }\n\n      Ajax.request(\"GET\", this.endpointURL(), \"application/json\", null, this.timeout, this.ontimeout.bind(this), function (resp) {\n        if (resp) {\n          var status = resp.status,\n              token = resp.token,\n              messages = resp.messages;\n\n          _this10.token = token;\n        } else {\n          var status = 0;\n        }\n\n        switch (status) {\n          case 200:\n            messages.forEach(function (msg) {\n              return _this10.onmessage({ data: msg });\n            });\n            _this10.poll();\n            break;\n          case 204:\n            _this10.poll();\n            break;\n          case 410:\n            _this10.readyState = SOCKET_STATES.open;\n            _this10.onopen();\n            _this10.poll();\n            break;\n          case 0:\n          case 500:\n            _this10.onerror();\n            _this10.closeAndRetry();\n            break;\n          default:\n            throw \"unhandled poll status \" + status;\n        }\n      });\n    }\n  }, {\n    key: \"send\",\n    value: function send(body) {\n      var _this11 = this;\n\n      Ajax.request(\"POST\", this.endpointURL(), \"application/json\", body, this.timeout, this.onerror.bind(this, \"timeout\"), function (resp) {\n        if (!resp || resp.status !== 200) {\n          _this11.onerror(resp && resp.status);\n          _this11.closeAndRetry();\n        }\n      });\n    }\n  }, {\n    key: \"close\",\n    value: function close(code, reason) {\n      this.readyState = SOCKET_STATES.closed;\n      this.onclose();\n    }\n  }]);\n\n  return LongPoll;\n}();\n\nvar Ajax = exports.Ajax = function () {\n  function Ajax() {\n    _classCallCheck(this, Ajax);\n  }\n\n  _createClass(Ajax, null, [{\n    key: \"request\",\n    value: function request(method, endPoint, accept, body, timeout, ontimeout, callback) {\n      if (window.XDomainRequest) {\n        var req = new XDomainRequest(); // IE8, IE9\n        this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback);\n      } else {\n        var _req = window.XMLHttpRequest ? new window.XMLHttpRequest() : // IE7+, Firefox, Chrome, Opera, Safari\n        new ActiveXObject(\"Microsoft.XMLHTTP\"); // IE6, IE5\n        this.xhrRequest(_req, method, endPoint, accept, body, timeout, ontimeout, callback);\n      }\n    }\n  }, {\n    key: \"xdomainRequest\",\n    value: function xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback) {\n      var _this12 = this;\n\n      req.timeout = timeout;\n      req.open(method, endPoint);\n      req.onload = function () {\n        var response = _this12.parseJSON(req.responseText);\n        callback && callback(response);\n      };\n      if (ontimeout) {\n        req.ontimeout = ontimeout;\n      }\n\n      // Work around bug in IE9 that requires an attached onprogress handler\n      req.onprogress = function () {};\n\n      req.send(body);\n    }\n  }, {\n    key: \"xhrRequest\",\n    value: function xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback) {\n      var _this13 = this;\n\n      req.open(method, endPoint, true);\n      req.timeout = timeout;\n      req.setRequestHeader(\"Content-Type\", accept);\n      req.onerror = function () {\n        callback && callback(null);\n      };\n      req.onreadystatechange = function () {\n        if (req.readyState === _this13.states.complete && callback) {\n          var response = _this13.parseJSON(req.responseText);\n          callback(response);\n        }\n      };\n      if (ontimeout) {\n        req.ontimeout = ontimeout;\n      }\n\n      req.send(body);\n    }\n  }, {\n    key: \"parseJSON\",\n    value: function parseJSON(resp) {\n      if (!resp || resp === \"\") {\n        return null;\n      }\n\n      try {\n        return JSON.parse(resp);\n      } catch (e) {\n        console && console.log(\"failed to parse JSON response\", resp);\n        return null;\n      }\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize(obj, parentKey) {\n      var queryStr = [];\n      for (var key in obj) {\n        if (!obj.hasOwnProperty(key)) {\n          continue;\n        }\n        var paramKey = parentKey ? parentKey + \"[\" + key + \"]\" : key;\n        var paramVal = obj[key];\n        if ((typeof paramVal === \"undefined\" ? \"undefined\" : _typeof(paramVal)) === \"object\") {\n          queryStr.push(this.serialize(paramVal, paramKey));\n        } else {\n          queryStr.push(encodeURIComponent(paramKey) + \"=\" + encodeURIComponent(paramVal));\n        }\n      }\n      return queryStr.join(\"&\");\n    }\n  }, {\n    key: \"appendParams\",\n    value: function appendParams(url, params) {\n      if (Object.keys(params).length === 0) {\n        return url;\n      }\n\n      var prefix = url.match(/\\?/) ? \"&\" : \"?\";\n      return \"\" + url + prefix + this.serialize(params);\n    }\n  }]);\n\n  return Ajax;\n}();\n\nAjax.states = { complete: 4 };\n\nvar Presence = exports.Presence = {\n  syncState: function syncState(currentState, newState, onJoin, onLeave) {\n    var _this14 = this;\n\n    var state = this.clone(currentState);\n    var joins = {};\n    var leaves = {};\n\n    this.map(state, function (key, presence) {\n      if (!newState[key]) {\n        leaves[key] = presence;\n      }\n    });\n    this.map(newState, function (key, newPresence) {\n      var currentPresence = state[key];\n      if (currentPresence) {\n        var newRefs = newPresence.metas.map(function (m) {\n          return m.phx_ref;\n        });\n        var curRefs = currentPresence.metas.map(function (m) {\n          return m.phx_ref;\n        });\n        var joinedMetas = newPresence.metas.filter(function (m) {\n          return curRefs.indexOf(m.phx_ref) < 0;\n        });\n        var leftMetas = currentPresence.metas.filter(function (m) {\n          return newRefs.indexOf(m.phx_ref) < 0;\n        });\n        if (joinedMetas.length > 0) {\n          joins[key] = newPresence;\n          joins[key].metas = joinedMetas;\n        }\n        if (leftMetas.length > 0) {\n          leaves[key] = _this14.clone(currentPresence);\n          leaves[key].metas = leftMetas;\n        }\n      } else {\n        joins[key] = newPresence;\n      }\n    });\n    return this.syncDiff(state, { joins: joins, leaves: leaves }, onJoin, onLeave);\n  },\n  syncDiff: function syncDiff(currentState, _ref2, onJoin, onLeave) {\n    var joins = _ref2.joins,\n        leaves = _ref2.leaves;\n\n    var state = this.clone(currentState);\n    if (!onJoin) {\n      onJoin = function onJoin() {};\n    }\n    if (!onLeave) {\n      onLeave = function onLeave() {};\n    }\n\n    this.map(joins, function (key, newPresence) {\n      var currentPresence = state[key];\n      state[key] = newPresence;\n      if (currentPresence) {\n        var _state$key$metas;\n\n        (_state$key$metas = state[key].metas).unshift.apply(_state$key$metas, _toConsumableArray(currentPresence.metas));\n      }\n      onJoin(key, currentPresence, newPresence);\n    });\n    this.map(leaves, function (key, leftPresence) {\n      var currentPresence = state[key];\n      if (!currentPresence) {\n        return;\n      }\n      var refsToRemove = leftPresence.metas.map(function (m) {\n        return m.phx_ref;\n      });\n      currentPresence.metas = currentPresence.metas.filter(function (p) {\n        return refsToRemove.indexOf(p.phx_ref) < 0;\n      });\n      onLeave(key, currentPresence, leftPresence);\n      if (currentPresence.metas.length === 0) {\n        delete state[key];\n      }\n    });\n    return state;\n  },\n  list: function list(presences, chooser) {\n    if (!chooser) {\n      chooser = function chooser(key, pres) {\n        return pres;\n      };\n    }\n\n    return this.map(presences, function (key, presence) {\n      return chooser(key, presence);\n    });\n  },\n\n\n  // private\n\n  map: function map(obj, func) {\n    return Object.getOwnPropertyNames(obj).map(function (key) {\n      return func(key, obj[key]);\n    });\n  },\n  clone: function clone(obj) {\n    return JSON.parse(JSON.stringify(obj));\n  }\n};\n\n/**\n *\n * Creates a timer that accepts a `timerCalc` function to perform\n * calculated timeout retries, such as exponential backoff.\n *\n * ## Examples\n *\n * ```javascript\n *    let reconnectTimer = new Timer(() => this.connect(), function(tries){\n *      return [1000, 5000, 10000][tries - 1] || 10000\n *    })\n *    reconnectTimer.scheduleTimeout() // fires after 1000\n *    reconnectTimer.scheduleTimeout() // fires after 5000\n *    reconnectTimer.reset()\n *    reconnectTimer.scheduleTimeout() // fires after 1000\n * ```\n * @param {Function} callback\n * @param {Function} timerCalc\n */\n\nvar Timer = function () {\n  function Timer(callback, timerCalc) {\n    _classCallCheck(this, Timer);\n\n    this.callback = callback;\n    this.timerCalc = timerCalc;\n    this.timer = null;\n    this.tries = 0;\n  }\n\n  _createClass(Timer, [{\n    key: \"reset\",\n    value: function reset() {\n      this.tries = 0;\n      clearTimeout(this.timer);\n    }\n\n    /**\n     * Cancels any previous scheduleTimeout and schedules callback\n     */\n\n  }, {\n    key: \"scheduleTimeout\",\n    value: function scheduleTimeout() {\n      var _this15 = this;\n\n      clearTimeout(this.timer);\n\n      this.timer = setTimeout(function () {\n        _this15.tries = _this15.tries + 1;\n        _this15.callback();\n      }, this.timerCalc(this.tries + 1));\n    }\n  }]);\n\n  return Timer;\n}();\n\n})));\n  })();\n});","\nrequire.register(\"phoenix_html/priv/static/phoenix_html.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"phoenix_html\");\n  (function() {\n    \"use strict\";\n\n(function() {\n  function buildHiddenInput(name, value) {\n    var input = document.createElement(\"input\");\n    input.type = \"hidden\";\n    input.name = name;\n    input.value = value;\n    return input;\n  }\n\n  function handleLinkClick(link) {\n    var message = link.getAttribute(\"data-confirm\");\n    if(message && !window.confirm(message)) {\n        return;\n    }\n\n    var to = link.getAttribute(\"data-to\"),\n        method = buildHiddenInput(\"_method\", link.getAttribute(\"data-method\")),\n        csrf = buildHiddenInput(\"_csrf_token\", link.getAttribute(\"data-csrf\")),\n        form = document.createElement(\"form\");\n\n    form.method = (link.getAttribute(\"data-method\") === \"get\") ? \"get\" : \"post\";\n    form.action = to;\n    form.style.display = \"hidden\";\n\n    form.appendChild(csrf);\n    form.appendChild(method);\n    document.body.appendChild(form);\n    form.submit();\n  }\n\n  window.addEventListener(\"click\", function(e) {\n    var element = e.target;\n\n    while (element && element.getAttribute) {\n      if(element.getAttribute(\"data-method\")) {\n        handleLinkClick(element);\n        e.preventDefault();\n        return false;\n      } else {\n        element = element.parentNode;\n      }\n    }\n  }, false);\n})();\n  })();\n});","\nrequire.register(\"process/browser.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"process\");\n  (function() {\n    // shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n  })();\n});","'use strict';\n\nvar mouseX = 0,\n    mouseY = 0,\n    windowHalfX = window.innerWidth / 2,\n    windowHalfY = window.innerHeight / 2,\n    SEPARATION = 1200,\n    AMOUNTX = 1,\n    AMOUNTY = 1,\n    camera,\n    scene,\n    renderer;\n\ninit();\nanimate();\n\nfunction init() {\n\n  /*\n   *   Define variables\n   */\n  var container,\n      separation = 1000,\n      amountX = 50,\n      amountY = 50,\n      color = 0xffffff,\n      particles,\n      particle;\n\n  container = document.getElementById(\"canvas\");\n\n  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);\n  camera.position.z = 100;\n\n  scene = new THREE.Scene();\n\n  renderer = new THREE.CanvasRenderer({ alpha: true });\n  renderer.setPixelRatio(window.devicePixelRatio);\n  renderer.setClearColor(0x000000, 0); // canvas background color\n  renderer.setSize(window.innerWidth, window.innerHeight);\n  container.appendChild(renderer.domElement);\n\n  var PI2 = Math.PI * 2;\n  var material = new THREE.SpriteCanvasMaterial({\n\n    color: color,\n    opacity: 0.5,\n    program: function program(context) {\n\n      context.beginPath();\n      context.arc(0, 0, 0.5, 0, PI2, true);\n      context.fill();\n    }\n\n  });\n\n  var geometry = new THREE.Geometry();\n\n  /*\n   *   Number of particles\n   */\n  for (var i = 0; i < 150; i++) {\n\n    particle = new THREE.Sprite(material);\n    particle.position.x = Math.random() * 2 - 1;\n    particle.position.y = Math.random() * 2 - 1;\n    particle.position.z = Math.random() * 2 - 1;\n    particle.position.normalize();\n    particle.position.multiplyScalar(Math.random() * 10 + 600);\n    particle.scale.x = particle.scale.y = 5;\n\n    scene.add(particle);\n\n    geometry.vertices.push(particle.position);\n  }\n\n  /*\n   *   Lines\n   */\n\n  var line = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: color, opacity: 0.2 }));\n  scene.add(line);\n\n  document.addEventListener('mousemove', onDocumentMouseMove, false);\n  document.addEventListener('touchstart', onDocumentTouchStart, false);\n  document.addEventListener('touchmove', onDocumentTouchMove, false);\n\n  //\n\n  window.addEventListener('resize', onWindowResize, false);\n}\n\nfunction onWindowResize() {\n\n  windowHalfX = window.innerWidth / 2;\n  windowHalfY = window.innerHeight / 2;\n\n  camera.aspect = window.innerWidth / window.innerHeight;\n  camera.updateProjectionMatrix();\n\n  renderer.setSize(window.innerWidth, window.innerHeight);\n}\n\n//\n\nfunction onDocumentMouseMove(event) {\n\n  mouseX = (event.clientX - windowHalfX) * 0.05;\n  mouseY = (event.clientY - windowHalfY) * 0.2;\n}\n\nfunction onDocumentTouchStart(event) {\n\n  if (event.touches.length > 1) {\n\n    event.preventDefault();\n\n    mouseX = (event.touches[0].pageX - windowHalfX) * 0.7;\n    mouseY = (event.touches[0].pageY - windowHalfY) * 0.7;\n  }\n}\n\nfunction onDocumentTouchMove(event) {\n\n  if (event.touches.length == 1) {\n\n    event.preventDefault();\n\n    mouseX = event.touches[0].pageX - windowHalfX;\n    mouseY = event.touches[0].pageY - windowHalfY;\n  }\n}\n\n//\n\nfunction animate() {\n\n  requestAnimationFrame(animate);\n\n  render();\n}\n\nfunction render() {\n\n  camera.position.x += (mouseX - camera.position.x) * 0.1;\n  camera.position.y += (-mouseY + 200 - camera.position.y) * 0.05;\n  camera.lookAt(scene.position);\n\n  renderer.render(scene, camera);\n}\n","\"use strict\";\n\nrequire(\"phoenix_html\");\n\nrequire(\"jquery\");\n\nvar CarenFitbitClient = {\n\n  init: function init() {\n    CarenFitbitClient.showPage();\n  },\n\n  showPage: function showPage() {\n    $('.wrapper').addClass('show');\n  }\n};\n\n$(window).ready(CarenFitbitClient.init);\n","'use strict';\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.SpriteCanvasMaterial = function (parameters) {\n\n\tTHREE.Material.call(this);\n\n\tthis.type = 'SpriteCanvasMaterial';\n\n\tthis.color = new THREE.Color(0xffffff);\n\tthis.program = function (context, color) {};\n\n\tthis.setValues(parameters);\n};\n\nTHREE.SpriteCanvasMaterial.prototype = Object.create(THREE.Material.prototype);\nTHREE.SpriteCanvasMaterial.prototype.constructor = THREE.SpriteCanvasMaterial;\n\nTHREE.SpriteCanvasMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.SpriteCanvasMaterial();\n\n\tTHREE.Material.prototype.clone.call(this, material);\n\n\tmaterial.color.copy(this.color);\n\tmaterial.program = this.program;\n\n\treturn material;\n};\n\n//\n\nTHREE.CanvasRenderer = function (parameters) {\n\n\tconsole.log('THREE.CanvasRenderer', THREE.REVISION);\n\n\tvar smoothstep = THREE.Math.smoothstep;\n\n\tparameters = parameters || {};\n\n\tvar _this = this,\n\t    _renderData,\n\t    _elements,\n\t    _lights,\n\t    _projector = new THREE.Projector(),\n\t    _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement('canvas'),\n\t    _canvasWidth = _canvas.width,\n\t    _canvasHeight = _canvas.height,\n\t    _canvasWidthHalf = Math.floor(_canvasWidth / 2),\n\t    _canvasHeightHalf = Math.floor(_canvasHeight / 2),\n\t    _viewportX = 0,\n\t    _viewportY = 0,\n\t    _viewportWidth = _canvasWidth,\n\t    _viewportHeight = _canvasHeight,\n\t    pixelRatio = 1,\n\t    _context = _canvas.getContext('2d', {\n\t\talpha: parameters.alpha === true\n\t}),\n\t    _clearColor = new THREE.Color(0x000000),\n\t    _clearAlpha = parameters.alpha === true ? 0 : 1,\n\t    _contextGlobalAlpha = 1,\n\t    _contextGlobalCompositeOperation = 0,\n\t    _contextStrokeStyle = null,\n\t    _contextFillStyle = null,\n\t    _contextLineWidth = null,\n\t    _contextLineCap = null,\n\t    _contextLineJoin = null,\n\t    _contextLineDash = [],\n\t    _camera,\n\t    _v1,\n\t    _v2,\n\t    _v3,\n\t    _v4,\n\t    _v5 = new THREE.RenderableVertex(),\n\t    _v6 = new THREE.RenderableVertex(),\n\t    _v1x,\n\t    _v1y,\n\t    _v2x,\n\t    _v2y,\n\t    _v3x,\n\t    _v3y,\n\t    _v4x,\n\t    _v4y,\n\t    _v5x,\n\t    _v5y,\n\t    _v6x,\n\t    _v6y,\n\t    _color = new THREE.Color(),\n\t    _color1 = new THREE.Color(),\n\t    _color2 = new THREE.Color(),\n\t    _color3 = new THREE.Color(),\n\t    _color4 = new THREE.Color(),\n\t    _diffuseColor = new THREE.Color(),\n\t    _emissiveColor = new THREE.Color(),\n\t    _lightColor = new THREE.Color(),\n\t    _patterns = {},\n\t    _image,\n\t    _uvs,\n\t    _uv1x,\n\t    _uv1y,\n\t    _uv2x,\n\t    _uv2y,\n\t    _uv3x,\n\t    _uv3y,\n\t    _clipBox = new THREE.Box2(),\n\t    _clearBox = new THREE.Box2(),\n\t    _elemBox = new THREE.Box2(),\n\t    _ambientLight = new THREE.Color(),\n\t    _directionalLights = new THREE.Color(),\n\t    _pointLights = new THREE.Color(),\n\t    _vector3 = new THREE.Vector3(),\n\t    // Needed for PointLight\n\t_centroid = new THREE.Vector3(),\n\t    _normal = new THREE.Vector3(),\n\t    _normalViewMatrix = new THREE.Matrix3();\n\n\t// dash+gap fallbacks for Firefox and everything else\n\n\tif (_context.setLineDash === undefined) {\n\n\t\t_context.setLineDash = function () {};\n\t}\n\n\tthis.domElement = _canvas;\n\n\tthis.autoClear = true;\n\tthis.sortObjects = true;\n\tthis.sortElements = true;\n\n\tthis.info = {\n\n\t\trender: {\n\n\t\t\tvertices: 0,\n\t\t\tfaces: 0\n\n\t\t}\n\n\t\t// WebGLRenderer compatibility\n\n\t};this.supportsVertexTextures = function () {};\n\tthis.setFaceCulling = function () {};\n\n\t//\n\n\tthis.getPixelRatio = function () {\n\n\t\treturn pixelRatio;\n\t};\n\n\tthis.setPixelRatio = function (value) {\n\n\t\tpixelRatio = value;\n\t};\n\n\tthis.setSize = function (width, height, updateStyle) {\n\n\t\t_canvasWidth = width * pixelRatio;\n\t\t_canvasHeight = height * pixelRatio;\n\n\t\t_canvas.width = _canvasWidth;\n\t\t_canvas.height = _canvasHeight;\n\n\t\t_canvasWidthHalf = Math.floor(_canvasWidth / 2);\n\t\t_canvasHeightHalf = Math.floor(_canvasHeight / 2);\n\n\t\tif (updateStyle !== false) {\n\n\t\t\t_canvas.style.width = width + 'px';\n\t\t\t_canvas.style.height = height + 'px';\n\t\t}\n\n\t\t_clipBox.min.set(-_canvasWidthHalf, -_canvasHeightHalf), _clipBox.max.set(_canvasWidthHalf, _canvasHeightHalf);\n\n\t\t_clearBox.min.set(-_canvasWidthHalf, -_canvasHeightHalf);\n\t\t_clearBox.max.set(_canvasWidthHalf, _canvasHeightHalf);\n\n\t\t_contextGlobalAlpha = 1;\n\t\t_contextGlobalCompositeOperation = 0;\n\t\t_contextStrokeStyle = null;\n\t\t_contextFillStyle = null;\n\t\t_contextLineWidth = null;\n\t\t_contextLineCap = null;\n\t\t_contextLineJoin = null;\n\n\t\tthis.setViewport(0, 0, width, height);\n\t};\n\n\tthis.setViewport = function (x, y, width, height) {\n\n\t\t_viewportX = x * pixelRatio;\n\t\t_viewportY = y * pixelRatio;\n\n\t\t_viewportWidth = width * pixelRatio;\n\t\t_viewportHeight = height * pixelRatio;\n\t};\n\n\tthis.setScissor = function () {};\n\tthis.enableScissorTest = function () {};\n\n\tthis.setClearColor = function (color, alpha) {\n\n\t\t_clearColor.set(color);\n\t\t_clearAlpha = alpha !== undefined ? alpha : 1;\n\n\t\t_clearBox.min.set(-_canvasWidthHalf, -_canvasHeightHalf);\n\t\t_clearBox.max.set(_canvasWidthHalf, _canvasHeightHalf);\n\t};\n\n\tthis.setClearColorHex = function (hex, alpha) {\n\n\t\tconsole.warn('THREE.CanvasRenderer: .setClearColorHex() is being removed. Use .setClearColor() instead.');\n\t\tthis.setClearColor(hex, alpha);\n\t};\n\n\tthis.getClearColor = function () {\n\n\t\treturn _clearColor;\n\t};\n\n\tthis.getClearAlpha = function () {\n\n\t\treturn _clearAlpha;\n\t};\n\n\tthis.getMaxAnisotropy = function () {\n\n\t\treturn 0;\n\t};\n\n\tthis.clear = function () {\n\n\t\tif (_clearBox.empty() === false) {\n\n\t\t\t_clearBox.intersect(_clipBox);\n\t\t\t_clearBox.expandByScalar(2);\n\n\t\t\t_clearBox.min.x = _clearBox.min.x + _canvasWidthHalf;\n\t\t\t_clearBox.min.y = -_clearBox.min.y + _canvasHeightHalf; // higher y value !\n\t\t\t_clearBox.max.x = _clearBox.max.x + _canvasWidthHalf;\n\t\t\t_clearBox.max.y = -_clearBox.max.y + _canvasHeightHalf; // lower y value !\n\n\t\t\tif (_clearAlpha < 1) {\n\n\t\t\t\t_context.clearRect(_clearBox.min.x | 0, _clearBox.max.y | 0, _clearBox.max.x - _clearBox.min.x | 0, _clearBox.min.y - _clearBox.max.y | 0);\n\t\t\t}\n\n\t\t\tif (_clearAlpha > 0) {\n\n\t\t\t\tsetBlending(THREE.NormalBlending);\n\t\t\t\tsetOpacity(1);\n\n\t\t\t\tsetFillStyle('rgba(' + Math.floor(_clearColor.r * 255) + ',' + Math.floor(_clearColor.g * 255) + ',' + Math.floor(_clearColor.b * 255) + ',' + _clearAlpha + ')');\n\n\t\t\t\t_context.fillRect(_clearBox.min.x | 0, _clearBox.max.y | 0, _clearBox.max.x - _clearBox.min.x | 0, _clearBox.min.y - _clearBox.max.y | 0);\n\t\t\t}\n\n\t\t\t_clearBox.makeEmpty();\n\t\t}\n\t};\n\n\t// compatibility\n\n\tthis.clearColor = function () {};\n\tthis.clearDepth = function () {};\n\tthis.clearStencil = function () {};\n\n\tthis.render = function (scene, camera) {\n\n\t\tif (camera instanceof THREE.Camera === false) {\n\n\t\t\tconsole.error('THREE.CanvasRenderer.render: camera is not an instance of THREE.Camera.');\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.autoClear === true) this.clear();\n\n\t\t_this.info.render.vertices = 0;\n\t\t_this.info.render.faces = 0;\n\n\t\t_context.setTransform(_viewportWidth / _canvasWidth, 0, 0, -_viewportHeight / _canvasHeight, _viewportX, _canvasHeight - _viewportY);\n\t\t_context.translate(_canvasWidthHalf, _canvasHeightHalf);\n\n\t\t_renderData = _projector.projectScene(scene, camera, this.sortObjects, this.sortElements);\n\t\t_elements = _renderData.elements;\n\t\t_lights = _renderData.lights;\n\t\t_camera = camera;\n\n\t\t_normalViewMatrix.getNormalMatrix(camera.matrixWorldInverse);\n\n\t\t/* DEBUG\n  setFillStyle( 'rgba( 0, 255, 255, 0.5 )' );\n  _context.fillRect( _clipBox.min.x, _clipBox.min.y, _clipBox.max.x - _clipBox.min.x, _clipBox.max.y - _clipBox.min.y );\n  */\n\n\t\tcalculateLights();\n\n\t\tfor (var e = 0, el = _elements.length; e < el; e++) {\n\n\t\t\tvar element = _elements[e];\n\n\t\t\tvar material = element.material;\n\n\t\t\tif (material === undefined || material.opacity === 0) continue;\n\n\t\t\t_elemBox.makeEmpty();\n\n\t\t\tif (element instanceof THREE.RenderableSprite) {\n\n\t\t\t\t_v1 = element;\n\t\t\t\t_v1.x *= _canvasWidthHalf;_v1.y *= _canvasHeightHalf;\n\n\t\t\t\trenderSprite(_v1, element, material);\n\t\t\t} else if (element instanceof THREE.RenderableLine) {\n\n\t\t\t\t_v1 = element.v1;_v2 = element.v2;\n\n\t\t\t\t_v1.positionScreen.x *= _canvasWidthHalf;_v1.positionScreen.y *= _canvasHeightHalf;\n\t\t\t\t_v2.positionScreen.x *= _canvasWidthHalf;_v2.positionScreen.y *= _canvasHeightHalf;\n\n\t\t\t\t_elemBox.setFromPoints([_v1.positionScreen, _v2.positionScreen]);\n\n\t\t\t\tif (_clipBox.isIntersectionBox(_elemBox) === true) {\n\n\t\t\t\t\trenderLine(_v1, _v2, element, material);\n\t\t\t\t}\n\t\t\t} else if (element instanceof THREE.RenderableFace) {\n\n\t\t\t\t_v1 = element.v1;_v2 = element.v2;_v3 = element.v3;\n\n\t\t\t\tif (_v1.positionScreen.z < -1 || _v1.positionScreen.z > 1) continue;\n\t\t\t\tif (_v2.positionScreen.z < -1 || _v2.positionScreen.z > 1) continue;\n\t\t\t\tif (_v3.positionScreen.z < -1 || _v3.positionScreen.z > 1) continue;\n\n\t\t\t\t_v1.positionScreen.x *= _canvasWidthHalf;_v1.positionScreen.y *= _canvasHeightHalf;\n\t\t\t\t_v2.positionScreen.x *= _canvasWidthHalf;_v2.positionScreen.y *= _canvasHeightHalf;\n\t\t\t\t_v3.positionScreen.x *= _canvasWidthHalf;_v3.positionScreen.y *= _canvasHeightHalf;\n\n\t\t\t\tif (material.overdraw > 0) {\n\n\t\t\t\t\texpand(_v1.positionScreen, _v2.positionScreen, material.overdraw);\n\t\t\t\t\texpand(_v2.positionScreen, _v3.positionScreen, material.overdraw);\n\t\t\t\t\texpand(_v3.positionScreen, _v1.positionScreen, material.overdraw);\n\t\t\t\t}\n\n\t\t\t\t_elemBox.setFromPoints([_v1.positionScreen, _v2.positionScreen, _v3.positionScreen]);\n\n\t\t\t\tif (_clipBox.isIntersectionBox(_elemBox) === true) {\n\n\t\t\t\t\trenderFace3(_v1, _v2, _v3, 0, 1, 2, element, material);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* DEBUG\n   setLineWidth( 1 );\n   setStrokeStyle( 'rgba( 0, 255, 0, 0.5 )' );\n   _context.strokeRect( _elemBox.min.x, _elemBox.min.y, _elemBox.max.x - _elemBox.min.x, _elemBox.max.y - _elemBox.min.y );\n   */\n\n\t\t\t_clearBox.union(_elemBox);\n\t\t}\n\n\t\t/* DEBUG\n  setLineWidth( 1 );\n  setStrokeStyle( 'rgba( 255, 0, 0, 0.5 )' );\n  _context.strokeRect( _clearBox.min.x, _clearBox.min.y, _clearBox.max.x - _clearBox.min.x, _clearBox.max.y - _clearBox.min.y );\n  */\n\n\t\t_context.setTransform(1, 0, 0, 1, 0, 0);\n\t};\n\n\t//\n\n\tfunction calculateLights() {\n\n\t\t_ambientLight.setRGB(0, 0, 0);\n\t\t_directionalLights.setRGB(0, 0, 0);\n\t\t_pointLights.setRGB(0, 0, 0);\n\n\t\tfor (var l = 0, ll = _lights.length; l < ll; l++) {\n\n\t\t\tvar light = _lights[l];\n\t\t\tvar lightColor = light.color;\n\n\t\t\tif (light instanceof THREE.AmbientLight) {\n\n\t\t\t\t_ambientLight.add(lightColor);\n\t\t\t} else if (light instanceof THREE.DirectionalLight) {\n\n\t\t\t\t// for sprites\n\n\t\t\t\t_directionalLights.add(lightColor);\n\t\t\t} else if (light instanceof THREE.PointLight) {\n\n\t\t\t\t// for sprites\n\n\t\t\t\t_pointLights.add(lightColor);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction calculateLight(position, normal, color) {\n\n\t\tfor (var l = 0, ll = _lights.length; l < ll; l++) {\n\n\t\t\tvar light = _lights[l];\n\n\t\t\t_lightColor.copy(light.color);\n\n\t\t\tif (light instanceof THREE.DirectionalLight) {\n\n\t\t\t\tvar lightPosition = _vector3.setFromMatrixPosition(light.matrixWorld).normalize();\n\n\t\t\t\tvar amount = normal.dot(lightPosition);\n\n\t\t\t\tif (amount <= 0) continue;\n\n\t\t\t\tamount *= light.intensity;\n\n\t\t\t\tcolor.add(_lightColor.multiplyScalar(amount));\n\t\t\t} else if (light instanceof THREE.PointLight) {\n\n\t\t\t\tvar lightPosition = _vector3.setFromMatrixPosition(light.matrixWorld);\n\n\t\t\t\tvar amount = normal.dot(_vector3.subVectors(lightPosition, position).normalize());\n\n\t\t\t\tif (amount <= 0) continue;\n\n\t\t\t\tamount *= light.distance == 0 ? 1 : 1 - Math.min(position.distanceTo(lightPosition) / light.distance, 1);\n\n\t\t\t\tif (amount == 0) continue;\n\n\t\t\t\tamount *= light.intensity;\n\n\t\t\t\tcolor.add(_lightColor.multiplyScalar(amount));\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction renderSprite(v1, element, material) {\n\n\t\tsetOpacity(material.opacity);\n\t\tsetBlending(material.blending);\n\n\t\tvar scaleX = element.scale.x * _canvasWidthHalf;\n\t\tvar scaleY = element.scale.y * _canvasHeightHalf;\n\n\t\tvar dist = 0.5 * Math.sqrt(scaleX * scaleX + scaleY * scaleY); // allow for rotated sprite\n\t\t_elemBox.min.set(v1.x - dist, v1.y - dist);\n\t\t_elemBox.max.set(v1.x + dist, v1.y + dist);\n\n\t\tif (material instanceof THREE.SpriteMaterial) {\n\n\t\t\tvar texture = material.map;\n\n\t\t\tif (texture !== null && texture.image !== undefined) {\n\n\t\t\t\tif (texture.hasEventListener('update', onTextureUpdate) === false) {\n\n\t\t\t\t\tif (texture.image.width > 0) {\n\n\t\t\t\t\t\ttextureToPattern(texture);\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.addEventListener('update', onTextureUpdate);\n\t\t\t\t}\n\n\t\t\t\tvar pattern = _patterns[texture.id];\n\n\t\t\t\tif (pattern !== undefined) {\n\n\t\t\t\t\tsetFillStyle(pattern);\n\t\t\t\t} else {\n\n\t\t\t\t\tsetFillStyle('rgba( 0, 0, 0, 1 )');\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tvar bitmap = texture.image;\n\n\t\t\t\tvar ox = bitmap.width * texture.offset.x;\n\t\t\t\tvar oy = bitmap.height * texture.offset.y;\n\n\t\t\t\tvar sx = bitmap.width * texture.repeat.x;\n\t\t\t\tvar sy = bitmap.height * texture.repeat.y;\n\n\t\t\t\tvar cx = scaleX / sx;\n\t\t\t\tvar cy = scaleY / sy;\n\n\t\t\t\t_context.save();\n\t\t\t\t_context.translate(v1.x, v1.y);\n\t\t\t\tif (material.rotation !== 0) _context.rotate(material.rotation);\n\t\t\t\t_context.translate(-scaleX / 2, -scaleY / 2);\n\t\t\t\t_context.scale(cx, cy);\n\t\t\t\t_context.translate(-ox, -oy);\n\t\t\t\t_context.fillRect(ox, oy, sx, sy);\n\t\t\t\t_context.restore();\n\t\t\t} else {\n\n\t\t\t\t// no texture\n\n\t\t\t\tsetFillStyle(material.color.getStyle());\n\n\t\t\t\t_context.save();\n\t\t\t\t_context.translate(v1.x, v1.y);\n\t\t\t\tif (material.rotation !== 0) _context.rotate(material.rotation);\n\t\t\t\t_context.scale(scaleX, -scaleY);\n\t\t\t\t_context.fillRect(-0.5, -0.5, 1, 1);\n\t\t\t\t_context.restore();\n\t\t\t}\n\t\t} else if (material instanceof THREE.SpriteCanvasMaterial) {\n\n\t\t\tsetStrokeStyle(material.color.getStyle());\n\t\t\tsetFillStyle(material.color.getStyle());\n\n\t\t\t_context.save();\n\t\t\t_context.translate(v1.x, v1.y);\n\t\t\tif (material.rotation !== 0) _context.rotate(material.rotation);\n\t\t\t_context.scale(scaleX, scaleY);\n\n\t\t\tmaterial.program(_context);\n\n\t\t\t_context.restore();\n\t\t}\n\n\t\t/* DEBUG\n  setStrokeStyle( 'rgb(255,255,0)' );\n  _context.beginPath();\n  _context.moveTo( v1.x - 10, v1.y );\n  _context.lineTo( v1.x + 10, v1.y );\n  _context.moveTo( v1.x, v1.y - 10 );\n  _context.lineTo( v1.x, v1.y + 10 );\n  _context.stroke();\n  */\n\t}\n\n\tfunction renderLine(v1, v2, element, material) {\n\n\t\tsetOpacity(material.opacity);\n\t\tsetBlending(material.blending);\n\n\t\t_context.beginPath();\n\t\t_context.moveTo(v1.positionScreen.x, v1.positionScreen.y);\n\t\t_context.lineTo(v2.positionScreen.x, v2.positionScreen.y);\n\n\t\tif (material instanceof THREE.LineBasicMaterial) {\n\n\t\t\tsetLineWidth(material.linewidth);\n\t\t\tsetLineCap(material.linecap);\n\t\t\tsetLineJoin(material.linejoin);\n\n\t\t\tif (material.vertexColors !== THREE.VertexColors) {\n\n\t\t\t\tsetStrokeStyle(material.color.getStyle());\n\t\t\t} else {\n\n\t\t\t\tvar colorStyle1 = element.vertexColors[0].getStyle();\n\t\t\t\tvar colorStyle2 = element.vertexColors[1].getStyle();\n\n\t\t\t\tif (colorStyle1 === colorStyle2) {\n\n\t\t\t\t\tsetStrokeStyle(colorStyle1);\n\t\t\t\t} else {\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\tvar grad = _context.createLinearGradient(v1.positionScreen.x, v1.positionScreen.y, v2.positionScreen.x, v2.positionScreen.y);\n\t\t\t\t\t\tgrad.addColorStop(0, colorStyle1);\n\t\t\t\t\t\tgrad.addColorStop(1, colorStyle2);\n\t\t\t\t\t} catch (exception) {\n\n\t\t\t\t\t\tgrad = colorStyle1;\n\t\t\t\t\t}\n\n\t\t\t\t\tsetStrokeStyle(grad);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_context.stroke();\n\t\t\t_elemBox.expandByScalar(material.linewidth * 2);\n\t\t} else if (material instanceof THREE.LineDashedMaterial) {\n\n\t\t\tsetLineWidth(material.linewidth);\n\t\t\tsetLineCap(material.linecap);\n\t\t\tsetLineJoin(material.linejoin);\n\t\t\tsetStrokeStyle(material.color.getStyle());\n\t\t\tsetLineDash([material.dashSize, material.gapSize]);\n\n\t\t\t_context.stroke();\n\n\t\t\t_elemBox.expandByScalar(material.linewidth * 2);\n\n\t\t\tsetLineDash([]);\n\t\t}\n\t}\n\n\tfunction renderFace3(v1, v2, v3, uv1, uv2, uv3, element, material) {\n\n\t\t_this.info.render.vertices += 3;\n\t\t_this.info.render.faces++;\n\n\t\tsetOpacity(material.opacity);\n\t\tsetBlending(material.blending);\n\n\t\t_v1x = v1.positionScreen.x;_v1y = v1.positionScreen.y;\n\t\t_v2x = v2.positionScreen.x;_v2y = v2.positionScreen.y;\n\t\t_v3x = v3.positionScreen.x;_v3y = v3.positionScreen.y;\n\n\t\tdrawTriangle(_v1x, _v1y, _v2x, _v2y, _v3x, _v3y);\n\n\t\tif ((material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial) && material.map === null) {\n\n\t\t\t_diffuseColor.copy(material.color);\n\t\t\t_emissiveColor.copy(material.emissive);\n\n\t\t\tif (material.vertexColors === THREE.FaceColors) {\n\n\t\t\t\t_diffuseColor.multiply(element.color);\n\t\t\t}\n\n\t\t\t_color.copy(_ambientLight);\n\n\t\t\t_centroid.copy(v1.positionWorld).add(v2.positionWorld).add(v3.positionWorld).divideScalar(3);\n\n\t\t\tcalculateLight(_centroid, element.normalModel, _color);\n\n\t\t\t_color.multiply(_diffuseColor).add(_emissiveColor);\n\n\t\t\tmaterial.wireframe === true ? strokePath(_color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin) : fillPath(_color);\n\t\t} else if (material instanceof THREE.MeshBasicMaterial || material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial) {\n\n\t\t\tif (material.map !== null) {\n\n\t\t\t\tvar mapping = material.map.mapping;\n\n\t\t\t\tif (mapping === THREE.UVMapping) {\n\n\t\t\t\t\t_uvs = element.uvs;\n\t\t\t\t\tpatternPath(_v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uvs[uv1].x, _uvs[uv1].y, _uvs[uv2].x, _uvs[uv2].y, _uvs[uv3].x, _uvs[uv3].y, material.map);\n\t\t\t\t}\n\t\t\t} else if (material.envMap !== null) {\n\n\t\t\t\tif (material.envMap.mapping === THREE.SphericalReflectionMapping) {\n\n\t\t\t\t\t_normal.copy(element.vertexNormalsModel[uv1]).applyMatrix3(_normalViewMatrix);\n\t\t\t\t\t_uv1x = 0.5 * _normal.x + 0.5;\n\t\t\t\t\t_uv1y = 0.5 * _normal.y + 0.5;\n\n\t\t\t\t\t_normal.copy(element.vertexNormalsModel[uv2]).applyMatrix3(_normalViewMatrix);\n\t\t\t\t\t_uv2x = 0.5 * _normal.x + 0.5;\n\t\t\t\t\t_uv2y = 0.5 * _normal.y + 0.5;\n\n\t\t\t\t\t_normal.copy(element.vertexNormalsModel[uv3]).applyMatrix3(_normalViewMatrix);\n\t\t\t\t\t_uv3x = 0.5 * _normal.x + 0.5;\n\t\t\t\t\t_uv3y = 0.5 * _normal.y + 0.5;\n\n\t\t\t\t\tpatternPath(_v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y, material.envMap);\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t_color.copy(material.color);\n\n\t\t\t\tif (material.vertexColors === THREE.FaceColors) {\n\n\t\t\t\t\t_color.multiply(element.color);\n\t\t\t\t}\n\n\t\t\t\tmaterial.wireframe === true ? strokePath(_color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin) : fillPath(_color);\n\t\t\t}\n\t\t} else if (material instanceof THREE.MeshDepthMaterial) {\n\n\t\t\t_color.r = _color.g = _color.b = 1 - smoothstep(v1.positionScreen.z * v1.positionScreen.w, _camera.near, _camera.far);\n\n\t\t\tmaterial.wireframe === true ? strokePath(_color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin) : fillPath(_color);\n\t\t} else if (material instanceof THREE.MeshNormalMaterial) {\n\n\t\t\t_normal.copy(element.normalModel).applyMatrix3(_normalViewMatrix);\n\n\t\t\t_color.setRGB(_normal.x, _normal.y, _normal.z).multiplyScalar(0.5).addScalar(0.5);\n\n\t\t\tmaterial.wireframe === true ? strokePath(_color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin) : fillPath(_color);\n\t\t} else {\n\n\t\t\t_color.setRGB(1, 1, 1);\n\n\t\t\tmaterial.wireframe === true ? strokePath(_color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin) : fillPath(_color);\n\t\t}\n\t}\n\n\t//\n\n\tfunction drawTriangle(x0, y0, x1, y1, x2, y2) {\n\n\t\t_context.beginPath();\n\t\t_context.moveTo(x0, y0);\n\t\t_context.lineTo(x1, y1);\n\t\t_context.lineTo(x2, y2);\n\t\t_context.closePath();\n\t}\n\n\tfunction strokePath(color, linewidth, linecap, linejoin) {\n\n\t\tsetLineWidth(linewidth);\n\t\tsetLineCap(linecap);\n\t\tsetLineJoin(linejoin);\n\t\tsetStrokeStyle(color.getStyle());\n\n\t\t_context.stroke();\n\n\t\t_elemBox.expandByScalar(linewidth * 2);\n\t}\n\n\tfunction fillPath(color) {\n\n\t\tsetFillStyle(color.getStyle());\n\t\t_context.fill();\n\t}\n\n\tfunction onTextureUpdate(event) {\n\n\t\ttextureToPattern(event.target);\n\t}\n\n\tfunction textureToPattern(texture) {\n\n\t\tif (texture instanceof THREE.CompressedTexture) return;\n\n\t\tvar repeatX = texture.wrapS === THREE.RepeatWrapping;\n\t\tvar repeatY = texture.wrapT === THREE.RepeatWrapping;\n\n\t\tvar image = texture.image;\n\n\t\tvar canvas = document.createElement('canvas');\n\t\tcanvas.width = image.width;\n\t\tcanvas.height = image.height;\n\n\t\tvar context = canvas.getContext('2d');\n\t\tcontext.setTransform(1, 0, 0, -1, 0, image.height);\n\t\tcontext.drawImage(image, 0, 0);\n\n\t\t_patterns[texture.id] = _context.createPattern(canvas, repeatX === true && repeatY === true ? 'repeat' : repeatX === true && repeatY === false ? 'repeat-x' : repeatX === false && repeatY === true ? 'repeat-y' : 'no-repeat');\n\t}\n\n\tfunction patternPath(x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, texture) {\n\n\t\tif (texture instanceof THREE.DataTexture) return;\n\n\t\tif (texture.hasEventListener('update', onTextureUpdate) === false) {\n\n\t\t\tif (texture.image !== undefined && texture.image.width > 0) {\n\n\t\t\t\ttextureToPattern(texture);\n\t\t\t}\n\n\t\t\ttexture.addEventListener('update', onTextureUpdate);\n\t\t}\n\n\t\tvar pattern = _patterns[texture.id];\n\n\t\tif (pattern !== undefined) {\n\n\t\t\tsetFillStyle(pattern);\n\t\t} else {\n\n\t\t\tsetFillStyle('rgba(0,0,0,1)');\n\t\t\t_context.fill();\n\n\t\t\treturn;\n\t\t}\n\n\t\t// http://extremelysatisfactorytotalitarianism.com/blog/?p=2120\n\n\t\tvar a,\n\t\t    b,\n\t\t    c,\n\t\t    d,\n\t\t    e,\n\t\t    f,\n\t\t    det,\n\t\t    idet,\n\t\t    offsetX = texture.offset.x / texture.repeat.x,\n\t\t    offsetY = texture.offset.y / texture.repeat.y,\n\t\t    width = texture.image.width * texture.repeat.x,\n\t\t    height = texture.image.height * texture.repeat.y;\n\n\t\tu0 = (u0 + offsetX) * width;\n\t\tv0 = (v0 + offsetY) * height;\n\n\t\tu1 = (u1 + offsetX) * width;\n\t\tv1 = (v1 + offsetY) * height;\n\n\t\tu2 = (u2 + offsetX) * width;\n\t\tv2 = (v2 + offsetY) * height;\n\n\t\tx1 -= x0;y1 -= y0;\n\t\tx2 -= x0;y2 -= y0;\n\n\t\tu1 -= u0;v1 -= v0;\n\t\tu2 -= u0;v2 -= v0;\n\n\t\tdet = u1 * v2 - u2 * v1;\n\n\t\tif (det === 0) return;\n\n\t\tidet = 1 / det;\n\n\t\ta = (v2 * x1 - v1 * x2) * idet;\n\t\tb = (v2 * y1 - v1 * y2) * idet;\n\t\tc = (u1 * x2 - u2 * x1) * idet;\n\t\td = (u1 * y2 - u2 * y1) * idet;\n\n\t\te = x0 - a * u0 - c * v0;\n\t\tf = y0 - b * u0 - d * v0;\n\n\t\t_context.save();\n\t\t_context.transform(a, b, c, d, e, f);\n\t\t_context.fill();\n\t\t_context.restore();\n\t}\n\n\tfunction clipImage(x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, image) {\n\n\t\t// http://extremelysatisfactorytotalitarianism.com/blog/?p=2120\n\n\t\tvar a,\n\t\t    b,\n\t\t    c,\n\t\t    d,\n\t\t    e,\n\t\t    f,\n\t\t    det,\n\t\t    idet,\n\t\t    width = image.width - 1,\n\t\t    height = image.height - 1;\n\n\t\tu0 *= width;v0 *= height;\n\t\tu1 *= width;v1 *= height;\n\t\tu2 *= width;v2 *= height;\n\n\t\tx1 -= x0;y1 -= y0;\n\t\tx2 -= x0;y2 -= y0;\n\n\t\tu1 -= u0;v1 -= v0;\n\t\tu2 -= u0;v2 -= v0;\n\n\t\tdet = u1 * v2 - u2 * v1;\n\n\t\tidet = 1 / det;\n\n\t\ta = (v2 * x1 - v1 * x2) * idet;\n\t\tb = (v2 * y1 - v1 * y2) * idet;\n\t\tc = (u1 * x2 - u2 * x1) * idet;\n\t\td = (u1 * y2 - u2 * y1) * idet;\n\n\t\te = x0 - a * u0 - c * v0;\n\t\tf = y0 - b * u0 - d * v0;\n\n\t\t_context.save();\n\t\t_context.transform(a, b, c, d, e, f);\n\t\t_context.clip();\n\t\t_context.drawImage(image, 0, 0);\n\t\t_context.restore();\n\t}\n\n\t// Hide anti-alias gaps\n\n\tfunction expand(v1, v2, pixels) {\n\n\t\tvar x = v2.x - v1.x,\n\t\t    y = v2.y - v1.y,\n\t\t    det = x * x + y * y,\n\t\t    idet;\n\n\t\tif (det === 0) return;\n\n\t\tidet = pixels / Math.sqrt(det);\n\n\t\tx *= idet;y *= idet;\n\n\t\tv2.x += x;v2.y += y;\n\t\tv1.x -= x;v1.y -= y;\n\t}\n\n\t// Context cached methods.\n\n\tfunction setOpacity(value) {\n\n\t\tif (_contextGlobalAlpha !== value) {\n\n\t\t\t_context.globalAlpha = value;\n\t\t\t_contextGlobalAlpha = value;\n\t\t}\n\t}\n\n\tfunction setBlending(value) {\n\n\t\tif (_contextGlobalCompositeOperation !== value) {\n\n\t\t\tif (value === THREE.NormalBlending) {\n\n\t\t\t\t_context.globalCompositeOperation = 'source-over';\n\t\t\t} else if (value === THREE.AdditiveBlending) {\n\n\t\t\t\t_context.globalCompositeOperation = 'lighter';\n\t\t\t} else if (value === THREE.SubtractiveBlending) {\n\n\t\t\t\t_context.globalCompositeOperation = 'darker';\n\t\t\t}\n\n\t\t\t_contextGlobalCompositeOperation = value;\n\t\t}\n\t}\n\n\tfunction setLineWidth(value) {\n\n\t\tif (_contextLineWidth !== value) {\n\n\t\t\t_context.lineWidth = value;\n\t\t\t_contextLineWidth = value;\n\t\t}\n\t}\n\n\tfunction setLineCap(value) {\n\n\t\t// \"butt\", \"round\", \"square\"\n\n\t\tif (_contextLineCap !== value) {\n\n\t\t\t_context.lineCap = value;\n\t\t\t_contextLineCap = value;\n\t\t}\n\t}\n\n\tfunction setLineJoin(value) {\n\n\t\t// \"round\", \"bevel\", \"miter\"\n\n\t\tif (_contextLineJoin !== value) {\n\n\t\t\t_context.lineJoin = value;\n\t\t\t_contextLineJoin = value;\n\t\t}\n\t}\n\n\tfunction setStrokeStyle(value) {\n\n\t\tif (_contextStrokeStyle !== value) {\n\n\t\t\t_context.strokeStyle = value;\n\t\t\t_contextStrokeStyle = value;\n\t\t}\n\t}\n\n\tfunction setFillStyle(value) {\n\n\t\tif (_contextFillStyle !== value) {\n\n\t\t\t_context.fillStyle = value;\n\t\t\t_contextFillStyle = value;\n\t\t}\n\t}\n\n\tfunction setLineDash(value) {\n\n\t\tif (_contextLineDash.length !== value.length) {\n\n\t\t\t_context.setLineDash(value);\n\t\t\t_contextLineDash = value;\n\t\t}\n\t}\n};\n","'use strict';\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author julianwa / https://github.com/julianwa\n */\n\nTHREE.RenderableObject = function () {\n\n\tthis.id = 0;\n\n\tthis.object = null;\n\tthis.z = 0;\n};\n\n//\n\nTHREE.RenderableFace = function () {\n\n\tthis.id = 0;\n\n\tthis.v1 = new THREE.RenderableVertex();\n\tthis.v2 = new THREE.RenderableVertex();\n\tthis.v3 = new THREE.RenderableVertex();\n\n\tthis.normalModel = new THREE.Vector3();\n\n\tthis.vertexNormalsModel = [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()];\n\tthis.vertexNormalsLength = 0;\n\n\tthis.color = new THREE.Color();\n\tthis.material = null;\n\tthis.uvs = [new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2()];\n\n\tthis.z = 0;\n};\n\n//\n\nTHREE.RenderableVertex = function () {\n\n\tthis.position = new THREE.Vector3();\n\tthis.positionWorld = new THREE.Vector3();\n\tthis.positionScreen = new THREE.Vector4();\n\n\tthis.visible = true;\n};\n\nTHREE.RenderableVertex.prototype.copy = function (vertex) {\n\n\tthis.positionWorld.copy(vertex.positionWorld);\n\tthis.positionScreen.copy(vertex.positionScreen);\n};\n\n//\n\nTHREE.RenderableLine = function () {\n\n\tthis.id = 0;\n\n\tthis.v1 = new THREE.RenderableVertex();\n\tthis.v2 = new THREE.RenderableVertex();\n\n\tthis.vertexColors = [new THREE.Color(), new THREE.Color()];\n\tthis.material = null;\n\n\tthis.z = 0;\n};\n\n//\n\nTHREE.RenderableSprite = function () {\n\n\tthis.id = 0;\n\n\tthis.object = null;\n\n\tthis.x = 0;\n\tthis.y = 0;\n\tthis.z = 0;\n\n\tthis.rotation = 0;\n\tthis.scale = new THREE.Vector2();\n\n\tthis.material = null;\n};\n\n//\n\nTHREE.Projector = function () {\n\n\tvar _object,\n\t    _objectCount,\n\t    _objectPool = [],\n\t    _objectPoolLength = 0,\n\t    _vertex,\n\t    _vertexCount,\n\t    _vertexPool = [],\n\t    _vertexPoolLength = 0,\n\t    _face,\n\t    _faceCount,\n\t    _facePool = [],\n\t    _facePoolLength = 0,\n\t    _line,\n\t    _lineCount,\n\t    _linePool = [],\n\t    _linePoolLength = 0,\n\t    _sprite,\n\t    _spriteCount,\n\t    _spritePool = [],\n\t    _spritePoolLength = 0,\n\t    _renderData = { objects: [], lights: [], elements: [] },\n\t    _vector3 = new THREE.Vector3(),\n\t    _vector4 = new THREE.Vector4(),\n\t    _clipBox = new THREE.Box3(new THREE.Vector3(-1, -1, -1), new THREE.Vector3(1, 1, 1)),\n\t    _boundingBox = new THREE.Box3(),\n\t    _points3 = new Array(3),\n\t    _points4 = new Array(4),\n\t    _viewMatrix = new THREE.Matrix4(),\n\t    _viewProjectionMatrix = new THREE.Matrix4(),\n\t    _modelMatrix,\n\t    _modelViewProjectionMatrix = new THREE.Matrix4(),\n\t    _normalMatrix = new THREE.Matrix3(),\n\t    _frustum = new THREE.Frustum(),\n\t    _clippedVertex1PositionScreen = new THREE.Vector4(),\n\t    _clippedVertex2PositionScreen = new THREE.Vector4();\n\n\t//\n\n\tthis.projectVector = function (vector, camera) {\n\n\t\tconsole.warn('THREE.Projector: .projectVector() is now vector.project().');\n\t\tvector.project(camera);\n\t};\n\n\tthis.unprojectVector = function (vector, camera) {\n\n\t\tconsole.warn('THREE.Projector: .unprojectVector() is now vector.unproject().');\n\t\tvector.unproject(camera);\n\t};\n\n\tthis.pickingRay = function (vector, camera) {\n\n\t\tconsole.error('THREE.Projector: .pickingRay() is now raycaster.setFromCamera().');\n\t};\n\n\t//\n\n\tvar RenderList = function RenderList() {\n\n\t\tvar normals = [];\n\t\tvar uvs = [];\n\n\t\tvar object = null;\n\t\tvar material = null;\n\n\t\tvar normalMatrix = new THREE.Matrix3();\n\n\t\tvar setObject = function setObject(value) {\n\n\t\t\tobject = value;\n\t\t\tmaterial = object.material;\n\n\t\t\tnormalMatrix.getNormalMatrix(object.matrixWorld);\n\n\t\t\tnormals.length = 0;\n\t\t\tuvs.length = 0;\n\t\t};\n\n\t\tvar projectVertex = function projectVertex(vertex) {\n\n\t\t\tvar position = vertex.position;\n\t\t\tvar positionWorld = vertex.positionWorld;\n\t\t\tvar positionScreen = vertex.positionScreen;\n\n\t\t\tpositionWorld.copy(position).applyMatrix4(_modelMatrix);\n\t\t\tpositionScreen.copy(positionWorld).applyMatrix4(_viewProjectionMatrix);\n\n\t\t\tvar invW = 1 / positionScreen.w;\n\n\t\t\tpositionScreen.x *= invW;\n\t\t\tpositionScreen.y *= invW;\n\t\t\tpositionScreen.z *= invW;\n\n\t\t\tvertex.visible = positionScreen.x >= -1 && positionScreen.x <= 1 && positionScreen.y >= -1 && positionScreen.y <= 1 && positionScreen.z >= -1 && positionScreen.z <= 1;\n\t\t};\n\n\t\tvar pushVertex = function pushVertex(x, y, z) {\n\n\t\t\t_vertex = getNextVertexInPool();\n\t\t\t_vertex.position.set(x, y, z);\n\n\t\t\tprojectVertex(_vertex);\n\t\t};\n\n\t\tvar pushNormal = function pushNormal(x, y, z) {\n\n\t\t\tnormals.push(x, y, z);\n\t\t};\n\n\t\tvar pushUv = function pushUv(x, y) {\n\n\t\t\tuvs.push(x, y);\n\t\t};\n\n\t\tvar checkTriangleVisibility = function checkTriangleVisibility(v1, v2, v3) {\n\n\t\t\tif (v1.visible === true || v2.visible === true || v3.visible === true) return true;\n\n\t\t\t_points3[0] = v1.positionScreen;\n\t\t\t_points3[1] = v2.positionScreen;\n\t\t\t_points3[2] = v3.positionScreen;\n\n\t\t\treturn _clipBox.isIntersectionBox(_boundingBox.setFromPoints(_points3));\n\t\t};\n\n\t\tvar checkBackfaceCulling = function checkBackfaceCulling(v1, v2, v3) {\n\n\t\t\treturn (v3.positionScreen.x - v1.positionScreen.x) * (v2.positionScreen.y - v1.positionScreen.y) - (v3.positionScreen.y - v1.positionScreen.y) * (v2.positionScreen.x - v1.positionScreen.x) < 0;\n\t\t};\n\n\t\tvar pushLine = function pushLine(a, b) {\n\n\t\t\tvar v1 = _vertexPool[a];\n\t\t\tvar v2 = _vertexPool[b];\n\n\t\t\t_line = getNextLineInPool();\n\n\t\t\t_line.id = object.id;\n\t\t\t_line.v1.copy(v1);\n\t\t\t_line.v2.copy(v2);\n\t\t\t_line.z = (v1.positionScreen.z + v2.positionScreen.z) / 2;\n\n\t\t\t_line.material = object.material;\n\n\t\t\t_renderData.elements.push(_line);\n\t\t};\n\n\t\tvar pushTriangle = function pushTriangle(a, b, c) {\n\n\t\t\tvar v1 = _vertexPool[a];\n\t\t\tvar v2 = _vertexPool[b];\n\t\t\tvar v3 = _vertexPool[c];\n\n\t\t\tif (checkTriangleVisibility(v1, v2, v3) === false) return;\n\n\t\t\tif (material.side === THREE.DoubleSide || checkBackfaceCulling(v1, v2, v3) === true) {\n\n\t\t\t\t_face = getNextFaceInPool();\n\n\t\t\t\t_face.id = object.id;\n\t\t\t\t_face.v1.copy(v1);\n\t\t\t\t_face.v2.copy(v2);\n\t\t\t\t_face.v3.copy(v3);\n\t\t\t\t_face.z = (v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z) / 3;\n\n\t\t\t\tfor (var i = 0; i < 3; i++) {\n\n\t\t\t\t\tvar offset = arguments[i] * 3;\n\t\t\t\t\tvar normal = _face.vertexNormalsModel[i];\n\n\t\t\t\t\tnormal.set(normals[offset], normals[offset + 1], normals[offset + 2]);\n\t\t\t\t\tnormal.applyMatrix3(normalMatrix).normalize();\n\n\t\t\t\t\tvar offset2 = arguments[i] * 2;\n\n\t\t\t\t\tvar uv = _face.uvs[i];\n\t\t\t\t\tuv.set(uvs[offset2], uvs[offset2 + 1]);\n\t\t\t\t}\n\n\t\t\t\t_face.vertexNormalsLength = 3;\n\n\t\t\t\t_face.material = object.material;\n\n\t\t\t\t_renderData.elements.push(_face);\n\t\t\t}\n\t\t};\n\n\t\treturn {\n\t\t\tsetObject: setObject,\n\t\t\tprojectVertex: projectVertex,\n\t\t\tcheckTriangleVisibility: checkTriangleVisibility,\n\t\t\tcheckBackfaceCulling: checkBackfaceCulling,\n\t\t\tpushVertex: pushVertex,\n\t\t\tpushNormal: pushNormal,\n\t\t\tpushUv: pushUv,\n\t\t\tpushLine: pushLine,\n\t\t\tpushTriangle: pushTriangle\n\t\t};\n\t};\n\n\tvar renderList = new RenderList();\n\n\tthis.projectScene = function (scene, camera, sortObjects, sortElements) {\n\n\t\t_faceCount = 0;\n\t\t_lineCount = 0;\n\t\t_spriteCount = 0;\n\n\t\t_renderData.elements.length = 0;\n\n\t\tif (scene.autoUpdate === true) scene.updateMatrixWorld();\n\t\tif (camera.parent === undefined) camera.updateMatrixWorld();\n\n\t\t_viewMatrix.copy(camera.matrixWorldInverse.getInverse(camera.matrixWorld));\n\t\t_viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, _viewMatrix);\n\n\t\t_frustum.setFromMatrix(_viewProjectionMatrix);\n\n\t\t//\n\n\t\t_objectCount = 0;\n\n\t\t_renderData.objects.length = 0;\n\t\t_renderData.lights.length = 0;\n\n\t\tscene.traverseVisible(function (object) {\n\n\t\t\tif (object instanceof THREE.Light) {\n\n\t\t\t\t_renderData.lights.push(object);\n\t\t\t} else if (object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Sprite) {\n\n\t\t\t\tif (object.material.visible === false) return;\n\n\t\t\t\tif (object.frustumCulled === false || _frustum.intersectsObject(object) === true) {\n\n\t\t\t\t\t_object = getNextObjectInPool();\n\t\t\t\t\t_object.id = object.id;\n\t\t\t\t\t_object.object = object;\n\n\t\t\t\t\t_vector3.setFromMatrixPosition(object.matrixWorld);\n\t\t\t\t\t_vector3.applyProjection(_viewProjectionMatrix);\n\t\t\t\t\t_object.z = _vector3.z;\n\n\t\t\t\t\t_renderData.objects.push(_object);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tif (sortObjects === true) {\n\n\t\t\t_renderData.objects.sort(painterSort);\n\t\t}\n\n\t\t//\n\n\t\tfor (var o = 0, ol = _renderData.objects.length; o < ol; o++) {\n\n\t\t\tvar object = _renderData.objects[o].object;\n\t\t\tvar geometry = object.geometry;\n\n\t\t\trenderList.setObject(object);\n\n\t\t\t_modelMatrix = object.matrixWorld;\n\n\t\t\t_vertexCount = 0;\n\n\t\t\tif (object instanceof THREE.Mesh) {\n\n\t\t\t\tif (geometry instanceof THREE.BufferGeometry) {\n\n\t\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\t\tvar offsets = geometry.offsets;\n\n\t\t\t\t\tif (attributes.position === undefined) continue;\n\n\t\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\t\tfor (var i = 0, l = positions.length; i < l; i += 3) {\n\n\t\t\t\t\t\trenderList.pushVertex(positions[i], positions[i + 1], positions[i + 2]);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (attributes.normal !== undefined) {\n\n\t\t\t\t\t\tvar normals = attributes.normal.array;\n\n\t\t\t\t\t\tfor (var i = 0, l = normals.length; i < l; i += 3) {\n\n\t\t\t\t\t\t\trenderList.pushNormal(normals[i], normals[i + 1], normals[i + 2]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (attributes.uv !== undefined) {\n\n\t\t\t\t\t\tvar uvs = attributes.uv.array;\n\n\t\t\t\t\t\tfor (var i = 0, l = uvs.length; i < l; i += 2) {\n\n\t\t\t\t\t\t\trenderList.pushUv(uvs[i], uvs[i + 1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (attributes.index !== undefined) {\n\n\t\t\t\t\t\tvar indices = attributes.index.array;\n\n\t\t\t\t\t\tif (offsets.length > 0) {\n\n\t\t\t\t\t\t\tfor (var o = 0; o < offsets.length; o++) {\n\n\t\t\t\t\t\t\t\tvar offset = offsets[o];\n\t\t\t\t\t\t\t\tvar index = offset.index;\n\n\t\t\t\t\t\t\t\tfor (var i = offset.start, l = offset.start + offset.count; i < l; i += 3) {\n\n\t\t\t\t\t\t\t\t\trenderList.pushTriangle(indices[i] + index, indices[i + 1] + index, indices[i + 2] + index);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfor (var i = 0, l = indices.length; i < l; i += 3) {\n\n\t\t\t\t\t\t\t\trenderList.pushTriangle(indices[i], indices[i + 1], indices[i + 2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor (var i = 0, l = positions.length / 3; i < l; i += 3) {\n\n\t\t\t\t\t\t\trenderList.pushTriangle(i, i + 1, i + 2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (geometry instanceof THREE.Geometry) {\n\n\t\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\t\tvar faces = geometry.faces;\n\t\t\t\t\tvar faceVertexUvs = geometry.faceVertexUvs[0];\n\n\t\t\t\t\t_normalMatrix.getNormalMatrix(_modelMatrix);\n\n\t\t\t\t\tvar material = object.material;\n\n\t\t\t\t\tvar isFaceMaterial = material instanceof THREE.MeshFaceMaterial;\n\t\t\t\t\tvar objectMaterials = isFaceMaterial === true ? object.material : null;\n\n\t\t\t\t\tfor (var v = 0, vl = vertices.length; v < vl; v++) {\n\n\t\t\t\t\t\tvar vertex = vertices[v];\n\n\t\t\t\t\t\t_vector3.copy(vertex);\n\n\t\t\t\t\t\tif (material.morphTargets === true) {\n\n\t\t\t\t\t\t\tvar morphTargets = geometry.morphTargets;\n\t\t\t\t\t\t\tvar morphInfluences = object.morphTargetInfluences;\n\n\t\t\t\t\t\t\tfor (var t = 0, tl = morphTargets.length; t < tl; t++) {\n\n\t\t\t\t\t\t\t\tvar influence = morphInfluences[t];\n\n\t\t\t\t\t\t\t\tif (influence === 0) continue;\n\n\t\t\t\t\t\t\t\tvar target = morphTargets[t];\n\t\t\t\t\t\t\t\tvar targetVertex = target.vertices[v];\n\n\t\t\t\t\t\t\t\t_vector3.x += (targetVertex.x - vertex.x) * influence;\n\t\t\t\t\t\t\t\t_vector3.y += (targetVertex.y - vertex.y) * influence;\n\t\t\t\t\t\t\t\t_vector3.z += (targetVertex.z - vertex.z) * influence;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\trenderList.pushVertex(_vector3.x, _vector3.y, _vector3.z);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (var f = 0, fl = faces.length; f < fl; f++) {\n\n\t\t\t\t\t\tvar face = faces[f];\n\n\t\t\t\t\t\tvar material = isFaceMaterial === true ? objectMaterials.materials[face.materialIndex] : object.material;\n\n\t\t\t\t\t\tif (material === undefined) continue;\n\n\t\t\t\t\t\tvar side = material.side;\n\n\t\t\t\t\t\tvar v1 = _vertexPool[face.a];\n\t\t\t\t\t\tvar v2 = _vertexPool[face.b];\n\t\t\t\t\t\tvar v3 = _vertexPool[face.c];\n\n\t\t\t\t\t\tif (renderList.checkTriangleVisibility(v1, v2, v3) === false) continue;\n\n\t\t\t\t\t\tvar visible = renderList.checkBackfaceCulling(v1, v2, v3);\n\n\t\t\t\t\t\tif (side !== THREE.DoubleSide) {\n\t\t\t\t\t\t\tif (side === THREE.FrontSide && visible === false) continue;\n\t\t\t\t\t\t\tif (side === THREE.BackSide && visible === true) continue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_face = getNextFaceInPool();\n\n\t\t\t\t\t\t_face.id = object.id;\n\t\t\t\t\t\t_face.v1.copy(v1);\n\t\t\t\t\t\t_face.v2.copy(v2);\n\t\t\t\t\t\t_face.v3.copy(v3);\n\n\t\t\t\t\t\t_face.normalModel.copy(face.normal);\n\n\t\t\t\t\t\tif (visible === false && (side === THREE.BackSide || side === THREE.DoubleSide)) {\n\n\t\t\t\t\t\t\t_face.normalModel.negate();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_face.normalModel.applyMatrix3(_normalMatrix).normalize();\n\n\t\t\t\t\t\tvar faceVertexNormals = face.vertexNormals;\n\n\t\t\t\t\t\tfor (var n = 0, nl = Math.min(faceVertexNormals.length, 3); n < nl; n++) {\n\n\t\t\t\t\t\t\tvar normalModel = _face.vertexNormalsModel[n];\n\t\t\t\t\t\t\tnormalModel.copy(faceVertexNormals[n]);\n\n\t\t\t\t\t\t\tif (visible === false && (side === THREE.BackSide || side === THREE.DoubleSide)) {\n\n\t\t\t\t\t\t\t\tnormalModel.negate();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tnormalModel.applyMatrix3(_normalMatrix).normalize();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_face.vertexNormalsLength = faceVertexNormals.length;\n\n\t\t\t\t\t\tvar vertexUvs = faceVertexUvs[f];\n\n\t\t\t\t\t\tif (vertexUvs !== undefined) {\n\n\t\t\t\t\t\t\tfor (var u = 0; u < 3; u++) {\n\n\t\t\t\t\t\t\t\t_face.uvs[u].copy(vertexUvs[u]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_face.color = face.color;\n\t\t\t\t\t\t_face.material = material;\n\n\t\t\t\t\t\t_face.z = (v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z) / 3;\n\n\t\t\t\t\t\t_renderData.elements.push(_face);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (object instanceof THREE.Line) {\n\n\t\t\t\tif (geometry instanceof THREE.BufferGeometry) {\n\n\t\t\t\t\tvar attributes = geometry.attributes;\n\n\t\t\t\t\tif (attributes.position !== undefined) {\n\n\t\t\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\t\t\tfor (var i = 0, l = positions.length; i < l; i += 3) {\n\n\t\t\t\t\t\t\trenderList.pushVertex(positions[i], positions[i + 1], positions[i + 2]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (attributes.index !== undefined) {\n\n\t\t\t\t\t\t\tvar indices = attributes.index.array;\n\n\t\t\t\t\t\t\tfor (var i = 0, l = indices.length; i < l; i += 2) {\n\n\t\t\t\t\t\t\t\trenderList.pushLine(indices[i], indices[i + 1]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar step = object.mode === THREE.LinePieces ? 2 : 1;\n\n\t\t\t\t\t\t\tfor (var i = 0, l = positions.length / 3 - 1; i < l; i += step) {\n\n\t\t\t\t\t\t\t\trenderList.pushLine(i, i + 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (geometry instanceof THREE.Geometry) {\n\n\t\t\t\t\t_modelViewProjectionMatrix.multiplyMatrices(_viewProjectionMatrix, _modelMatrix);\n\n\t\t\t\t\tvar vertices = object.geometry.vertices;\n\n\t\t\t\t\tif (vertices.length === 0) continue;\n\n\t\t\t\t\tv1 = getNextVertexInPool();\n\t\t\t\t\tv1.positionScreen.copy(vertices[0]).applyMatrix4(_modelViewProjectionMatrix);\n\n\t\t\t\t\t// Handle LineStrip and LinePieces\n\t\t\t\t\tvar step = object.mode === THREE.LinePieces ? 2 : 1;\n\n\t\t\t\t\tfor (var v = 1, vl = vertices.length; v < vl; v++) {\n\n\t\t\t\t\t\tv1 = getNextVertexInPool();\n\t\t\t\t\t\tv1.positionScreen.copy(vertices[v]).applyMatrix4(_modelViewProjectionMatrix);\n\n\t\t\t\t\t\tif ((v + 1) % step > 0) continue;\n\n\t\t\t\t\t\tv2 = _vertexPool[_vertexCount - 2];\n\n\t\t\t\t\t\t_clippedVertex1PositionScreen.copy(v1.positionScreen);\n\t\t\t\t\t\t_clippedVertex2PositionScreen.copy(v2.positionScreen);\n\n\t\t\t\t\t\tif (clipLine(_clippedVertex1PositionScreen, _clippedVertex2PositionScreen) === true) {\n\n\t\t\t\t\t\t\t// Perform the perspective divide\n\t\t\t\t\t\t\t_clippedVertex1PositionScreen.multiplyScalar(1 / _clippedVertex1PositionScreen.w);\n\t\t\t\t\t\t\t_clippedVertex2PositionScreen.multiplyScalar(1 / _clippedVertex2PositionScreen.w);\n\n\t\t\t\t\t\t\t_line = getNextLineInPool();\n\n\t\t\t\t\t\t\t_line.id = object.id;\n\t\t\t\t\t\t\t_line.v1.positionScreen.copy(_clippedVertex1PositionScreen);\n\t\t\t\t\t\t\t_line.v2.positionScreen.copy(_clippedVertex2PositionScreen);\n\n\t\t\t\t\t\t\t_line.z = Math.max(_clippedVertex1PositionScreen.z, _clippedVertex2PositionScreen.z);\n\n\t\t\t\t\t\t\t_line.material = object.material;\n\n\t\t\t\t\t\t\tif (object.material.vertexColors === THREE.VertexColors) {\n\n\t\t\t\t\t\t\t\t_line.vertexColors[0].copy(object.geometry.colors[v]);\n\t\t\t\t\t\t\t\t_line.vertexColors[1].copy(object.geometry.colors[v - 1]);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t_renderData.elements.push(_line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (object instanceof THREE.Sprite) {\n\n\t\t\t\t_vector4.set(_modelMatrix.elements[12], _modelMatrix.elements[13], _modelMatrix.elements[14], 1);\n\t\t\t\t_vector4.applyMatrix4(_viewProjectionMatrix);\n\n\t\t\t\tvar invW = 1 / _vector4.w;\n\n\t\t\t\t_vector4.z *= invW;\n\n\t\t\t\tif (_vector4.z >= -1 && _vector4.z <= 1) {\n\n\t\t\t\t\t_sprite = getNextSpriteInPool();\n\t\t\t\t\t_sprite.id = object.id;\n\t\t\t\t\t_sprite.x = _vector4.x * invW;\n\t\t\t\t\t_sprite.y = _vector4.y * invW;\n\t\t\t\t\t_sprite.z = _vector4.z;\n\t\t\t\t\t_sprite.object = object;\n\n\t\t\t\t\t_sprite.rotation = object.rotation;\n\n\t\t\t\t\t_sprite.scale.x = object.scale.x * Math.abs(_sprite.x - (_vector4.x + camera.projectionMatrix.elements[0]) / (_vector4.w + camera.projectionMatrix.elements[12]));\n\t\t\t\t\t_sprite.scale.y = object.scale.y * Math.abs(_sprite.y - (_vector4.y + camera.projectionMatrix.elements[5]) / (_vector4.w + camera.projectionMatrix.elements[13]));\n\n\t\t\t\t\t_sprite.material = object.material;\n\n\t\t\t\t\t_renderData.elements.push(_sprite);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (sortElements === true) {\n\n\t\t\t_renderData.elements.sort(painterSort);\n\t\t}\n\n\t\treturn _renderData;\n\t};\n\n\t// Pools\n\n\tfunction getNextObjectInPool() {\n\n\t\tif (_objectCount === _objectPoolLength) {\n\n\t\t\tvar object = new THREE.RenderableObject();\n\t\t\t_objectPool.push(object);\n\t\t\t_objectPoolLength++;\n\t\t\t_objectCount++;\n\t\t\treturn object;\n\t\t}\n\n\t\treturn _objectPool[_objectCount++];\n\t}\n\n\tfunction getNextVertexInPool() {\n\n\t\tif (_vertexCount === _vertexPoolLength) {\n\n\t\t\tvar vertex = new THREE.RenderableVertex();\n\t\t\t_vertexPool.push(vertex);\n\t\t\t_vertexPoolLength++;\n\t\t\t_vertexCount++;\n\t\t\treturn vertex;\n\t\t}\n\n\t\treturn _vertexPool[_vertexCount++];\n\t}\n\n\tfunction getNextFaceInPool() {\n\n\t\tif (_faceCount === _facePoolLength) {\n\n\t\t\tvar face = new THREE.RenderableFace();\n\t\t\t_facePool.push(face);\n\t\t\t_facePoolLength++;\n\t\t\t_faceCount++;\n\t\t\treturn face;\n\t\t}\n\n\t\treturn _facePool[_faceCount++];\n\t}\n\n\tfunction getNextLineInPool() {\n\n\t\tif (_lineCount === _linePoolLength) {\n\n\t\t\tvar line = new THREE.RenderableLine();\n\t\t\t_linePool.push(line);\n\t\t\t_linePoolLength++;\n\t\t\t_lineCount++;\n\t\t\treturn line;\n\t\t}\n\n\t\treturn _linePool[_lineCount++];\n\t}\n\n\tfunction getNextSpriteInPool() {\n\n\t\tif (_spriteCount === _spritePoolLength) {\n\n\t\t\tvar sprite = new THREE.RenderableSprite();\n\t\t\t_spritePool.push(sprite);\n\t\t\t_spritePoolLength++;\n\t\t\t_spriteCount++;\n\t\t\treturn sprite;\n\t\t}\n\n\t\treturn _spritePool[_spriteCount++];\n\t}\n\n\t//\n\n\tfunction painterSort(a, b) {\n\n\t\tif (a.z !== b.z) {\n\n\t\t\treturn b.z - a.z;\n\t\t} else if (a.id !== b.id) {\n\n\t\t\treturn a.id - b.id;\n\t\t} else {\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tfunction clipLine(s1, s2) {\n\n\t\tvar alpha1 = 0,\n\t\t    alpha2 = 1,\n\n\n\t\t// Calculate the boundary coordinate of each vertex for the near and far clip planes,\n\t\t// Z = -1 and Z = +1, respectively.\n\t\tbc1near = s1.z + s1.w,\n\t\t    bc2near = s2.z + s2.w,\n\t\t    bc1far = -s1.z + s1.w,\n\t\t    bc2far = -s2.z + s2.w;\n\n\t\tif (bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0) {\n\n\t\t\t// Both vertices lie entirely within all clip planes.\n\t\t\treturn true;\n\t\t} else if (bc1near < 0 && bc2near < 0 || bc1far < 0 && bc2far < 0) {\n\n\t\t\t// Both vertices lie entirely outside one of the clip planes.\n\t\t\treturn false;\n\t\t} else {\n\n\t\t\t// The line segment spans at least one clip plane.\n\n\t\t\tif (bc1near < 0) {\n\n\t\t\t\t// v1 lies outside the near plane, v2 inside\n\t\t\t\talpha1 = Math.max(alpha1, bc1near / (bc1near - bc2near));\n\t\t\t} else if (bc2near < 0) {\n\n\t\t\t\t// v2 lies outside the near plane, v1 inside\n\t\t\t\talpha2 = Math.min(alpha2, bc1near / (bc1near - bc2near));\n\t\t\t}\n\n\t\t\tif (bc1far < 0) {\n\n\t\t\t\t// v1 lies outside the far plane, v2 inside\n\t\t\t\talpha1 = Math.max(alpha1, bc1far / (bc1far - bc2far));\n\t\t\t} else if (bc2far < 0) {\n\n\t\t\t\t// v2 lies outside the far plane, v2 inside\n\t\t\t\talpha2 = Math.min(alpha2, bc1far / (bc1far - bc2far));\n\t\t\t}\n\n\t\t\tif (alpha2 < alpha1) {\n\n\t\t\t\t// The line segment spans two boundaries, but is outside both of them.\n\t\t\t\t// (This can't happen when we're only clipping against just near/far but good\n\t\t\t\t//  to leave the check here for future usage if other clip planes are added.)\n\t\t\t\treturn false;\n\t\t\t} else {\n\n\t\t\t\t// Update the s1 and s2 vertices to match the clipped line segment.\n\t\t\t\ts1.lerp(s2, alpha1);\n\t\t\t\ts2.lerp(s1, 1 - alpha2);\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n};\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _phoenix = require(\"phoenix\");\n\nvar socket = new _phoenix.Socket(\"/socket\", { params: { token: window.userToken } });\n\n// When you connect, you'll often need to authenticate the client.\n// For example, imagine you have an authentication plug, `MyAuth`,\n// which authenticates the session and assigns a `:current_user`.\n// If the current user exists you can assign the user's token in\n// the connection for use in the layout.\n//\n// In your \"web/router.ex\":\n//\n//     pipeline :browser do\n//       ...\n//       plug MyAuth\n//       plug :put_user_token\n//     end\n//\n//     defp put_user_token(conn, _) do\n//       if current_user = conn.assigns[:current_user] do\n//         token = Phoenix.Token.sign(conn, \"user socket\", current_user.id)\n//         assign(conn, :user_token, token)\n//       else\n//         conn\n//       end\n//     end\n//\n// Now you need to pass this token to JavaScript. You can do so\n// inside a script tag in \"web/templates/layout/app.html.eex\":\n//\n//     <script>window.userToken = \"<%= assigns[:user_token] %>\";</script>\n//\n// You will need to verify the user token in the \"connect/2\" function\n// in \"web/channels/user_socket.ex\":\n//\n//     def connect(%{\"token\" => token}, socket) do\n//       # max_age: 1209600 is equivalent to two weeks in seconds\n//       case Phoenix.Token.verify(socket, \"user socket\", token, max_age: 1209600) do\n//         {:ok, user_id} ->\n//           {:ok, assign(socket, :user, user_id)}\n//         {:error, reason} ->\n//           :error\n//       end\n//     end\n//\n// Finally, pass the token to the Socket constructor as above.\n// Or, remove it from the constructor if you don't care about\n// authentication.\n\n// NOTE: The contents of this file will only be executed if\n// you uncomment its entry in \"web/static/js/app.js\".\n\n// To use Phoenix channels, the first step is to import Socket\n// and connect at the socket path in \"lib/my_app/endpoint.ex\":\nsocket.connect();\n\n// Now that you are connected, you can join channels with a topic:\nvar channel = socket.channel(\"topic:subtopic\", {});\nchannel.join().receive(\"ok\", function (resp) {\n  console.log(\"Joined successfully\", resp);\n}).receive(\"error\", function (resp) {\n  console.log(\"Unable to join\", resp);\n});\n\nexports.default = socket;\n","// threejs.org/license\n'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar THREE = { REVISION: \"71\" };\"object\" === (typeof module === \"undefined\" ? \"undefined\" : _typeof(module)) && (module.exports = THREE);void 0 === Math.sign && (Math.sign = function (a) {\n  return 0 > a ? -1 : 0 < a ? 1 : +a;\n});THREE.log = function () {\n  console.log.apply(console, arguments);\n};THREE.warn = function () {\n  console.warn.apply(console, arguments);\n};THREE.error = function () {\n  console.error.apply(console, arguments);\n};THREE.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };THREE.CullFaceNone = 0;THREE.CullFaceBack = 1;THREE.CullFaceFront = 2;THREE.CullFaceFrontBack = 3;THREE.FrontFaceDirectionCW = 0;\nTHREE.FrontFaceDirectionCCW = 1;THREE.BasicShadowMap = 0;THREE.PCFShadowMap = 1;THREE.PCFSoftShadowMap = 2;THREE.FrontSide = 0;THREE.BackSide = 1;THREE.DoubleSide = 2;THREE.NoShading = 0;THREE.FlatShading = 1;THREE.SmoothShading = 2;THREE.NoColors = 0;THREE.FaceColors = 1;THREE.VertexColors = 2;THREE.NoBlending = 0;THREE.NormalBlending = 1;THREE.AdditiveBlending = 2;THREE.SubtractiveBlending = 3;THREE.MultiplyBlending = 4;THREE.CustomBlending = 5;THREE.AddEquation = 100;THREE.SubtractEquation = 101;THREE.ReverseSubtractEquation = 102;\nTHREE.MinEquation = 103;THREE.MaxEquation = 104;THREE.ZeroFactor = 200;THREE.OneFactor = 201;THREE.SrcColorFactor = 202;THREE.OneMinusSrcColorFactor = 203;THREE.SrcAlphaFactor = 204;THREE.OneMinusSrcAlphaFactor = 205;THREE.DstAlphaFactor = 206;THREE.OneMinusDstAlphaFactor = 207;THREE.DstColorFactor = 208;THREE.OneMinusDstColorFactor = 209;THREE.SrcAlphaSaturateFactor = 210;THREE.MultiplyOperation = 0;THREE.MixOperation = 1;THREE.AddOperation = 2;THREE.UVMapping = 300;THREE.CubeReflectionMapping = 301;THREE.CubeRefractionMapping = 302;\nTHREE.EquirectangularReflectionMapping = 303;THREE.EquirectangularRefractionMapping = 304;THREE.SphericalReflectionMapping = 305;THREE.RepeatWrapping = 1E3;THREE.ClampToEdgeWrapping = 1001;THREE.MirroredRepeatWrapping = 1002;THREE.NearestFilter = 1003;THREE.NearestMipMapNearestFilter = 1004;THREE.NearestMipMapLinearFilter = 1005;THREE.LinearFilter = 1006;THREE.LinearMipMapNearestFilter = 1007;THREE.LinearMipMapLinearFilter = 1008;THREE.UnsignedByteType = 1009;THREE.ByteType = 1010;THREE.ShortType = 1011;\nTHREE.UnsignedShortType = 1012;THREE.IntType = 1013;THREE.UnsignedIntType = 1014;THREE.FloatType = 1015;THREE.HalfFloatType = 1025;THREE.UnsignedShort4444Type = 1016;THREE.UnsignedShort5551Type = 1017;THREE.UnsignedShort565Type = 1018;THREE.AlphaFormat = 1019;THREE.RGBFormat = 1020;THREE.RGBAFormat = 1021;THREE.LuminanceFormat = 1022;THREE.LuminanceAlphaFormat = 1023;THREE.RGBEFormat = THREE.RGBAFormat;THREE.RGB_S3TC_DXT1_Format = 2001;THREE.RGBA_S3TC_DXT1_Format = 2002;THREE.RGBA_S3TC_DXT3_Format = 2003;\nTHREE.RGBA_S3TC_DXT5_Format = 2004;THREE.RGB_PVRTC_4BPPV1_Format = 2100;THREE.RGB_PVRTC_2BPPV1_Format = 2101;THREE.RGBA_PVRTC_4BPPV1_Format = 2102;THREE.RGBA_PVRTC_2BPPV1_Format = 2103;\nTHREE.Projector = function () {\n  THREE.error(\"THREE.Projector has been moved to /examples/js/renderers/Projector.js.\");this.projectVector = function (a, b) {\n    THREE.warn(\"THREE.Projector: .projectVector() is now vector.project().\");a.project(b);\n  };this.unprojectVector = function (a, b) {\n    THREE.warn(\"THREE.Projector: .unprojectVector() is now vector.unproject().\");a.unproject(b);\n  };this.pickingRay = function (a, b) {\n    THREE.error(\"THREE.Projector: .pickingRay() is now raycaster.setFromCamera().\");\n  };\n};\nTHREE.CanvasRenderer = function () {\n  THREE.error(\"THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js\");this.domElement = document.createElement(\"canvas\");this.clear = function () {};this.render = function () {};this.setClearColor = function () {};this.setSize = function () {};\n};THREE.Color = function (a) {\n  return 3 === arguments.length ? this.setRGB(arguments[0], arguments[1], arguments[2]) : this.set(a);\n};\nTHREE.Color.prototype = { constructor: THREE.Color, r: 1, g: 1, b: 1, set: function set(a) {\n    a instanceof THREE.Color ? this.copy(a) : \"number\" === typeof a ? this.setHex(a) : \"string\" === typeof a && this.setStyle(a);return this;\n  }, setHex: function setHex(a) {\n    a = Math.floor(a);this.r = (a >> 16 & 255) / 255;this.g = (a >> 8 & 255) / 255;this.b = (a & 255) / 255;return this;\n  }, setRGB: function setRGB(a, b, c) {\n    this.r = a;this.g = b;this.b = c;return this;\n  }, setHSL: function setHSL(a, b, c) {\n    if (0 === b) this.r = this.g = this.b = c;else {\n      var d = function d(a, b, c) {\n        0 > c && (c += 1);1 < c && (c -= 1);return c < 1 / 6 ? a + 6 * (b - a) * c : .5 > c ? b : c < 2 / 3 ? a + 6 * (b - a) * (2 / 3 - c) : a;\n      };b = .5 >= c ? c * (1 + b) : c + b - c * b;c = 2 * c - b;this.r = d(c, b, a + 1 / 3);this.g = d(c, b, a);this.b = d(c, b, a - 1 / 3);\n    }return this;\n  }, setStyle: function setStyle(a) {\n    if (/^rgb\\((\\d+), ?(\\d+), ?(\\d+)\\)$/i.test(a)) return a = /^rgb\\((\\d+), ?(\\d+), ?(\\d+)\\)$/i.exec(a), this.r = Math.min(255, parseInt(a[1], 10)) / 255, this.g = Math.min(255, parseInt(a[2], 10)) / 255, this.b = Math.min(255, parseInt(a[3], 10)) / 255, this;if (/^rgb\\((\\d+)\\%, ?(\\d+)\\%, ?(\\d+)\\%\\)$/i.test(a)) return a = /^rgb\\((\\d+)\\%, ?(\\d+)\\%, ?(\\d+)\\%\\)$/i.exec(a), this.r = Math.min(100, parseInt(a[1], 10)) / 100, this.g = Math.min(100, parseInt(a[2], 10)) / 100, this.b = Math.min(100, parseInt(a[3], 10)) / 100, this;if (/^\\#([0-9a-f]{6})$/i.test(a)) return a = /^\\#([0-9a-f]{6})$/i.exec(a), this.setHex(parseInt(a[1], 16)), this;if (/^\\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test(a)) return a = /^\\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(a), this.setHex(parseInt(a[1] + a[1] + a[2] + a[2] + a[3] + a[3], 16)), this;if (/^(\\w+)$/i.test(a)) return this.setHex(THREE.ColorKeywords[a]), this;\n  }, copy: function copy(a) {\n    this.r = a.r;this.g = a.g;this.b = a.b;return this;\n  }, copyGammaToLinear: function copyGammaToLinear(a, b) {\n    void 0 === b && (b = 2);this.r = Math.pow(a.r, b);this.g = Math.pow(a.g, b);this.b = Math.pow(a.b, b);return this;\n  }, copyLinearToGamma: function copyLinearToGamma(a, b) {\n    void 0 === b && (b = 2);var c = 0 < b ? 1 / b : 1;this.r = Math.pow(a.r, c);this.g = Math.pow(a.g, c);this.b = Math.pow(a.b, c);return this;\n  }, convertGammaToLinear: function convertGammaToLinear() {\n    var a = this.r,\n        b = this.g,\n        c = this.b;this.r = a * a;this.g = b * b;this.b = c * c;return this;\n  }, convertLinearToGamma: function convertLinearToGamma() {\n    this.r = Math.sqrt(this.r);this.g = Math.sqrt(this.g);this.b = Math.sqrt(this.b);return this;\n  }, getHex: function getHex() {\n    return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0;\n  }, getHexString: function getHexString() {\n    return (\"000000\" + this.getHex().toString(16)).slice(-6);\n  }, getHSL: function getHSL(a) {\n    a = a || { h: 0, s: 0, l: 0 };var b = this.r,\n        c = this.g,\n        d = this.b,\n        e = Math.max(b, c, d),\n        f = Math.min(b, c, d),\n        g,\n        h = (f + e) / 2;if (f === e) f = g = 0;else {\n      var k = e - f,\n          f = .5 >= h ? k / (e + f) : k / (2 - e - f);switch (e) {case b:\n          g = (c - d) / k + (c < d ? 6 : 0);break;case c:\n          g = (d - b) / k + 2;break;case d:\n          g = (b - c) / k + 4;}g /= 6;\n    }a.h = g;a.s = f;a.l = h;return a;\n  }, getStyle: function getStyle() {\n    return \"rgb(\" + (255 * this.r | 0) + \",\" + (255 * this.g | 0) + \",\" + (255 * this.b | 0) + \")\";\n  }, offsetHSL: function offsetHSL(a, b, c) {\n    var d = this.getHSL();d.h += a;d.s += b;d.l += c;this.setHSL(d.h, d.s, d.l);return this;\n  }, add: function add(a) {\n    this.r += a.r;this.g += a.g;this.b += a.b;return this;\n  }, addColors: function addColors(a, b) {\n    this.r = a.r + b.r;this.g = a.g + b.g;this.b = a.b + b.b;return this;\n  }, addScalar: function addScalar(a) {\n    this.r += a;this.g += a;this.b += a;return this;\n  }, multiply: function multiply(a) {\n    this.r *= a.r;this.g *= a.g;this.b *= a.b;return this;\n  }, multiplyScalar: function multiplyScalar(a) {\n    this.r *= a;this.g *= a;this.b *= a;\n    return this;\n  }, lerp: function lerp(a, b) {\n    this.r += (a.r - this.r) * b;this.g += (a.g - this.g) * b;this.b += (a.b - this.b) * b;return this;\n  }, equals: function equals(a) {\n    return a.r === this.r && a.g === this.g && a.b === this.b;\n  }, fromArray: function fromArray(a) {\n    this.r = a[0];this.g = a[1];this.b = a[2];return this;\n  }, toArray: function toArray(a, b) {\n    void 0 === a && (a = []);void 0 === b && (b = 0);a[b] = this.r;a[b + 1] = this.g;a[b + 2] = this.b;return a;\n  }, clone: function clone() {\n    return new THREE.Color().setRGB(this.r, this.g, this.b);\n  } };\nTHREE.ColorKeywords = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643,\n  darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055,\n  grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184,\n  lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130,\n  palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888,\n  tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 };THREE.Quaternion = function (a, b, c, d) {\n  this._x = a || 0;this._y = b || 0;this._z = c || 0;this._w = void 0 !== d ? d : 1;\n};\nTHREE.Quaternion.prototype = { constructor: THREE.Quaternion, _x: 0, _y: 0, _z: 0, _w: 0, get x() {\n    return this._x;\n  }, set x(a) {\n    this._x = a;this.onChangeCallback();\n  }, get y() {\n    return this._y;\n  }, set y(a) {\n    this._y = a;this.onChangeCallback();\n  }, get z() {\n    return this._z;\n  }, set z(a) {\n    this._z = a;this.onChangeCallback();\n  }, get w() {\n    return this._w;\n  }, set w(a) {\n    this._w = a;this.onChangeCallback();\n  }, set: function set(a, b, c, d) {\n    this._x = a;this._y = b;this._z = c;this._w = d;this.onChangeCallback();return this;\n  }, copy: function copy(a) {\n    this._x = a.x;this._y = a.y;this._z = a.z;\n    this._w = a.w;this.onChangeCallback();return this;\n  }, setFromEuler: function setFromEuler(a, b) {\n    if (!1 === a instanceof THREE.Euler) throw Error(\"THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.\");var c = Math.cos(a._x / 2),\n        d = Math.cos(a._y / 2),\n        e = Math.cos(a._z / 2),\n        f = Math.sin(a._x / 2),\n        g = Math.sin(a._y / 2),\n        h = Math.sin(a._z / 2);\"XYZ\" === a.order ? (this._x = f * d * e + c * g * h, this._y = c * g * e - f * d * h, this._z = c * d * h + f * g * e, this._w = c * d * e - f * g * h) : \"YXZ\" === a.order ? (this._x = f * d * e + c * g * h, this._y = c * g * e - f * d * h, this._z = c * d * h - f * g * e, this._w = c * d * e + f * g * h) : \"ZXY\" === a.order ? (this._x = f * d * e - c * g * h, this._y = c * g * e + f * d * h, this._z = c * d * h + f * g * e, this._w = c * d * e - f * g * h) : \"ZYX\" === a.order ? (this._x = f * d * e - c * g * h, this._y = c * g * e + f * d * h, this._z = c * d * h - f * g * e, this._w = c * d * e + f * g * h) : \"YZX\" === a.order ? (this._x = f * d * e + c * g * h, this._y = c * g * e + f * d * h, this._z = c * d * h - f * g * e, this._w = c * d * e - f * g * h) : \"XZY\" === a.order && (this._x = f * d * e - c * g * h, this._y = c * g * e - f * d * h, this._z = c * d * h + f * g * e, this._w = c * d * e + f * g * h);if (!1 !== b) this.onChangeCallback();return this;\n  }, setFromAxisAngle: function setFromAxisAngle(a, b) {\n    var c = b / 2,\n        d = Math.sin(c);this._x = a.x * d;this._y = a.y * d;this._z = a.z * d;this._w = Math.cos(c);this.onChangeCallback();return this;\n  }, setFromRotationMatrix: function setFromRotationMatrix(a) {\n    var b = a.elements,\n        c = b[0];a = b[4];var d = b[8],\n        e = b[1],\n        f = b[5],\n        g = b[9],\n        h = b[2],\n        k = b[6],\n        b = b[10],\n        l = c + f + b;0 < l ? (c = .5 / Math.sqrt(l + 1), this._w = .25 / c, this._x = (k - g) * c, this._y = (d - h) * c, this._z = (e - a) * c) : c > f && c > b ? (c = 2 * Math.sqrt(1 + c - f - b), this._w = (k - g) / c, this._x = .25 * c, this._y = (a + e) / c, this._z = (d + h) / c) : f > b ? (c = 2 * Math.sqrt(1 + f - c - b), this._w = (d - h) / c, this._x = (a + e) / c, this._y = .25 * c, this._z = (g + k) / c) : (c = 2 * Math.sqrt(1 + b - c - f), this._w = (e - a) / c, this._x = (d + h) / c, this._y = (g + k) / c, this._z = .25 * c);this.onChangeCallback();return this;\n  }, setFromUnitVectors: function () {\n    var a, b;return function (c, d) {\n      void 0 === a && (a = new THREE.Vector3());b = c.dot(d) + 1;1E-6 > b ? (b = 0, Math.abs(c.x) > Math.abs(c.z) ? a.set(-c.y, c.x, 0) : a.set(0, -c.z, c.y)) : a.crossVectors(c, d);this._x = a.x;this._y = a.y;this._z = a.z;this._w = b;this.normalize();return this;\n    };\n  }(), inverse: function inverse() {\n    this.conjugate().normalize();return this;\n  }, conjugate: function conjugate() {\n    this._x *= -1;this._y *= -1;this._z *= -1;this.onChangeCallback();return this;\n  }, dot: function dot(a) {\n    return this._x * a._x + this._y * a._y + this._z * a._z + this._w * a._w;\n  }, lengthSq: function lengthSq() {\n    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n  }, length: function length() {\n    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);\n  }, normalize: function normalize() {\n    var a = this.length();0 === a ? (this._z = this._y = this._x = 0, this._w = 1) : (a = 1 / a, this._x *= a, this._y *= a, this._z *= a, this._w *= a);this.onChangeCallback();return this;\n  },\n  multiply: function multiply(a, b) {\n    return void 0 !== b ? (THREE.warn(\"THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.\"), this.multiplyQuaternions(a, b)) : this.multiplyQuaternions(this, a);\n  }, multiplyQuaternions: function multiplyQuaternions(a, b) {\n    var c = a._x,\n        d = a._y,\n        e = a._z,\n        f = a._w,\n        g = b._x,\n        h = b._y,\n        k = b._z,\n        l = b._w;this._x = c * l + f * g + d * k - e * h;this._y = d * l + f * h + e * g - c * k;this._z = e * l + f * k + c * h - d * g;this._w = f * l - c * g - d * h - e * k;this.onChangeCallback();return this;\n  }, multiplyVector3: function multiplyVector3(a) {\n    THREE.warn(\"THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.\");\n    return a.applyQuaternion(this);\n  }, slerp: function slerp(a, b) {\n    if (0 === b) return this;if (1 === b) return this.copy(a);var c = this._x,\n        d = this._y,\n        e = this._z,\n        f = this._w,\n        g = f * a._w + c * a._x + d * a._y + e * a._z;0 > g ? (this._w = -a._w, this._x = -a._x, this._y = -a._y, this._z = -a._z, g = -g) : this.copy(a);if (1 <= g) return this._w = f, this._x = c, this._y = d, this._z = e, this;var h = Math.acos(g),\n        k = Math.sqrt(1 - g * g);if (.001 > Math.abs(k)) return this._w = .5 * (f + this._w), this._x = .5 * (c + this._x), this._y = .5 * (d + this._y), this._z = .5 * (e + this._z), this;g = Math.sin((1 - b) * h) / k;h = Math.sin(b * h) / k;this._w = f * g + this._w * h;this._x = c * g + this._x * h;this._y = d * g + this._y * h;this._z = e * g + this._z * h;this.onChangeCallback();return this;\n  }, equals: function equals(a) {\n    return a._x === this._x && a._y === this._y && a._z === this._z && a._w === this._w;\n  }, fromArray: function fromArray(a, b) {\n    void 0 === b && (b = 0);this._x = a[b];this._y = a[b + 1];this._z = a[b + 2];this._w = a[b + 3];this.onChangeCallback();return this;\n  }, toArray: function toArray(a, b) {\n    void 0 === a && (a = []);void 0 === b && (b = 0);a[b] = this._x;a[b + 1] = this._y;a[b + 2] = this._z;a[b + 3] = this._w;return a;\n  }, onChange: function onChange(a) {\n    this.onChangeCallback = a;return this;\n  }, onChangeCallback: function onChangeCallback() {}, clone: function clone() {\n    return new THREE.Quaternion(this._x, this._y, this._z, this._w);\n  } };THREE.Quaternion.slerp = function (a, b, c, d) {\n  return c.copy(a).slerp(b, d);\n};THREE.Vector2 = function (a, b) {\n  this.x = a || 0;this.y = b || 0;\n};\nTHREE.Vector2.prototype = { constructor: THREE.Vector2, set: function set(a, b) {\n    this.x = a;this.y = b;return this;\n  }, setX: function setX(a) {\n    this.x = a;return this;\n  }, setY: function setY(a) {\n    this.y = a;return this;\n  }, setComponent: function setComponent(a, b) {\n    switch (a) {case 0:\n        this.x = b;break;case 1:\n        this.y = b;break;default:\n        throw Error(\"index is out of range: \" + a);}\n  }, getComponent: function getComponent(a) {\n    switch (a) {case 0:\n        return this.x;case 1:\n        return this.y;default:\n        throw Error(\"index is out of range: \" + a);}\n  }, copy: function copy(a) {\n    this.x = a.x;this.y = a.y;return this;\n  }, add: function add(a, b) {\n    if (void 0 !== b) return THREE.warn(\"THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.\"), this.addVectors(a, b);this.x += a.x;this.y += a.y;return this;\n  }, addScalar: function addScalar(a) {\n    this.x += a;this.y += a;return this;\n  }, addVectors: function addVectors(a, b) {\n    this.x = a.x + b.x;this.y = a.y + b.y;return this;\n  }, sub: function sub(a, b) {\n    if (void 0 !== b) return THREE.warn(\"THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.\"), this.subVectors(a, b);this.x -= a.x;this.y -= a.y;return this;\n  },\n  subScalar: function subScalar(a) {\n    this.x -= a;this.y -= a;return this;\n  }, subVectors: function subVectors(a, b) {\n    this.x = a.x - b.x;this.y = a.y - b.y;return this;\n  }, multiply: function multiply(a) {\n    this.x *= a.x;this.y *= a.y;return this;\n  }, multiplyScalar: function multiplyScalar(a) {\n    this.x *= a;this.y *= a;return this;\n  }, divide: function divide(a) {\n    this.x /= a.x;this.y /= a.y;return this;\n  }, divideScalar: function divideScalar(a) {\n    0 !== a ? (a = 1 / a, this.x *= a, this.y *= a) : this.y = this.x = 0;return this;\n  }, min: function min(a) {\n    this.x > a.x && (this.x = a.x);this.y > a.y && (this.y = a.y);return this;\n  }, max: function max(a) {\n    this.x < a.x && (this.x = a.x);\n    this.y < a.y && (this.y = a.y);return this;\n  }, clamp: function clamp(a, b) {\n    this.x < a.x ? this.x = a.x : this.x > b.x && (this.x = b.x);this.y < a.y ? this.y = a.y : this.y > b.y && (this.y = b.y);return this;\n  }, clampScalar: function () {\n    var a, b;return function (c, d) {\n      void 0 === a && (a = new THREE.Vector2(), b = new THREE.Vector2());a.set(c, c);b.set(d, d);return this.clamp(a, b);\n    };\n  }(), floor: function floor() {\n    this.x = Math.floor(this.x);this.y = Math.floor(this.y);return this;\n  }, ceil: function ceil() {\n    this.x = Math.ceil(this.x);this.y = Math.ceil(this.y);return this;\n  }, round: function round() {\n    this.x = Math.round(this.x);this.y = Math.round(this.y);return this;\n  }, roundToZero: function roundToZero() {\n    this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);return this;\n  }, negate: function negate() {\n    this.x = -this.x;this.y = -this.y;return this;\n  }, dot: function dot(a) {\n    return this.x * a.x + this.y * a.y;\n  }, lengthSq: function lengthSq() {\n    return this.x * this.x + this.y * this.y;\n  }, length: function length() {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  }, normalize: function normalize() {\n    return this.divideScalar(this.length());\n  }, distanceTo: function distanceTo(a) {\n    return Math.sqrt(this.distanceToSquared(a));\n  },\n  distanceToSquared: function distanceToSquared(a) {\n    var b = this.x - a.x;a = this.y - a.y;return b * b + a * a;\n  }, setLength: function setLength(a) {\n    var b = this.length();0 !== b && a !== b && this.multiplyScalar(a / b);return this;\n  }, lerp: function lerp(a, b) {\n    this.x += (a.x - this.x) * b;this.y += (a.y - this.y) * b;return this;\n  }, lerpVectors: function lerpVectors(a, b, c) {\n    this.subVectors(b, a).multiplyScalar(c).add(a);return this;\n  }, equals: function equals(a) {\n    return a.x === this.x && a.y === this.y;\n  }, fromArray: function fromArray(a, b) {\n    void 0 === b && (b = 0);this.x = a[b];this.y = a[b + 1];return this;\n  }, toArray: function toArray(a, b) {\n    void 0 === a && (a = []);void 0 === b && (b = 0);a[b] = this.x;a[b + 1] = this.y;return a;\n  }, fromAttribute: function fromAttribute(a, b, c) {\n    void 0 === c && (c = 0);b = b * a.itemSize + c;this.x = a.array[b];this.y = a.array[b + 1];return this;\n  }, clone: function clone() {\n    return new THREE.Vector2(this.x, this.y);\n  } };THREE.Vector3 = function (a, b, c) {\n  this.x = a || 0;this.y = b || 0;this.z = c || 0;\n};\nTHREE.Vector3.prototype = { constructor: THREE.Vector3, set: function set(a, b, c) {\n    this.x = a;this.y = b;this.z = c;return this;\n  }, setX: function setX(a) {\n    this.x = a;return this;\n  }, setY: function setY(a) {\n    this.y = a;return this;\n  }, setZ: function setZ(a) {\n    this.z = a;return this;\n  }, setComponent: function setComponent(a, b) {\n    switch (a) {case 0:\n        this.x = b;break;case 1:\n        this.y = b;break;case 2:\n        this.z = b;break;default:\n        throw Error(\"index is out of range: \" + a);}\n  }, getComponent: function getComponent(a) {\n    switch (a) {case 0:\n        return this.x;case 1:\n        return this.y;case 2:\n        return this.z;default:\n        throw Error(\"index is out of range: \" + a);}\n  }, copy: function copy(a) {\n    this.x = a.x;this.y = a.y;this.z = a.z;return this;\n  }, add: function add(a, b) {\n    if (void 0 !== b) return THREE.warn(\"THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.\"), this.addVectors(a, b);this.x += a.x;this.y += a.y;this.z += a.z;return this;\n  }, addScalar: function addScalar(a) {\n    this.x += a;this.y += a;this.z += a;return this;\n  }, addVectors: function addVectors(a, b) {\n    this.x = a.x + b.x;this.y = a.y + b.y;this.z = a.z + b.z;return this;\n  }, sub: function sub(a, b) {\n    if (void 0 !== b) return THREE.warn(\"THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.\"), this.subVectors(a, b);this.x -= a.x;this.y -= a.y;this.z -= a.z;return this;\n  }, subScalar: function subScalar(a) {\n    this.x -= a;this.y -= a;this.z -= a;return this;\n  }, subVectors: function subVectors(a, b) {\n    this.x = a.x - b.x;this.y = a.y - b.y;this.z = a.z - b.z;return this;\n  }, multiply: function multiply(a, b) {\n    if (void 0 !== b) return THREE.warn(\"THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.\"), this.multiplyVectors(a, b);this.x *= a.x;this.y *= a.y;this.z *= a.z;return this;\n  }, multiplyScalar: function multiplyScalar(a) {\n    this.x *= a;this.y *= a;this.z *= a;return this;\n  }, multiplyVectors: function multiplyVectors(a, b) {\n    this.x = a.x * b.x;this.y = a.y * b.y;this.z = a.z * b.z;return this;\n  }, applyEuler: function () {\n    var a;return function (b) {\n      !1 === b instanceof THREE.Euler && THREE.error(\"THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.\");void 0 === a && (a = new THREE.Quaternion());this.applyQuaternion(a.setFromEuler(b));return this;\n    };\n  }(), applyAxisAngle: function () {\n    var a;return function (b, c) {\n      void 0 === a && (a = new THREE.Quaternion());this.applyQuaternion(a.setFromAxisAngle(b, c));return this;\n    };\n  }(), applyMatrix3: function applyMatrix3(a) {\n    var b = this.x,\n        c = this.y,\n        d = this.z;a = a.elements;this.x = a[0] * b + a[3] * c + a[6] * d;this.y = a[1] * b + a[4] * c + a[7] * d;this.z = a[2] * b + a[5] * c + a[8] * d;return this;\n  }, applyMatrix4: function applyMatrix4(a) {\n    var b = this.x,\n        c = this.y,\n        d = this.z;a = a.elements;this.x = a[0] * b + a[4] * c + a[8] * d + a[12];this.y = a[1] * b + a[5] * c + a[9] * d + a[13];this.z = a[2] * b + a[6] * c + a[10] * d + a[14];return this;\n  }, applyProjection: function applyProjection(a) {\n    var b = this.x,\n        c = this.y,\n        d = this.z;a = a.elements;var e = 1 / (a[3] * b + a[7] * c + a[11] * d + a[15]);this.x = (a[0] * b + a[4] * c + a[8] * d + a[12]) * e;this.y = (a[1] * b + a[5] * c + a[9] * d + a[13]) * e;this.z = (a[2] * b + a[6] * c + a[10] * d + a[14]) * e;return this;\n  }, applyQuaternion: function applyQuaternion(a) {\n    var b = this.x,\n        c = this.y,\n        d = this.z,\n        e = a.x,\n        f = a.y,\n        g = a.z;a = a.w;var h = a * b + f * d - g * c,\n        k = a * c + g * b - e * d,\n        l = a * d + e * c - f * b,\n        b = -e * b - f * c - g * d;this.x = h * a + b * -e + k * -g - l * -f;this.y = k * a + b * -f + l * -e - h * -g;this.z = l * a + b * -g + h * -f - k * -e;return this;\n  }, project: function () {\n    var a;return function (b) {\n      void 0 === a && (a = new THREE.Matrix4());a.multiplyMatrices(b.projectionMatrix, a.getInverse(b.matrixWorld));return this.applyProjection(a);\n    };\n  }(),\n  unproject: function () {\n    var a;return function (b) {\n      void 0 === a && (a = new THREE.Matrix4());a.multiplyMatrices(b.matrixWorld, a.getInverse(b.projectionMatrix));return this.applyProjection(a);\n    };\n  }(), transformDirection: function transformDirection(a) {\n    var b = this.x,\n        c = this.y,\n        d = this.z;a = a.elements;this.x = a[0] * b + a[4] * c + a[8] * d;this.y = a[1] * b + a[5] * c + a[9] * d;this.z = a[2] * b + a[6] * c + a[10] * d;this.normalize();return this;\n  }, divide: function divide(a) {\n    this.x /= a.x;this.y /= a.y;this.z /= a.z;return this;\n  }, divideScalar: function divideScalar(a) {\n    0 !== a ? (a = 1 / a, this.x *= a, this.y *= a, this.z *= a) : this.z = this.y = this.x = 0;return this;\n  }, min: function min(a) {\n    this.x > a.x && (this.x = a.x);this.y > a.y && (this.y = a.y);this.z > a.z && (this.z = a.z);return this;\n  }, max: function max(a) {\n    this.x < a.x && (this.x = a.x);this.y < a.y && (this.y = a.y);this.z < a.z && (this.z = a.z);return this;\n  }, clamp: function clamp(a, b) {\n    this.x < a.x ? this.x = a.x : this.x > b.x && (this.x = b.x);this.y < a.y ? this.y = a.y : this.y > b.y && (this.y = b.y);this.z < a.z ? this.z = a.z : this.z > b.z && (this.z = b.z);return this;\n  }, clampScalar: function () {\n    var a, b;return function (c, d) {\n      void 0 === a && (a = new THREE.Vector3(), b = new THREE.Vector3());a.set(c, c, c);b.set(d, d, d);return this.clamp(a, b);\n    };\n  }(), floor: function floor() {\n    this.x = Math.floor(this.x);this.y = Math.floor(this.y);this.z = Math.floor(this.z);return this;\n  }, ceil: function ceil() {\n    this.x = Math.ceil(this.x);this.y = Math.ceil(this.y);this.z = Math.ceil(this.z);return this;\n  }, round: function round() {\n    this.x = Math.round(this.x);this.y = Math.round(this.y);this.z = Math.round(this.z);return this;\n  }, roundToZero: function roundToZero() {\n    this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);return this;\n  }, negate: function negate() {\n    this.x = -this.x;this.y = -this.y;this.z = -this.z;return this;\n  }, dot: function dot(a) {\n    return this.x * a.x + this.y * a.y + this.z * a.z;\n  }, lengthSq: function lengthSq() {\n    return this.x * this.x + this.y * this.y + this.z * this.z;\n  }, length: function length() {\n    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n  }, lengthManhattan: function lengthManhattan() {\n    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);\n  }, normalize: function normalize() {\n    return this.divideScalar(this.length());\n  },\n  setLength: function setLength(a) {\n    var b = this.length();0 !== b && a !== b && this.multiplyScalar(a / b);return this;\n  }, lerp: function lerp(a, b) {\n    this.x += (a.x - this.x) * b;this.y += (a.y - this.y) * b;this.z += (a.z - this.z) * b;return this;\n  }, lerpVectors: function lerpVectors(a, b, c) {\n    this.subVectors(b, a).multiplyScalar(c).add(a);return this;\n  }, cross: function cross(a, b) {\n    if (void 0 !== b) return THREE.warn(\"THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.\"), this.crossVectors(a, b);var c = this.x,\n        d = this.y,\n        e = this.z;this.x = d * a.z - e * a.y;this.y = e * a.x - c * a.z;this.z = c * a.y - d * a.x;return this;\n  }, crossVectors: function crossVectors(a, b) {\n    var c = a.x,\n        d = a.y,\n        e = a.z,\n        f = b.x,\n        g = b.y,\n        h = b.z;this.x = d * h - e * g;this.y = e * f - c * h;this.z = c * g - d * f;return this;\n  }, projectOnVector: function () {\n    var a, b;return function (c) {\n      void 0 === a && (a = new THREE.Vector3());a.copy(c).normalize();b = this.dot(a);return this.copy(a).multiplyScalar(b);\n    };\n  }(), projectOnPlane: function () {\n    var a;return function (b) {\n      void 0 === a && (a = new THREE.Vector3());a.copy(this).projectOnVector(b);return this.sub(a);\n    };\n  }(), reflect: function () {\n    var a;return function (b) {\n      void 0 === a && (a = new THREE.Vector3());return this.sub(a.copy(b).multiplyScalar(2 * this.dot(b)));\n    };\n  }(), angleTo: function angleTo(a) {\n    a = this.dot(a) / (this.length() * a.length());return Math.acos(THREE.Math.clamp(a, -1, 1));\n  }, distanceTo: function distanceTo(a) {\n    return Math.sqrt(this.distanceToSquared(a));\n  }, distanceToSquared: function distanceToSquared(a) {\n    var b = this.x - a.x,\n        c = this.y - a.y;a = this.z - a.z;return b * b + c * c + a * a;\n  }, setEulerFromRotationMatrix: function setEulerFromRotationMatrix(a, b) {\n    THREE.error(\"THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.\");\n  },\n  setEulerFromQuaternion: function setEulerFromQuaternion(a, b) {\n    THREE.error(\"THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.\");\n  }, getPositionFromMatrix: function getPositionFromMatrix(a) {\n    THREE.warn(\"THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().\");return this.setFromMatrixPosition(a);\n  }, getScaleFromMatrix: function getScaleFromMatrix(a) {\n    THREE.warn(\"THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().\");return this.setFromMatrixScale(a);\n  }, getColumnFromMatrix: function getColumnFromMatrix(a, b) {\n    THREE.warn(\"THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().\");return this.setFromMatrixColumn(a, b);\n  }, setFromMatrixPosition: function setFromMatrixPosition(a) {\n    this.x = a.elements[12];this.y = a.elements[13];this.z = a.elements[14];return this;\n  }, setFromMatrixScale: function setFromMatrixScale(a) {\n    var b = this.set(a.elements[0], a.elements[1], a.elements[2]).length(),\n        c = this.set(a.elements[4], a.elements[5], a.elements[6]).length();a = this.set(a.elements[8], a.elements[9], a.elements[10]).length();this.x = b;this.y = c;this.z = a;\n    return this;\n  }, setFromMatrixColumn: function setFromMatrixColumn(a, b) {\n    var c = 4 * a,\n        d = b.elements;this.x = d[c];this.y = d[c + 1];this.z = d[c + 2];return this;\n  }, equals: function equals(a) {\n    return a.x === this.x && a.y === this.y && a.z === this.z;\n  }, fromArray: function fromArray(a, b) {\n    void 0 === b && (b = 0);this.x = a[b];this.y = a[b + 1];this.z = a[b + 2];return this;\n  }, toArray: function toArray(a, b) {\n    void 0 === a && (a = []);void 0 === b && (b = 0);a[b] = this.x;a[b + 1] = this.y;a[b + 2] = this.z;return a;\n  }, fromAttribute: function fromAttribute(a, b, c) {\n    void 0 === c && (c = 0);b = b * a.itemSize + c;this.x = a.array[b];this.y = a.array[b + 1];this.z = a.array[b + 2];return this;\n  }, clone: function clone() {\n    return new THREE.Vector3(this.x, this.y, this.z);\n  } };THREE.Vector4 = function (a, b, c, d) {\n  this.x = a || 0;this.y = b || 0;this.z = c || 0;this.w = void 0 !== d ? d : 1;\n};\nTHREE.Vector4.prototype = { constructor: THREE.Vector4, set: function set(a, b, c, d) {\n    this.x = a;this.y = b;this.z = c;this.w = d;return this;\n  }, setX: function setX(a) {\n    this.x = a;return this;\n  }, setY: function setY(a) {\n    this.y = a;return this;\n  }, setZ: function setZ(a) {\n    this.z = a;return this;\n  }, setW: function setW(a) {\n    this.w = a;return this;\n  }, setComponent: function setComponent(a, b) {\n    switch (a) {case 0:\n        this.x = b;break;case 1:\n        this.y = b;break;case 2:\n        this.z = b;break;case 3:\n        this.w = b;break;default:\n        throw Error(\"index is out of range: \" + a);}\n  }, getComponent: function getComponent(a) {\n    switch (a) {case 0:\n        return this.x;\n      case 1:\n        return this.y;case 2:\n        return this.z;case 3:\n        return this.w;default:\n        throw Error(\"index is out of range: \" + a);}\n  }, copy: function copy(a) {\n    this.x = a.x;this.y = a.y;this.z = a.z;this.w = void 0 !== a.w ? a.w : 1;return this;\n  }, add: function add(a, b) {\n    if (void 0 !== b) return THREE.warn(\"THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.\"), this.addVectors(a, b);this.x += a.x;this.y += a.y;this.z += a.z;this.w += a.w;return this;\n  }, addScalar: function addScalar(a) {\n    this.x += a;this.y += a;this.z += a;this.w += a;return this;\n  }, addVectors: function addVectors(a, b) {\n    this.x = a.x + b.x;this.y = a.y + b.y;this.z = a.z + b.z;this.w = a.w + b.w;return this;\n  }, sub: function sub(a, b) {\n    if (void 0 !== b) return THREE.warn(\"THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.\"), this.subVectors(a, b);this.x -= a.x;this.y -= a.y;this.z -= a.z;this.w -= a.w;return this;\n  }, subScalar: function subScalar(a) {\n    this.x -= a;this.y -= a;this.z -= a;this.w -= a;return this;\n  }, subVectors: function subVectors(a, b) {\n    this.x = a.x - b.x;this.y = a.y - b.y;this.z = a.z - b.z;this.w = a.w - b.w;return this;\n  }, multiplyScalar: function multiplyScalar(a) {\n    this.x *= a;this.y *= a;this.z *= a;this.w *= a;return this;\n  }, applyMatrix4: function applyMatrix4(a) {\n    var b = this.x,\n        c = this.y,\n        d = this.z,\n        e = this.w;a = a.elements;this.x = a[0] * b + a[4] * c + a[8] * d + a[12] * e;this.y = a[1] * b + a[5] * c + a[9] * d + a[13] * e;this.z = a[2] * b + a[6] * c + a[10] * d + a[14] * e;this.w = a[3] * b + a[7] * c + a[11] * d + a[15] * e;return this;\n  }, divideScalar: function divideScalar(a) {\n    0 !== a ? (a = 1 / a, this.x *= a, this.y *= a, this.z *= a, this.w *= a) : (this.z = this.y = this.x = 0, this.w = 1);return this;\n  }, setAxisAngleFromQuaternion: function setAxisAngleFromQuaternion(a) {\n    this.w = 2 * Math.acos(a.w);var b = Math.sqrt(1 - a.w * a.w);1E-4 > b ? (this.x = 1, this.z = this.y = 0) : (this.x = a.x / b, this.y = a.y / b, this.z = a.z / b);return this;\n  }, setAxisAngleFromRotationMatrix: function setAxisAngleFromRotationMatrix(a) {\n    var b, c, d;a = a.elements;var e = a[0];d = a[4];var f = a[8],\n        g = a[1],\n        h = a[5],\n        k = a[9];c = a[2];b = a[6];var l = a[10];if (.01 > Math.abs(d - g) && .01 > Math.abs(f - c) && .01 > Math.abs(k - b)) {\n      if (.1 > Math.abs(d + g) && .1 > Math.abs(f + c) && .1 > Math.abs(k + b) && .1 > Math.abs(e + h + l - 3)) return this.set(1, 0, 0, 0), this;a = Math.PI;e = (e + 1) / 2;h = (h + 1) / 2;l = (l + 1) / 2;d = (d + g) / 4;f = (f + c) / 4;k = (k + b) / 4;e > h && e > l ? .01 > e ? (b = 0, d = c = .707106781) : (b = Math.sqrt(e), c = d / b, d = f / b) : h > l ? .01 > h ? (b = .707106781, c = 0, d = .707106781) : (c = Math.sqrt(h), b = d / c, d = k / c) : .01 > l ? (c = b = .707106781, d = 0) : (d = Math.sqrt(l), b = f / d, c = k / d);this.set(b, c, d, a);return this;\n    }a = Math.sqrt((b - k) * (b - k) + (f - c) * (f - c) + (g - d) * (g - d));.001 > Math.abs(a) && (a = 1);this.x = (b - k) / a;this.y = (f - c) / a;this.z = (g - d) / a;this.w = Math.acos((e + h + l - 1) / 2);return this;\n  }, min: function min(a) {\n    this.x > a.x && (this.x = a.x);this.y > a.y && (this.y = a.y);this.z > a.z && (this.z = a.z);this.w > a.w && (this.w = a.w);return this;\n  }, max: function max(a) {\n    this.x < a.x && (this.x = a.x);this.y < a.y && (this.y = a.y);this.z < a.z && (this.z = a.z);this.w < a.w && (this.w = a.w);return this;\n  }, clamp: function clamp(a, b) {\n    this.x < a.x ? this.x = a.x : this.x > b.x && (this.x = b.x);this.y < a.y ? this.y = a.y : this.y > b.y && (this.y = b.y);this.z < a.z ? this.z = a.z : this.z > b.z && (this.z = b.z);this.w < a.w ? this.w = a.w : this.w > b.w && (this.w = b.w);return this;\n  }, clampScalar: function () {\n    var a, b;return function (c, d) {\n      void 0 === a && (a = new THREE.Vector4(), b = new THREE.Vector4());a.set(c, c, c, c);b.set(d, d, d, d);return this.clamp(a, b);\n    };\n  }(), floor: function floor() {\n    this.x = Math.floor(this.x);this.y = Math.floor(this.y);this.z = Math.floor(this.z);this.w = Math.floor(this.w);return this;\n  }, ceil: function ceil() {\n    this.x = Math.ceil(this.x);this.y = Math.ceil(this.y);this.z = Math.ceil(this.z);this.w = Math.ceil(this.w);return this;\n  }, round: function round() {\n    this.x = Math.round(this.x);this.y = Math.round(this.y);this.z = Math.round(this.z);this.w = Math.round(this.w);return this;\n  }, roundToZero: function roundToZero() {\n    this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);\n    this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w);return this;\n  }, negate: function negate() {\n    this.x = -this.x;this.y = -this.y;this.z = -this.z;this.w = -this.w;return this;\n  }, dot: function dot(a) {\n    return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w;\n  }, lengthSq: function lengthSq() {\n    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n  }, length: function length() {\n    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n  }, lengthManhattan: function lengthManhattan() {\n    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);\n  }, normalize: function normalize() {\n    return this.divideScalar(this.length());\n  }, setLength: function setLength(a) {\n    var b = this.length();0 !== b && a !== b && this.multiplyScalar(a / b);return this;\n  }, lerp: function lerp(a, b) {\n    this.x += (a.x - this.x) * b;this.y += (a.y - this.y) * b;this.z += (a.z - this.z) * b;this.w += (a.w - this.w) * b;return this;\n  }, lerpVectors: function lerpVectors(a, b, c) {\n    this.subVectors(b, a).multiplyScalar(c).add(a);return this;\n  }, equals: function equals(a) {\n    return a.x === this.x && a.y === this.y && a.z === this.z && a.w === this.w;\n  },\n  fromArray: function fromArray(a, b) {\n    void 0 === b && (b = 0);this.x = a[b];this.y = a[b + 1];this.z = a[b + 2];this.w = a[b + 3];return this;\n  }, toArray: function toArray(a, b) {\n    void 0 === a && (a = []);void 0 === b && (b = 0);a[b] = this.x;a[b + 1] = this.y;a[b + 2] = this.z;a[b + 3] = this.w;return a;\n  }, fromAttribute: function fromAttribute(a, b, c) {\n    void 0 === c && (c = 0);b = b * a.itemSize + c;this.x = a.array[b];this.y = a.array[b + 1];this.z = a.array[b + 2];this.w = a.array[b + 3];return this;\n  }, clone: function clone() {\n    return new THREE.Vector4(this.x, this.y, this.z, this.w);\n  } };\nTHREE.Euler = function (a, b, c, d) {\n  this._x = a || 0;this._y = b || 0;this._z = c || 0;this._order = d || THREE.Euler.DefaultOrder;\n};THREE.Euler.RotationOrders = \"XYZ YZX ZXY XZY YXZ ZYX\".split(\" \");THREE.Euler.DefaultOrder = \"XYZ\";\nTHREE.Euler.prototype = { constructor: THREE.Euler, _x: 0, _y: 0, _z: 0, _order: THREE.Euler.DefaultOrder, get x() {\n    return this._x;\n  }, set x(a) {\n    this._x = a;this.onChangeCallback();\n  }, get y() {\n    return this._y;\n  }, set y(a) {\n    this._y = a;this.onChangeCallback();\n  }, get z() {\n    return this._z;\n  }, set z(a) {\n    this._z = a;this.onChangeCallback();\n  }, get order() {\n    return this._order;\n  }, set order(a) {\n    this._order = a;this.onChangeCallback();\n  }, set: function set(a, b, c, d) {\n    this._x = a;this._y = b;this._z = c;this._order = d || this._order;this.onChangeCallback();return this;\n  }, copy: function copy(a) {\n    this._x = a._x;this._y = a._y;this._z = a._z;this._order = a._order;this.onChangeCallback();return this;\n  }, setFromRotationMatrix: function setFromRotationMatrix(a, b, c) {\n    var d = THREE.Math.clamp,\n        e = a.elements;a = e[0];var f = e[4],\n        g = e[8],\n        h = e[1],\n        k = e[5],\n        l = e[9],\n        p = e[2],\n        q = e[6],\n        e = e[10];b = b || this._order;\"XYZ\" === b ? (this._y = Math.asin(d(g, -1, 1)), .99999 > Math.abs(g) ? (this._x = Math.atan2(-l, e), this._z = Math.atan2(-f, a)) : (this._x = Math.atan2(q, k), this._z = 0)) : \"YXZ\" === b ? (this._x = Math.asin(-d(l, -1, 1)), .99999 > Math.abs(l) ? (this._y = Math.atan2(g, e), this._z = Math.atan2(h, k)) : (this._y = Math.atan2(-p, a), this._z = 0)) : \"ZXY\" === b ? (this._x = Math.asin(d(q, -1, 1)), .99999 > Math.abs(q) ? (this._y = Math.atan2(-p, e), this._z = Math.atan2(-f, k)) : (this._y = 0, this._z = Math.atan2(h, a))) : \"ZYX\" === b ? (this._y = Math.asin(-d(p, -1, 1)), .99999 > Math.abs(p) ? (this._x = Math.atan2(q, e), this._z = Math.atan2(h, a)) : (this._x = 0, this._z = Math.atan2(-f, k))) : \"YZX\" === b ? (this._z = Math.asin(d(h, -1, 1)), .99999 > Math.abs(h) ? (this._x = Math.atan2(-l, k), this._y = Math.atan2(-p, a)) : (this._x = 0, this._y = Math.atan2(g, e))) : \"XZY\" === b ? (this._z = Math.asin(-d(f, -1, 1)), .99999 > Math.abs(f) ? (this._x = Math.atan2(q, k), this._y = Math.atan2(g, a)) : (this._x = Math.atan2(-l, e), this._y = 0)) : THREE.warn(\"THREE.Euler: .setFromRotationMatrix() given unsupported order: \" + b);this._order = b;if (!1 !== c) this.onChangeCallback();return this;\n  }, setFromQuaternion: function () {\n    var a;return function (b, c, d) {\n      void 0 === a && (a = new THREE.Matrix4());a.makeRotationFromQuaternion(b);this.setFromRotationMatrix(a, c, d);return this;\n    };\n  }(), setFromVector3: function setFromVector3(a, b) {\n    return this.set(a.x, a.y, a.z, b || this._order);\n  }, reorder: function () {\n    var a = new THREE.Quaternion();return function (b) {\n      a.setFromEuler(this);this.setFromQuaternion(a, b);\n    };\n  }(), equals: function equals(a) {\n    return a._x === this._x && a._y === this._y && a._z === this._z && a._order === this._order;\n  }, fromArray: function fromArray(a) {\n    this._x = a[0];this._y = a[1];this._z = a[2];void 0 !== a[3] && (this._order = a[3]);this.onChangeCallback();return this;\n  }, toArray: function toArray(a, b) {\n    void 0 === a && (a = []);void 0 === b && (b = 0);a[b] = this._x;a[b + 1] = this._y;a[b + 2] = this._z;a[b + 3] = this._order;return a;\n  }, toVector3: function toVector3(a) {\n    return a ? a.set(this._x, this._y, this._z) : new THREE.Vector3(this._x, this._y, this._z);\n  }, onChange: function onChange(a) {\n    this.onChangeCallback = a;return this;\n  }, onChangeCallback: function onChangeCallback() {}, clone: function clone() {\n    return new THREE.Euler(this._x, this._y, this._z, this._order);\n  } };THREE.Line3 = function (a, b) {\n  this.start = void 0 !== a ? a : new THREE.Vector3();this.end = void 0 !== b ? b : new THREE.Vector3();\n};\nTHREE.Line3.prototype = { constructor: THREE.Line3, set: function set(a, b) {\n    this.start.copy(a);this.end.copy(b);return this;\n  }, copy: function copy(a) {\n    this.start.copy(a.start);this.end.copy(a.end);return this;\n  }, center: function center(a) {\n    return (a || new THREE.Vector3()).addVectors(this.start, this.end).multiplyScalar(.5);\n  }, delta: function delta(a) {\n    return (a || new THREE.Vector3()).subVectors(this.end, this.start);\n  }, distanceSq: function distanceSq() {\n    return this.start.distanceToSquared(this.end);\n  }, distance: function distance() {\n    return this.start.distanceTo(this.end);\n  }, at: function at(a, b) {\n    var c = b || new THREE.Vector3();return this.delta(c).multiplyScalar(a).add(this.start);\n  }, closestPointToPointParameter: function () {\n    var a = new THREE.Vector3(),\n        b = new THREE.Vector3();return function (c, d) {\n      a.subVectors(c, this.start);b.subVectors(this.end, this.start);var e = b.dot(b),\n          e = b.dot(a) / e;d && (e = THREE.Math.clamp(e, 0, 1));return e;\n    };\n  }(), closestPointToPoint: function closestPointToPoint(a, b, c) {\n    a = this.closestPointToPointParameter(a, b);c = c || new THREE.Vector3();return this.delta(c).multiplyScalar(a).add(this.start);\n  }, applyMatrix4: function applyMatrix4(a) {\n    this.start.applyMatrix4(a);\n    this.end.applyMatrix4(a);return this;\n  }, equals: function equals(a) {\n    return a.start.equals(this.start) && a.end.equals(this.end);\n  }, clone: function clone() {\n    return new THREE.Line3().copy(this);\n  } };THREE.Box2 = function (a, b) {\n  this.min = void 0 !== a ? a : new THREE.Vector2(Infinity, Infinity);this.max = void 0 !== b ? b : new THREE.Vector2(-Infinity, -Infinity);\n};\nTHREE.Box2.prototype = { constructor: THREE.Box2, set: function set(a, b) {\n    this.min.copy(a);this.max.copy(b);return this;\n  }, setFromPoints: function setFromPoints(a) {\n    this.makeEmpty();for (var b = 0, c = a.length; b < c; b++) {\n      this.expandByPoint(a[b]);\n    }return this;\n  }, setFromCenterAndSize: function () {\n    var a = new THREE.Vector2();return function (b, c) {\n      var d = a.copy(c).multiplyScalar(.5);this.min.copy(b).sub(d);this.max.copy(b).add(d);return this;\n    };\n  }(), copy: function copy(a) {\n    this.min.copy(a.min);this.max.copy(a.max);return this;\n  }, makeEmpty: function makeEmpty() {\n    this.min.x = this.min.y = Infinity;this.max.x = this.max.y = -Infinity;return this;\n  }, empty: function empty() {\n    return this.max.x < this.min.x || this.max.y < this.min.y;\n  }, center: function center(a) {\n    return (a || new THREE.Vector2()).addVectors(this.min, this.max).multiplyScalar(.5);\n  }, size: function size(a) {\n    return (a || new THREE.Vector2()).subVectors(this.max, this.min);\n  }, expandByPoint: function expandByPoint(a) {\n    this.min.min(a);this.max.max(a);return this;\n  }, expandByVector: function expandByVector(a) {\n    this.min.sub(a);this.max.add(a);return this;\n  }, expandByScalar: function expandByScalar(a) {\n    this.min.addScalar(-a);\n    this.max.addScalar(a);return this;\n  }, containsPoint: function containsPoint(a) {\n    return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y ? !1 : !0;\n  }, containsBox: function containsBox(a) {\n    return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y ? !0 : !1;\n  }, getParameter: function getParameter(a, b) {\n    return (b || new THREE.Vector2()).set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y));\n  }, isIntersectionBox: function isIntersectionBox(a) {\n    return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y ? !1 : !0;\n  }, clampPoint: function clampPoint(a, b) {\n    return (b || new THREE.Vector2()).copy(a).clamp(this.min, this.max);\n  }, distanceToPoint: function () {\n    var a = new THREE.Vector2();return function (b) {\n      return a.copy(b).clamp(this.min, this.max).sub(b).length();\n    };\n  }(), intersect: function intersect(a) {\n    this.min.max(a.min);this.max.min(a.max);return this;\n  }, union: function union(a) {\n    this.min.min(a.min);this.max.max(a.max);return this;\n  }, translate: function translate(a) {\n    this.min.add(a);this.max.add(a);return this;\n  }, equals: function equals(a) {\n    return a.min.equals(this.min) && a.max.equals(this.max);\n  }, clone: function clone() {\n    return new THREE.Box2().copy(this);\n  } };THREE.Box3 = function (a, b) {\n  this.min = void 0 !== a ? a : new THREE.Vector3(Infinity, Infinity, Infinity);this.max = void 0 !== b ? b : new THREE.Vector3(-Infinity, -Infinity, -Infinity);\n};\nTHREE.Box3.prototype = { constructor: THREE.Box3, set: function set(a, b) {\n    this.min.copy(a);this.max.copy(b);return this;\n  }, setFromPoints: function setFromPoints(a) {\n    this.makeEmpty();for (var b = 0, c = a.length; b < c; b++) {\n      this.expandByPoint(a[b]);\n    }return this;\n  }, setFromCenterAndSize: function () {\n    var a = new THREE.Vector3();return function (b, c) {\n      var d = a.copy(c).multiplyScalar(.5);this.min.copy(b).sub(d);this.max.copy(b).add(d);return this;\n    };\n  }(), setFromObject: function () {\n    var a = new THREE.Vector3();return function (b) {\n      var c = this;b.updateMatrixWorld(!0);\n      this.makeEmpty();b.traverse(function (b) {\n        var e = b.geometry;if (void 0 !== e) if (e instanceof THREE.Geometry) for (var f = e.vertices, e = 0, g = f.length; e < g; e++) {\n          a.copy(f[e]), a.applyMatrix4(b.matrixWorld), c.expandByPoint(a);\n        } else if (e instanceof THREE.BufferGeometry && void 0 !== e.attributes.position) for (f = e.attributes.position.array, e = 0, g = f.length; e < g; e += 3) {\n          a.set(f[e], f[e + 1], f[e + 2]), a.applyMatrix4(b.matrixWorld), c.expandByPoint(a);\n        }\n      });return this;\n    };\n  }(), copy: function copy(a) {\n    this.min.copy(a.min);this.max.copy(a.max);return this;\n  },\n  makeEmpty: function makeEmpty() {\n    this.min.x = this.min.y = this.min.z = Infinity;this.max.x = this.max.y = this.max.z = -Infinity;return this;\n  }, empty: function empty() {\n    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;\n  }, center: function center(a) {\n    return (a || new THREE.Vector3()).addVectors(this.min, this.max).multiplyScalar(.5);\n  }, size: function size(a) {\n    return (a || new THREE.Vector3()).subVectors(this.max, this.min);\n  }, expandByPoint: function expandByPoint(a) {\n    this.min.min(a);this.max.max(a);return this;\n  }, expandByVector: function expandByVector(a) {\n    this.min.sub(a);\n    this.max.add(a);return this;\n  }, expandByScalar: function expandByScalar(a) {\n    this.min.addScalar(-a);this.max.addScalar(a);return this;\n  }, containsPoint: function containsPoint(a) {\n    return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y || a.z < this.min.z || a.z > this.max.z ? !1 : !0;\n  }, containsBox: function containsBox(a) {\n    return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y && this.min.z <= a.min.z && a.max.z <= this.max.z ? !0 : !1;\n  }, getParameter: function getParameter(a, b) {\n    return (b || new THREE.Vector3()).set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y), (a.z - this.min.z) / (this.max.z - this.min.z));\n  }, isIntersectionBox: function isIntersectionBox(a) {\n    return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y || a.max.z < this.min.z || a.min.z > this.max.z ? !1 : !0;\n  }, clampPoint: function clampPoint(a, b) {\n    return (b || new THREE.Vector3()).copy(a).clamp(this.min, this.max);\n  }, distanceToPoint: function () {\n    var a = new THREE.Vector3();return function (b) {\n      return a.copy(b).clamp(this.min, this.max).sub(b).length();\n    };\n  }(), getBoundingSphere: function () {\n    var a = new THREE.Vector3();return function (b) {\n      b = b || new THREE.Sphere();b.center = this.center();b.radius = .5 * this.size(a).length();return b;\n    };\n  }(), intersect: function intersect(a) {\n    this.min.max(a.min);this.max.min(a.max);return this;\n  }, union: function union(a) {\n    this.min.min(a.min);this.max.max(a.max);return this;\n  }, applyMatrix4: function () {\n    var a = [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()];return function (b) {\n      a[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(b);a[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(b);a[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(b);a[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(b);a[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(b);a[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(b);a[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(b);a[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(b);this.makeEmpty();this.setFromPoints(a);return this;\n    };\n  }(), translate: function translate(a) {\n    this.min.add(a);\n    this.max.add(a);return this;\n  }, equals: function equals(a) {\n    return a.min.equals(this.min) && a.max.equals(this.max);\n  }, clone: function clone() {\n    return new THREE.Box3().copy(this);\n  } };THREE.Matrix3 = function () {\n  this.elements = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);0 < arguments.length && THREE.error(\"THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.\");\n};\nTHREE.Matrix3.prototype = { constructor: THREE.Matrix3, set: function set(a, b, c, d, e, f, g, h, k) {\n    var l = this.elements;l[0] = a;l[3] = b;l[6] = c;l[1] = d;l[4] = e;l[7] = f;l[2] = g;l[5] = h;l[8] = k;return this;\n  }, identity: function identity() {\n    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);return this;\n  }, copy: function copy(a) {\n    a = a.elements;this.set(a[0], a[3], a[6], a[1], a[4], a[7], a[2], a[5], a[8]);return this;\n  }, multiplyVector3: function multiplyVector3(a) {\n    THREE.warn(\"THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.\");return a.applyMatrix3(this);\n  },\n  multiplyVector3Array: function multiplyVector3Array(a) {\n    THREE.warn(\"THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.\");return this.applyToVector3Array(a);\n  }, applyToVector3Array: function () {\n    var a = new THREE.Vector3();return function (b, c, d) {\n      void 0 === c && (c = 0);void 0 === d && (d = b.length);for (var e = 0; e < d; e += 3, c += 3) {\n        a.x = b[c], a.y = b[c + 1], a.z = b[c + 2], a.applyMatrix3(this), b[c] = a.x, b[c + 1] = a.y, b[c + 2] = a.z;\n      }return b;\n    };\n  }(), multiplyScalar: function multiplyScalar(a) {\n    var b = this.elements;b[0] *= a;b[3] *= a;b[6] *= a;b[1] *= a;b[4] *= a;b[7] *= a;b[2] *= a;b[5] *= a;b[8] *= a;return this;\n  }, determinant: function determinant() {\n    var a = this.elements,\n        b = a[0],\n        c = a[1],\n        d = a[2],\n        e = a[3],\n        f = a[4],\n        g = a[5],\n        h = a[6],\n        k = a[7],\n        a = a[8];return b * f * a - b * g * k - c * e * a + c * g * h + d * e * k - d * f * h;\n  }, getInverse: function getInverse(a, b) {\n    var c = a.elements,\n        d = this.elements;d[0] = c[10] * c[5] - c[6] * c[9];d[1] = -c[10] * c[1] + c[2] * c[9];d[2] = c[6] * c[1] - c[2] * c[5];d[3] = -c[10] * c[4] + c[6] * c[8];d[4] = c[10] * c[0] - c[2] * c[8];d[5] = -c[6] * c[0] + c[2] * c[4];d[6] = c[9] * c[4] - c[5] * c[8];d[7] = -c[9] * c[0] + c[1] * c[8];d[8] = c[5] * c[0] - c[1] * c[4];\n    c = c[0] * d[0] + c[1] * d[3] + c[2] * d[6];if (0 === c) {\n      if (b) throw Error(\"Matrix3.getInverse(): can't invert matrix, determinant is 0\");THREE.warn(\"Matrix3.getInverse(): can't invert matrix, determinant is 0\");this.identity();return this;\n    }this.multiplyScalar(1 / c);return this;\n  }, transpose: function transpose() {\n    var a,\n        b = this.elements;a = b[1];b[1] = b[3];b[3] = a;a = b[2];b[2] = b[6];b[6] = a;a = b[5];b[5] = b[7];b[7] = a;return this;\n  }, flattenToArrayOffset: function flattenToArrayOffset(a, b) {\n    var c = this.elements;a[b] = c[0];a[b + 1] = c[1];a[b + 2] = c[2];a[b + 3] = c[3];a[b + 4] = c[4];\n    a[b + 5] = c[5];a[b + 6] = c[6];a[b + 7] = c[7];a[b + 8] = c[8];return a;\n  }, getNormalMatrix: function getNormalMatrix(a) {\n    this.getInverse(a).transpose();return this;\n  }, transposeIntoArray: function transposeIntoArray(a) {\n    var b = this.elements;a[0] = b[0];a[1] = b[3];a[2] = b[6];a[3] = b[1];a[4] = b[4];a[5] = b[7];a[6] = b[2];a[7] = b[5];a[8] = b[8];return this;\n  }, fromArray: function fromArray(a) {\n    this.elements.set(a);return this;\n  }, toArray: function toArray() {\n    var a = this.elements;return [a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]];\n  }, clone: function clone() {\n    return new THREE.Matrix3().fromArray(this.elements);\n  } };\nTHREE.Matrix4 = function () {\n  this.elements = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);0 < arguments.length && THREE.error(\"THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.\");\n};\nTHREE.Matrix4.prototype = { constructor: THREE.Matrix4, set: function set(a, b, c, d, e, f, g, h, k, l, p, q, n, t, r, s) {\n    var u = this.elements;u[0] = a;u[4] = b;u[8] = c;u[12] = d;u[1] = e;u[5] = f;u[9] = g;u[13] = h;u[2] = k;u[6] = l;u[10] = p;u[14] = q;u[3] = n;u[7] = t;u[11] = r;u[15] = s;return this;\n  }, identity: function identity() {\n    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);return this;\n  }, copy: function copy(a) {\n    this.elements.set(a.elements);return this;\n  }, extractPosition: function extractPosition(a) {\n    THREE.warn(\"THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().\");return this.copyPosition(a);\n  },\n  copyPosition: function copyPosition(a) {\n    var b = this.elements;a = a.elements;b[12] = a[12];b[13] = a[13];b[14] = a[14];return this;\n  }, extractBasis: function extractBasis(a, b, c) {\n    var d = this.elements;a.set(d[0], d[1], d[2]);b.set(d[4], d[5], d[6]);c.set(d[8], d[9], d[10]);return this;\n  }, makeBasis: function makeBasis(a, b, c) {\n    this.set(a.x, b.x, c.x, 0, a.y, b.y, c.y, 0, a.z, b.z, c.z, 0, 0, 0, 0, 1);return this;\n  }, extractRotation: function () {\n    var a = new THREE.Vector3();return function (b) {\n      var c = this.elements;b = b.elements;var d = 1 / a.set(b[0], b[1], b[2]).length(),\n          e = 1 / a.set(b[4], b[5], b[6]).length(),\n          f = 1 / a.set(b[8], b[9], b[10]).length();c[0] = b[0] * d;c[1] = b[1] * d;c[2] = b[2] * d;c[4] = b[4] * e;c[5] = b[5] * e;c[6] = b[6] * e;c[8] = b[8] * f;c[9] = b[9] * f;c[10] = b[10] * f;return this;\n    };\n  }(), makeRotationFromEuler: function makeRotationFromEuler(a) {\n    !1 === a instanceof THREE.Euler && THREE.error(\"THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.\");var b = this.elements,\n        c = a.x,\n        d = a.y,\n        e = a.z,\n        f = Math.cos(c),\n        c = Math.sin(c),\n        g = Math.cos(d),\n        d = Math.sin(d),\n        h = Math.cos(e),\n        e = Math.sin(e);if (\"XYZ\" === a.order) {\n      a = f * h;var k = f * e,\n          l = c * h,\n          p = c * e;b[0] = g * h;b[4] = -g * e;b[8] = d;b[1] = k + l * d;b[5] = a - p * d;b[9] = -c * g;b[2] = p - a * d;b[6] = l + k * d;b[10] = f * g;\n    } else \"YXZ\" === a.order ? (a = g * h, k = g * e, l = d * h, p = d * e, b[0] = a + p * c, b[4] = l * c - k, b[8] = f * d, b[1] = f * e, b[5] = f * h, b[9] = -c, b[2] = k * c - l, b[6] = p + a * c, b[10] = f * g) : \"ZXY\" === a.order ? (a = g * h, k = g * e, l = d * h, p = d * e, b[0] = a - p * c, b[4] = -f * e, b[8] = l + k * c, b[1] = k + l * c, b[5] = f * h, b[9] = p - a * c, b[2] = -f * d, b[6] = c, b[10] = f * g) : \"ZYX\" === a.order ? (a = f * h, k = f * e, l = c * h, p = c * e, b[0] = g * h, b[4] = l * d - k, b[8] = a * d + p, b[1] = g * e, b[5] = p * d + a, b[9] = k * d - l, b[2] = -d, b[6] = c * g, b[10] = f * g) : \"YZX\" === a.order ? (a = f * g, k = f * d, l = c * g, p = c * d, b[0] = g * h, b[4] = p - a * e, b[8] = l * e + k, b[1] = e, b[5] = f * h, b[9] = -c * h, b[2] = -d * h, b[6] = k * e + l, b[10] = a - p * e) : \"XZY\" === a.order && (a = f * g, k = f * d, l = c * g, p = c * d, b[0] = g * h, b[4] = -e, b[8] = d * h, b[1] = a * e + p, b[5] = f * h, b[9] = k * e - l, b[2] = l * e - k, b[6] = c * h, b[10] = p * e + a);b[3] = 0;b[7] = 0;b[11] = 0;b[12] = 0;b[13] = 0;b[14] = 0;b[15] = 1;return this;\n  }, setRotationFromQuaternion: function setRotationFromQuaternion(a) {\n    THREE.warn(\"THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().\");return this.makeRotationFromQuaternion(a);\n  },\n  makeRotationFromQuaternion: function makeRotationFromQuaternion(a) {\n    var b = this.elements,\n        c = a.x,\n        d = a.y,\n        e = a.z,\n        f = a.w,\n        g = c + c,\n        h = d + d,\n        k = e + e;a = c * g;var l = c * h,\n        c = c * k,\n        p = d * h,\n        d = d * k,\n        e = e * k,\n        g = f * g,\n        h = f * h,\n        f = f * k;b[0] = 1 - (p + e);b[4] = l - f;b[8] = c + h;b[1] = l + f;b[5] = 1 - (a + e);b[9] = d - g;b[2] = c - h;b[6] = d + g;b[10] = 1 - (a + p);b[3] = 0;b[7] = 0;b[11] = 0;b[12] = 0;b[13] = 0;b[14] = 0;b[15] = 1;return this;\n  }, lookAt: function () {\n    var a = new THREE.Vector3(),\n        b = new THREE.Vector3(),\n        c = new THREE.Vector3();return function (d, e, f) {\n      var g = this.elements;c.subVectors(d, e).normalize();0 === c.length() && (c.z = 1);a.crossVectors(f, c).normalize();0 === a.length() && (c.x += 1E-4, a.crossVectors(f, c).normalize());b.crossVectors(c, a);g[0] = a.x;g[4] = b.x;g[8] = c.x;g[1] = a.y;g[5] = b.y;g[9] = c.y;g[2] = a.z;g[6] = b.z;g[10] = c.z;return this;\n    };\n  }(), multiply: function multiply(a, b) {\n    return void 0 !== b ? (THREE.warn(\"THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.\"), this.multiplyMatrices(a, b)) : this.multiplyMatrices(this, a);\n  }, multiplyMatrices: function multiplyMatrices(a, b) {\n    var c = a.elements,\n        d = b.elements,\n        e = this.elements,\n        f = c[0],\n        g = c[4],\n        h = c[8],\n        k = c[12],\n        l = c[1],\n        p = c[5],\n        q = c[9],\n        n = c[13],\n        t = c[2],\n        r = c[6],\n        s = c[10],\n        u = c[14],\n        v = c[3],\n        x = c[7],\n        D = c[11],\n        c = c[15],\n        w = d[0],\n        y = d[4],\n        A = d[8],\n        E = d[12],\n        G = d[1],\n        F = d[5],\n        z = d[9],\n        I = d[13],\n        U = d[2],\n        M = d[6],\n        H = d[10],\n        L = d[14],\n        P = d[3],\n        N = d[7],\n        R = d[11],\n        d = d[15];e[0] = f * w + g * G + h * U + k * P;e[4] = f * y + g * F + h * M + k * N;e[8] = f * A + g * z + h * H + k * R;e[12] = f * E + g * I + h * L + k * d;e[1] = l * w + p * G + q * U + n * P;e[5] = l * y + p * F + q * M + n * N;e[9] = l * A + p * z + q * H + n * R;e[13] = l * E + p * I + q * L + n * d;e[2] = t * w + r * G + s * U + u * P;e[6] = t * y + r * F + s * M + u * N;e[10] = t * A + r * z + s * H + u * R;e[14] = t * E + r * I + s * L + u * d;e[3] = v * w + x * G + D * U + c * P;e[7] = v * y + x * F + D * M + c * N;e[11] = v * A + x * z + D * H + c * R;e[15] = v * E + x * I + D * L + c * d;return this;\n  }, multiplyToArray: function multiplyToArray(a, b, c) {\n    var d = this.elements;this.multiplyMatrices(a, b);c[0] = d[0];c[1] = d[1];c[2] = d[2];c[3] = d[3];c[4] = d[4];c[5] = d[5];c[6] = d[6];c[7] = d[7];c[8] = d[8];c[9] = d[9];c[10] = d[10];c[11] = d[11];c[12] = d[12];c[13] = d[13];c[14] = d[14];c[15] = d[15];return this;\n  }, multiplyScalar: function multiplyScalar(a) {\n    var b = this.elements;b[0] *= a;b[4] *= a;b[8] *= a;b[12] *= a;b[1] *= a;b[5] *= a;b[9] *= a;b[13] *= a;b[2] *= a;b[6] *= a;b[10] *= a;b[14] *= a;b[3] *= a;b[7] *= a;b[11] *= a;b[15] *= a;return this;\n  }, multiplyVector3: function multiplyVector3(a) {\n    THREE.warn(\"THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.\");return a.applyProjection(this);\n  }, multiplyVector4: function multiplyVector4(a) {\n    THREE.warn(\"THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.\");return a.applyMatrix4(this);\n  }, multiplyVector3Array: function multiplyVector3Array(a) {\n    THREE.warn(\"THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.\");\n    return this.applyToVector3Array(a);\n  }, applyToVector3Array: function () {\n    var a = new THREE.Vector3();return function (b, c, d) {\n      void 0 === c && (c = 0);void 0 === d && (d = b.length);for (var e = 0; e < d; e += 3, c += 3) {\n        a.x = b[c], a.y = b[c + 1], a.z = b[c + 2], a.applyMatrix4(this), b[c] = a.x, b[c + 1] = a.y, b[c + 2] = a.z;\n      }return b;\n    };\n  }(), rotateAxis: function rotateAxis(a) {\n    THREE.warn(\"THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.\");a.transformDirection(this);\n  }, crossVector: function crossVector(a) {\n    THREE.warn(\"THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.\");\n    return a.applyMatrix4(this);\n  }, determinant: function determinant() {\n    var a = this.elements,\n        b = a[0],\n        c = a[4],\n        d = a[8],\n        e = a[12],\n        f = a[1],\n        g = a[5],\n        h = a[9],\n        k = a[13],\n        l = a[2],\n        p = a[6],\n        q = a[10],\n        n = a[14];return a[3] * (+e * h * p - d * k * p - e * g * q + c * k * q + d * g * n - c * h * n) + a[7] * (+b * h * n - b * k * q + e * f * q - d * f * n + d * k * l - e * h * l) + a[11] * (+b * k * p - b * g * n - e * f * p + c * f * n + e * g * l - c * k * l) + a[15] * (-d * g * l - b * h * p + b * g * q + d * f * p - c * f * q + c * h * l);\n  }, transpose: function transpose() {\n    var a = this.elements,\n        b;b = a[1];a[1] = a[4];a[4] = b;b = a[2];a[2] = a[8];a[8] = b;b = a[6];a[6] = a[9];a[9] = b;b = a[3];a[3] = a[12];a[12] = b;b = a[7];a[7] = a[13];\n    a[13] = b;b = a[11];a[11] = a[14];a[14] = b;return this;\n  }, flattenToArrayOffset: function flattenToArrayOffset(a, b) {\n    var c = this.elements;a[b] = c[0];a[b + 1] = c[1];a[b + 2] = c[2];a[b + 3] = c[3];a[b + 4] = c[4];a[b + 5] = c[5];a[b + 6] = c[6];a[b + 7] = c[7];a[b + 8] = c[8];a[b + 9] = c[9];a[b + 10] = c[10];a[b + 11] = c[11];a[b + 12] = c[12];a[b + 13] = c[13];a[b + 14] = c[14];a[b + 15] = c[15];return a;\n  }, getPosition: function () {\n    var a = new THREE.Vector3();return function () {\n      THREE.warn(\"THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.\");var b = this.elements;return a.set(b[12], b[13], b[14]);\n    };\n  }(), setPosition: function setPosition(a) {\n    var b = this.elements;b[12] = a.x;b[13] = a.y;b[14] = a.z;return this;\n  }, getInverse: function getInverse(a, b) {\n    var c = this.elements,\n        d = a.elements,\n        e = d[0],\n        f = d[4],\n        g = d[8],\n        h = d[12],\n        k = d[1],\n        l = d[5],\n        p = d[9],\n        q = d[13],\n        n = d[2],\n        t = d[6],\n        r = d[10],\n        s = d[14],\n        u = d[3],\n        v = d[7],\n        x = d[11],\n        d = d[15];c[0] = p * s * v - q * r * v + q * t * x - l * s * x - p * t * d + l * r * d;c[4] = h * r * v - g * s * v - h * t * x + f * s * x + g * t * d - f * r * d;c[8] = g * q * v - h * p * v + h * l * x - f * q * x - g * l * d + f * p * d;c[12] = h * p * t - g * q * t - h * l * r + f * q * r + g * l * s - f * p * s;c[1] = q * r * u - p * s * u - q * n * x + k * s * x + p * n * d - k * r * d;c[5] = g * s * u - h * r * u + h * n * x - e * s * x - g * n * d + e * r * d;c[9] = h * p * u - g * q * u - h * k * x + e * q * x + g * k * d - e * p * d;c[13] = g * q * n - h * p * n + h * k * r - e * q * r - g * k * s + e * p * s;c[2] = l * s * u - q * t * u + q * n * v - k * s * v - l * n * d + k * t * d;c[6] = h * t * u - f * s * u - h * n * v + e * s * v + f * n * d - e * t * d;c[10] = f * q * u - h * l * u + h * k * v - e * q * v - f * k * d + e * l * d;c[14] = h * l * n - f * q * n - h * k * t + e * q * t + f * k * s - e * l * s;c[3] = p * t * u - l * r * u - p * n * v + k * r * v + l * n * x - k * t * x;c[7] = f * r * u - g * t * u + g * n * v - e * r * v - f * n * x + e * t * x;c[11] = g * l * u - f * p * u - g * k * v + e * p * v + f * k * x - e * l * x;c[15] = f * p * n - g * l * n + g * k * t - e * p * t - f * k * r + e * l * r;c = e * c[0] + k * c[4] + n * c[8] + u * c[12];\n    if (0 == c) {\n      if (b) throw Error(\"THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0\");THREE.warn(\"THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0\");this.identity();return this;\n    }this.multiplyScalar(1 / c);return this;\n  }, translate: function translate(a) {\n    THREE.error(\"THREE.Matrix4: .translate() has been removed.\");\n  }, rotateX: function rotateX(a) {\n    THREE.error(\"THREE.Matrix4: .rotateX() has been removed.\");\n  }, rotateY: function rotateY(a) {\n    THREE.error(\"THREE.Matrix4: .rotateY() has been removed.\");\n  }, rotateZ: function rotateZ(a) {\n    THREE.error(\"THREE.Matrix4: .rotateZ() has been removed.\");\n  },\n  rotateByAxis: function rotateByAxis(a, b) {\n    THREE.error(\"THREE.Matrix4: .rotateByAxis() has been removed.\");\n  }, scale: function scale(a) {\n    var b = this.elements,\n        c = a.x,\n        d = a.y;a = a.z;b[0] *= c;b[4] *= d;b[8] *= a;b[1] *= c;b[5] *= d;b[9] *= a;b[2] *= c;b[6] *= d;b[10] *= a;b[3] *= c;b[7] *= d;b[11] *= a;return this;\n  }, getMaxScaleOnAxis: function getMaxScaleOnAxis() {\n    var a = this.elements;return Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1] + a[2] * a[2], Math.max(a[4] * a[4] + a[5] * a[5] + a[6] * a[6], a[8] * a[8] + a[9] * a[9] + a[10] * a[10])));\n  }, makeTranslation: function makeTranslation(a, b, c) {\n    this.set(1, 0, 0, a, 0, 1, 0, b, 0, 0, 1, c, 0, 0, 0, 1);return this;\n  }, makeRotationX: function makeRotationX(a) {\n    var b = Math.cos(a);a = Math.sin(a);this.set(1, 0, 0, 0, 0, b, -a, 0, 0, a, b, 0, 0, 0, 0, 1);return this;\n  }, makeRotationY: function makeRotationY(a) {\n    var b = Math.cos(a);a = Math.sin(a);this.set(b, 0, a, 0, 0, 1, 0, 0, -a, 0, b, 0, 0, 0, 0, 1);return this;\n  }, makeRotationZ: function makeRotationZ(a) {\n    var b = Math.cos(a);a = Math.sin(a);this.set(b, -a, 0, 0, a, b, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);return this;\n  }, makeRotationAxis: function makeRotationAxis(a, b) {\n    var c = Math.cos(b),\n        d = Math.sin(b),\n        e = 1 - c,\n        f = a.x,\n        g = a.y,\n        h = a.z,\n        k = e * f,\n        l = e * g;this.set(k * f + c, k * g - d * h, k * h + d * g, 0, k * g + d * h, l * g + c, l * h - d * f, 0, k * h - d * g, l * h + d * f, e * h * h + c, 0, 0, 0, 0, 1);return this;\n  }, makeScale: function makeScale(a, b, c) {\n    this.set(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, 0, 1);return this;\n  }, compose: function compose(a, b, c) {\n    this.makeRotationFromQuaternion(b);this.scale(c);this.setPosition(a);return this;\n  }, decompose: function () {\n    var a = new THREE.Vector3(),\n        b = new THREE.Matrix4();return function (c, d, e) {\n      var f = this.elements,\n          g = a.set(f[0], f[1], f[2]).length(),\n          h = a.set(f[4], f[5], f[6]).length(),\n          k = a.set(f[8], f[9], f[10]).length();0 > this.determinant() && (g = -g);c.x = f[12];\n      c.y = f[13];c.z = f[14];b.elements.set(this.elements);c = 1 / g;var f = 1 / h,\n          l = 1 / k;b.elements[0] *= c;b.elements[1] *= c;b.elements[2] *= c;b.elements[4] *= f;b.elements[5] *= f;b.elements[6] *= f;b.elements[8] *= l;b.elements[9] *= l;b.elements[10] *= l;d.setFromRotationMatrix(b);e.x = g;e.y = h;e.z = k;return this;\n    };\n  }(), makeFrustum: function makeFrustum(a, b, c, d, e, f) {\n    var g = this.elements;g[0] = 2 * e / (b - a);g[4] = 0;g[8] = (b + a) / (b - a);g[12] = 0;g[1] = 0;g[5] = 2 * e / (d - c);g[9] = (d + c) / (d - c);g[13] = 0;g[2] = 0;g[6] = 0;g[10] = -(f + e) / (f - e);g[14] = -2 * f * e / (f - e);g[3] = 0;g[7] = 0;\n    g[11] = -1;g[15] = 0;return this;\n  }, makePerspective: function makePerspective(a, b, c, d) {\n    a = c * Math.tan(THREE.Math.degToRad(.5 * a));var e = -a;return this.makeFrustum(e * b, a * b, e, a, c, d);\n  }, makeOrthographic: function makeOrthographic(a, b, c, d, e, f) {\n    var g = this.elements,\n        h = b - a,\n        k = c - d,\n        l = f - e;g[0] = 2 / h;g[4] = 0;g[8] = 0;g[12] = -((b + a) / h);g[1] = 0;g[5] = 2 / k;g[9] = 0;g[13] = -((c + d) / k);g[2] = 0;g[6] = 0;g[10] = -2 / l;g[14] = -((f + e) / l);g[3] = 0;g[7] = 0;g[11] = 0;g[15] = 1;return this;\n  }, fromArray: function fromArray(a) {\n    this.elements.set(a);return this;\n  }, toArray: function toArray() {\n    var a = this.elements;return [a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]];\n  }, clone: function clone() {\n    return new THREE.Matrix4().fromArray(this.elements);\n  } };THREE.Ray = function (a, b) {\n  this.origin = void 0 !== a ? a : new THREE.Vector3();this.direction = void 0 !== b ? b : new THREE.Vector3();\n};\nTHREE.Ray.prototype = { constructor: THREE.Ray, set: function set(a, b) {\n    this.origin.copy(a);this.direction.copy(b);return this;\n  }, copy: function copy(a) {\n    this.origin.copy(a.origin);this.direction.copy(a.direction);return this;\n  }, at: function at(a, b) {\n    return (b || new THREE.Vector3()).copy(this.direction).multiplyScalar(a).add(this.origin);\n  }, recast: function () {\n    var a = new THREE.Vector3();return function (b) {\n      this.origin.copy(this.at(b, a));return this;\n    };\n  }(), closestPointToPoint: function closestPointToPoint(a, b) {\n    var c = b || new THREE.Vector3();c.subVectors(a, this.origin);\n    var d = c.dot(this.direction);return 0 > d ? c.copy(this.origin) : c.copy(this.direction).multiplyScalar(d).add(this.origin);\n  }, distanceToPoint: function () {\n    var a = new THREE.Vector3();return function (b) {\n      var c = a.subVectors(b, this.origin).dot(this.direction);if (0 > c) return this.origin.distanceTo(b);a.copy(this.direction).multiplyScalar(c).add(this.origin);return a.distanceTo(b);\n    };\n  }(), distanceSqToSegment: function () {\n    var a = new THREE.Vector3(),\n        b = new THREE.Vector3(),\n        c = new THREE.Vector3();return function (d, e, f, g) {\n      a.copy(d).add(e).multiplyScalar(.5);\n      b.copy(e).sub(d).normalize();c.copy(this.origin).sub(a);var h = .5 * d.distanceTo(e),\n          k = -this.direction.dot(b),\n          l = c.dot(this.direction),\n          p = -c.dot(b),\n          q = c.lengthSq(),\n          n = Math.abs(1 - k * k),\n          t;0 < n ? (d = k * p - l, e = k * l - p, t = h * n, 0 <= d ? e >= -t ? e <= t ? (h = 1 / n, d *= h, e *= h, k = d * (d + k * e + 2 * l) + e * (k * d + e + 2 * p) + q) : (e = h, d = Math.max(0, -(k * e + l)), k = -d * d + e * (e + 2 * p) + q) : (e = -h, d = Math.max(0, -(k * e + l)), k = -d * d + e * (e + 2 * p) + q) : e <= -t ? (d = Math.max(0, -(-k * h + l)), e = 0 < d ? -h : Math.min(Math.max(-h, -p), h), k = -d * d + e * (e + 2 * p) + q) : e <= t ? (d = 0, e = Math.min(Math.max(-h, -p), h), k = e * (e + 2 * p) + q) : (d = Math.max(0, -(k * h + l)), e = 0 < d ? h : Math.min(Math.max(-h, -p), h), k = -d * d + e * (e + 2 * p) + q)) : (e = 0 < k ? -h : h, d = Math.max(0, -(k * e + l)), k = -d * d + e * (e + 2 * p) + q);f && f.copy(this.direction).multiplyScalar(d).add(this.origin);g && g.copy(b).multiplyScalar(e).add(a);return k;\n    };\n  }(), isIntersectionSphere: function isIntersectionSphere(a) {\n    return this.distanceToPoint(a.center) <= a.radius;\n  }, intersectSphere: function () {\n    var a = new THREE.Vector3();return function (b, c) {\n      a.subVectors(b.center, this.origin);var d = a.dot(this.direction),\n          e = a.dot(a) - d * d,\n          f = b.radius * b.radius;\n      if (e > f) return null;f = Math.sqrt(f - e);e = d - f;d += f;return 0 > e && 0 > d ? null : 0 > e ? this.at(d, c) : this.at(e, c);\n    };\n  }(), isIntersectionPlane: function isIntersectionPlane(a) {\n    var b = a.distanceToPoint(this.origin);return 0 === b || 0 > a.normal.dot(this.direction) * b ? !0 : !1;\n  }, distanceToPlane: function distanceToPlane(a) {\n    var b = a.normal.dot(this.direction);if (0 == b) return 0 == a.distanceToPoint(this.origin) ? 0 : null;a = -(this.origin.dot(a.normal) + a.constant) / b;return 0 <= a ? a : null;\n  }, intersectPlane: function intersectPlane(a, b) {\n    var c = this.distanceToPlane(a);return null === c ? null : this.at(c, b);\n  },\n  isIntersectionBox: function () {\n    var a = new THREE.Vector3();return function (b) {\n      return null !== this.intersectBox(b, a);\n    };\n  }(), intersectBox: function intersectBox(a, b) {\n    var c, d, e, f, g;d = 1 / this.direction.x;f = 1 / this.direction.y;g = 1 / this.direction.z;var h = this.origin;0 <= d ? (c = (a.min.x - h.x) * d, d *= a.max.x - h.x) : (c = (a.max.x - h.x) * d, d *= a.min.x - h.x);0 <= f ? (e = (a.min.y - h.y) * f, f *= a.max.y - h.y) : (e = (a.max.y - h.y) * f, f *= a.min.y - h.y);if (c > f || e > d) return null;if (e > c || c !== c) c = e;if (f < d || d !== d) d = f;0 <= g ? (e = (a.min.z - h.z) * g, g *= a.max.z - h.z) : (e = (a.max.z - h.z) * g, g *= a.min.z - h.z);if (c > g || e > d) return null;if (e > c || c !== c) c = e;if (g < d || d !== d) d = g;return 0 > d ? null : this.at(0 <= c ? c : d, b);\n  }, intersectTriangle: function () {\n    var a = new THREE.Vector3(),\n        b = new THREE.Vector3(),\n        c = new THREE.Vector3(),\n        d = new THREE.Vector3();return function (e, f, g, h, k) {\n      b.subVectors(f, e);c.subVectors(g, e);d.crossVectors(b, c);f = this.direction.dot(d);if (0 < f) {\n        if (h) return null;h = 1;\n      } else if (0 > f) h = -1, f = -f;else return null;a.subVectors(this.origin, e);e = h * this.direction.dot(c.crossVectors(a, c));if (0 > e) return null;g = h * this.direction.dot(b.cross(a));\n      if (0 > g || e + g > f) return null;e = -h * a.dot(d);return 0 > e ? null : this.at(e / f, k);\n    };\n  }(), applyMatrix4: function applyMatrix4(a) {\n    this.direction.add(this.origin).applyMatrix4(a);this.origin.applyMatrix4(a);this.direction.sub(this.origin);this.direction.normalize();return this;\n  }, equals: function equals(a) {\n    return a.origin.equals(this.origin) && a.direction.equals(this.direction);\n  }, clone: function clone() {\n    return new THREE.Ray().copy(this);\n  } };THREE.Sphere = function (a, b) {\n  this.center = void 0 !== a ? a : new THREE.Vector3();this.radius = void 0 !== b ? b : 0;\n};\nTHREE.Sphere.prototype = { constructor: THREE.Sphere, set: function set(a, b) {\n    this.center.copy(a);this.radius = b;return this;\n  }, setFromPoints: function () {\n    var a = new THREE.Box3();return function (b, c) {\n      var d = this.center;void 0 !== c ? d.copy(c) : a.setFromPoints(b).center(d);for (var e = 0, f = 0, g = b.length; f < g; f++) {\n        e = Math.max(e, d.distanceToSquared(b[f]));\n      }this.radius = Math.sqrt(e);return this;\n    };\n  }(), copy: function copy(a) {\n    this.center.copy(a.center);this.radius = a.radius;return this;\n  }, empty: function empty() {\n    return 0 >= this.radius;\n  }, containsPoint: function containsPoint(a) {\n    return a.distanceToSquared(this.center) <= this.radius * this.radius;\n  }, distanceToPoint: function distanceToPoint(a) {\n    return a.distanceTo(this.center) - this.radius;\n  }, intersectsSphere: function intersectsSphere(a) {\n    var b = this.radius + a.radius;return a.center.distanceToSquared(this.center) <= b * b;\n  }, clampPoint: function clampPoint(a, b) {\n    var c = this.center.distanceToSquared(a),\n        d = b || new THREE.Vector3();d.copy(a);c > this.radius * this.radius && (d.sub(this.center).normalize(), d.multiplyScalar(this.radius).add(this.center));return d;\n  }, getBoundingBox: function getBoundingBox(a) {\n    a = a || new THREE.Box3();a.set(this.center, this.center);a.expandByScalar(this.radius);\n    return a;\n  }, applyMatrix4: function applyMatrix4(a) {\n    this.center.applyMatrix4(a);this.radius *= a.getMaxScaleOnAxis();return this;\n  }, translate: function translate(a) {\n    this.center.add(a);return this;\n  }, equals: function equals(a) {\n    return a.center.equals(this.center) && a.radius === this.radius;\n  }, clone: function clone() {\n    return new THREE.Sphere().copy(this);\n  } };\nTHREE.Frustum = function (a, b, c, d, e, f) {\n  this.planes = [void 0 !== a ? a : new THREE.Plane(), void 0 !== b ? b : new THREE.Plane(), void 0 !== c ? c : new THREE.Plane(), void 0 !== d ? d : new THREE.Plane(), void 0 !== e ? e : new THREE.Plane(), void 0 !== f ? f : new THREE.Plane()];\n};\nTHREE.Frustum.prototype = { constructor: THREE.Frustum, set: function set(a, b, c, d, e, f) {\n    var g = this.planes;g[0].copy(a);g[1].copy(b);g[2].copy(c);g[3].copy(d);g[4].copy(e);g[5].copy(f);return this;\n  }, copy: function copy(a) {\n    for (var b = this.planes, c = 0; 6 > c; c++) {\n      b[c].copy(a.planes[c]);\n    }return this;\n  }, setFromMatrix: function setFromMatrix(a) {\n    var b = this.planes,\n        c = a.elements;a = c[0];var d = c[1],\n        e = c[2],\n        f = c[3],\n        g = c[4],\n        h = c[5],\n        k = c[6],\n        l = c[7],\n        p = c[8],\n        q = c[9],\n        n = c[10],\n        t = c[11],\n        r = c[12],\n        s = c[13],\n        u = c[14],\n        c = c[15];b[0].setComponents(f - a, l - g, t - p, c - r).normalize();b[1].setComponents(f + a, l + g, t + p, c + r).normalize();b[2].setComponents(f + d, l + h, t + q, c + s).normalize();b[3].setComponents(f - d, l - h, t - q, c - s).normalize();b[4].setComponents(f - e, l - k, t - n, c - u).normalize();b[5].setComponents(f + e, l + k, t + n, c + u).normalize();return this;\n  }, intersectsObject: function () {\n    var a = new THREE.Sphere();return function (b) {\n      var c = b.geometry;null === c.boundingSphere && c.computeBoundingSphere();a.copy(c.boundingSphere);a.applyMatrix4(b.matrixWorld);return this.intersectsSphere(a);\n    };\n  }(), intersectsSphere: function intersectsSphere(a) {\n    var b = this.planes,\n        c = a.center;a = -a.radius;for (var d = 0; 6 > d; d++) {\n      if (b[d].distanceToPoint(c) < a) return !1;\n    }return !0;\n  }, intersectsBox: function () {\n    var a = new THREE.Vector3(),\n        b = new THREE.Vector3();return function (c) {\n      for (var d = this.planes, e = 0; 6 > e; e++) {\n        var f = d[e];a.x = 0 < f.normal.x ? c.min.x : c.max.x;b.x = 0 < f.normal.x ? c.max.x : c.min.x;a.y = 0 < f.normal.y ? c.min.y : c.max.y;b.y = 0 < f.normal.y ? c.max.y : c.min.y;a.z = 0 < f.normal.z ? c.min.z : c.max.z;b.z = 0 < f.normal.z ? c.max.z : c.min.z;var g = f.distanceToPoint(a),\n            f = f.distanceToPoint(b);if (0 > g && 0 > f) return !1;\n      }return !0;\n    };\n  }(),\n  containsPoint: function containsPoint(a) {\n    for (var b = this.planes, c = 0; 6 > c; c++) {\n      if (0 > b[c].distanceToPoint(a)) return !1;\n    }return !0;\n  }, clone: function clone() {\n    return new THREE.Frustum().copy(this);\n  } };THREE.Plane = function (a, b) {\n  this.normal = void 0 !== a ? a : new THREE.Vector3(1, 0, 0);this.constant = void 0 !== b ? b : 0;\n};\nTHREE.Plane.prototype = { constructor: THREE.Plane, set: function set(a, b) {\n    this.normal.copy(a);this.constant = b;return this;\n  }, setComponents: function setComponents(a, b, c, d) {\n    this.normal.set(a, b, c);this.constant = d;return this;\n  }, setFromNormalAndCoplanarPoint: function setFromNormalAndCoplanarPoint(a, b) {\n    this.normal.copy(a);this.constant = -b.dot(this.normal);return this;\n  }, setFromCoplanarPoints: function () {\n    var a = new THREE.Vector3(),\n        b = new THREE.Vector3();return function (c, d, e) {\n      d = a.subVectors(e, d).cross(b.subVectors(c, d)).normalize();this.setFromNormalAndCoplanarPoint(d, c);return this;\n    };\n  }(), copy: function copy(a) {\n    this.normal.copy(a.normal);this.constant = a.constant;return this;\n  }, normalize: function normalize() {\n    var a = 1 / this.normal.length();this.normal.multiplyScalar(a);this.constant *= a;return this;\n  }, negate: function negate() {\n    this.constant *= -1;this.normal.negate();return this;\n  }, distanceToPoint: function distanceToPoint(a) {\n    return this.normal.dot(a) + this.constant;\n  }, distanceToSphere: function distanceToSphere(a) {\n    return this.distanceToPoint(a.center) - a.radius;\n  }, projectPoint: function projectPoint(a, b) {\n    return this.orthoPoint(a, b).sub(a).negate();\n  }, orthoPoint: function orthoPoint(a, b) {\n    var c = this.distanceToPoint(a);return (b || new THREE.Vector3()).copy(this.normal).multiplyScalar(c);\n  }, isIntersectionLine: function isIntersectionLine(a) {\n    var b = this.distanceToPoint(a.start);a = this.distanceToPoint(a.end);return 0 > b && 0 < a || 0 > a && 0 < b;\n  }, intersectLine: function () {\n    var a = new THREE.Vector3();return function (b, c) {\n      var d = c || new THREE.Vector3(),\n          e = b.delta(a),\n          f = this.normal.dot(e);if (0 == f) {\n        if (0 == this.distanceToPoint(b.start)) return d.copy(b.start);\n      } else return f = -(b.start.dot(this.normal) + this.constant) / f, 0 > f || 1 < f ? void 0 : d.copy(e).multiplyScalar(f).add(b.start);\n    };\n  }(),\n  coplanarPoint: function coplanarPoint(a) {\n    return (a || new THREE.Vector3()).copy(this.normal).multiplyScalar(-this.constant);\n  }, applyMatrix4: function () {\n    var a = new THREE.Vector3(),\n        b = new THREE.Vector3(),\n        c = new THREE.Matrix3();return function (d, e) {\n      var f = e || c.getNormalMatrix(d),\n          f = a.copy(this.normal).applyMatrix3(f),\n          g = this.coplanarPoint(b);g.applyMatrix4(d);this.setFromNormalAndCoplanarPoint(f, g);return this;\n    };\n  }(), translate: function translate(a) {\n    this.constant -= a.dot(this.normal);return this;\n  }, equals: function equals(a) {\n    return a.normal.equals(this.normal) && a.constant == this.constant;\n  }, clone: function clone() {\n    return new THREE.Plane().copy(this);\n  } };\nTHREE.Math = { generateUUID: function () {\n    var a = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\".split(\"\"),\n        b = Array(36),\n        c = 0,\n        d;return function () {\n      for (var e = 0; 36 > e; e++) {\n        8 == e || 13 == e || 18 == e || 23 == e ? b[e] = \"-\" : 14 == e ? b[e] = \"4\" : (2 >= c && (c = 33554432 + 16777216 * Math.random() | 0), d = c & 15, c >>= 4, b[e] = a[19 == e ? d & 3 | 8 : d]);\n      }return b.join(\"\");\n    };\n  }(), clamp: function clamp(a, b, c) {\n    return a < b ? b : a > c ? c : a;\n  }, clampBottom: function clampBottom(a, b) {\n    return a < b ? b : a;\n  }, mapLinear: function mapLinear(a, b, c, d, e) {\n    return d + (a - b) * (e - d) / (c - b);\n  }, smoothstep: function smoothstep(a, b, c) {\n    if (a <= b) return 0;if (a >= c) return 1;a = (a - b) / (c - b);return a * a * (3 - 2 * a);\n  }, smootherstep: function smootherstep(a, b, c) {\n    if (a <= b) return 0;if (a >= c) return 1;a = (a - b) / (c - b);return a * a * a * (a * (6 * a - 15) + 10);\n  }, random16: function random16() {\n    return (65280 * Math.random() + 255 * Math.random()) / 65535;\n  }, randInt: function randInt(a, b) {\n    return Math.floor(this.randFloat(a, b));\n  }, randFloat: function randFloat(a, b) {\n    return a + Math.random() * (b - a);\n  }, randFloatSpread: function randFloatSpread(a) {\n    return a * (.5 - Math.random());\n  }, degToRad: function () {\n    var a = Math.PI / 180;return function (b) {\n      return b * a;\n    };\n  }(), radToDeg: function () {\n    var a = 180 / Math.PI;return function (b) {\n      return b * a;\n    };\n  }(), isPowerOfTwo: function isPowerOfTwo(a) {\n    return 0 === (a & a - 1) && 0 !== a;\n  }, nextPowerOfTwo: function nextPowerOfTwo(a) {\n    a--;a |= a >> 1;a |= a >> 2;a |= a >> 4;a |= a >> 8;a |= a >> 16;a++;return a;\n  } };\nTHREE.Spline = function (a) {\n  function b(a, b, c, d, e, f, g) {\n    a = .5 * (c - a);d = .5 * (d - b);return (2 * (b - c) + a + d) * g + (-3 * (b - c) - 2 * a - d) * f + a * e + b;\n  }this.points = a;var c = [],\n      d = { x: 0, y: 0, z: 0 },\n      e,\n      f,\n      g,\n      h,\n      k,\n      l,\n      p,\n      q,\n      n;this.initFromArray = function (a) {\n    this.points = [];for (var b = 0; b < a.length; b++) {\n      this.points[b] = { x: a[b][0], y: a[b][1], z: a[b][2] };\n    }\n  };this.getPoint = function (a) {\n    e = (this.points.length - 1) * a;f = Math.floor(e);g = e - f;c[0] = 0 === f ? f : f - 1;c[1] = f;c[2] = f > this.points.length - 2 ? this.points.length - 1 : f + 1;c[3] = f > this.points.length - 3 ? this.points.length - 1 : f + 2;l = this.points[c[0]];p = this.points[c[1]];q = this.points[c[2]];n = this.points[c[3]];h = g * g;k = g * h;d.x = b(l.x, p.x, q.x, n.x, g, h, k);d.y = b(l.y, p.y, q.y, n.y, g, h, k);d.z = b(l.z, p.z, q.z, n.z, g, h, k);return d;\n  };this.getControlPointsArray = function () {\n    var a,\n        b,\n        c = this.points.length,\n        d = [];for (a = 0; a < c; a++) {\n      b = this.points[a], d[a] = [b.x, b.y, b.z];\n    }return d;\n  };this.getLength = function (a) {\n    var b,\n        c,\n        d,\n        e = b = b = 0,\n        f = new THREE.Vector3(),\n        g = new THREE.Vector3(),\n        h = [],\n        k = 0;h[0] = 0;a || (a = 100);c = this.points.length * a;f.copy(this.points[0]);for (a = 1; a < c; a++) {\n      b = a / c, d = this.getPoint(b), g.copy(d), k += g.distanceTo(f), f.copy(d), b *= this.points.length - 1, b = Math.floor(b), b != e && (h[b] = k, e = b);\n    }h[h.length] = k;return { chunks: h, total: k };\n  };this.reparametrizeByArcLength = function (a) {\n    var b,\n        c,\n        d,\n        e,\n        f,\n        g,\n        h = [],\n        k = new THREE.Vector3(),\n        n = this.getLength();h.push(k.copy(this.points[0]).clone());for (b = 1; b < this.points.length; b++) {\n      c = n.chunks[b] - n.chunks[b - 1];g = Math.ceil(a * c / n.total);e = (b - 1) / (this.points.length - 1);f = b / (this.points.length - 1);for (c = 1; c < g - 1; c++) {\n        d = e + 1 / g * c * (f - e), d = this.getPoint(d), h.push(k.copy(d).clone());\n      }h.push(k.copy(this.points[b]).clone());\n    }this.points = h;\n  };\n};THREE.Triangle = function (a, b, c) {\n  this.a = void 0 !== a ? a : new THREE.Vector3();this.b = void 0 !== b ? b : new THREE.Vector3();this.c = void 0 !== c ? c : new THREE.Vector3();\n};THREE.Triangle.normal = function () {\n  var a = new THREE.Vector3();return function (b, c, d, e) {\n    e = e || new THREE.Vector3();e.subVectors(d, c);a.subVectors(b, c);e.cross(a);b = e.lengthSq();return 0 < b ? e.multiplyScalar(1 / Math.sqrt(b)) : e.set(0, 0, 0);\n  };\n}();\nTHREE.Triangle.barycoordFromPoint = function () {\n  var a = new THREE.Vector3(),\n      b = new THREE.Vector3(),\n      c = new THREE.Vector3();return function (d, e, f, g, h) {\n    a.subVectors(g, e);b.subVectors(f, e);c.subVectors(d, e);d = a.dot(a);e = a.dot(b);f = a.dot(c);var k = b.dot(b);g = b.dot(c);var l = d * k - e * e;h = h || new THREE.Vector3();if (0 == l) return h.set(-2, -1, -1);l = 1 / l;k = (k * f - e * g) * l;d = (d * g - e * f) * l;return h.set(1 - k - d, d, k);\n  };\n}();\nTHREE.Triangle.containsPoint = function () {\n  var a = new THREE.Vector3();return function (b, c, d, e) {\n    b = THREE.Triangle.barycoordFromPoint(b, c, d, e, a);return 0 <= b.x && 0 <= b.y && 1 >= b.x + b.y;\n  };\n}();\nTHREE.Triangle.prototype = { constructor: THREE.Triangle, set: function set(a, b, c) {\n    this.a.copy(a);this.b.copy(b);this.c.copy(c);return this;\n  }, setFromPointsAndIndices: function setFromPointsAndIndices(a, b, c, d) {\n    this.a.copy(a[b]);this.b.copy(a[c]);this.c.copy(a[d]);return this;\n  }, copy: function copy(a) {\n    this.a.copy(a.a);this.b.copy(a.b);this.c.copy(a.c);return this;\n  }, area: function () {\n    var a = new THREE.Vector3(),\n        b = new THREE.Vector3();return function () {\n      a.subVectors(this.c, this.b);b.subVectors(this.a, this.b);return .5 * a.cross(b).length();\n    };\n  }(), midpoint: function midpoint(a) {\n    return (a || new THREE.Vector3()).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);\n  }, normal: function normal(a) {\n    return THREE.Triangle.normal(this.a, this.b, this.c, a);\n  }, plane: function plane(a) {\n    return (a || new THREE.Plane()).setFromCoplanarPoints(this.a, this.b, this.c);\n  }, barycoordFromPoint: function barycoordFromPoint(a, b) {\n    return THREE.Triangle.barycoordFromPoint(a, this.a, this.b, this.c, b);\n  }, containsPoint: function containsPoint(a) {\n    return THREE.Triangle.containsPoint(a, this.a, this.b, this.c);\n  }, equals: function equals(a) {\n    return a.a.equals(this.a) && a.b.equals(this.b) && a.c.equals(this.c);\n  },\n  clone: function clone() {\n    return new THREE.Triangle().copy(this);\n  } };THREE.Clock = function (a) {\n  this.autoStart = void 0 !== a ? a : !0;this.elapsedTime = this.oldTime = this.startTime = 0;this.running = !1;\n};\nTHREE.Clock.prototype = { constructor: THREE.Clock, start: function start() {\n    this.oldTime = this.startTime = void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now() : Date.now();this.running = !0;\n  }, stop: function stop() {\n    this.getElapsedTime();this.running = !1;\n  }, getElapsedTime: function getElapsedTime() {\n    this.getDelta();return this.elapsedTime;\n  }, getDelta: function getDelta() {\n    var a = 0;this.autoStart && !this.running && this.start();if (this.running) {\n      var b = void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now() : Date.now(),\n          a = .001 * (b - this.oldTime);this.oldTime = b;this.elapsedTime += a;\n    }return a;\n  } };THREE.EventDispatcher = function () {};\nTHREE.EventDispatcher.prototype = { constructor: THREE.EventDispatcher, apply: function apply(a) {\n    a.addEventListener = THREE.EventDispatcher.prototype.addEventListener;a.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;a.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;a.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;\n  }, addEventListener: function addEventListener(a, b) {\n    void 0 === this._listeners && (this._listeners = {});var c = this._listeners;void 0 === c[a] && (c[a] = []);-1 === c[a].indexOf(b) && c[a].push(b);\n  }, hasEventListener: function hasEventListener(a, b) {\n    if (void 0 === this._listeners) return !1;var c = this._listeners;return void 0 !== c[a] && -1 !== c[a].indexOf(b) ? !0 : !1;\n  }, removeEventListener: function removeEventListener(a, b) {\n    if (void 0 !== this._listeners) {\n      var c = this._listeners[a];if (void 0 !== c) {\n        var d = c.indexOf(b);-1 !== d && c.splice(d, 1);\n      }\n    }\n  }, dispatchEvent: function dispatchEvent(a) {\n    if (void 0 !== this._listeners) {\n      var b = this._listeners[a.type];if (void 0 !== b) {\n        a.target = this;for (var c = [], d = b.length, e = 0; e < d; e++) {\n          c[e] = b[e];\n        }for (e = 0; e < d; e++) {\n          c[e].call(this, a);\n        }\n      }\n    }\n  } };\n(function (a) {\n  a.Raycaster = function (b, c, f, g) {\n    this.ray = new a.Ray(b, c);this.near = f || 0;this.far = g || Infinity;this.params = { Sprite: {}, Mesh: {}, PointCloud: { threshold: 1 }, LOD: {}, Line: {} };\n  };var b = function b(a, _b) {\n    return a.distance - _b.distance;\n  },\n      c = function c(a, b, f, g) {\n    a.raycast(b, f);if (!0 === g) {\n      a = a.children;g = 0;for (var h = a.length; g < h; g++) {\n        c(a[g], b, f, !0);\n      }\n    }\n  };a.Raycaster.prototype = { constructor: a.Raycaster, precision: 1E-4, linePrecision: 1, set: function set(a, b) {\n      this.ray.set(a, b);\n    }, setFromCamera: function setFromCamera(b, c) {\n      c instanceof a.PerspectiveCamera ? (this.ray.origin.copy(c.position), this.ray.direction.set(b.x, b.y, .5).unproject(c).sub(c.position).normalize()) : c instanceof a.OrthographicCamera ? (this.ray.origin.set(b.x, b.y, -1).unproject(c), this.ray.direction.set(0, 0, -1).transformDirection(c.matrixWorld)) : a.error(\"THREE.Raycaster: Unsupported camera type.\");\n    }, intersectObject: function intersectObject(a, e) {\n      var f = [];c(a, this, f, e);f.sort(b);return f;\n    }, intersectObjects: function intersectObjects(d, e) {\n      var f = [];if (!1 === d instanceof Array) return a.warn(\"THREE.Raycaster.intersectObjects: objects is not an Array.\"), f;for (var g = 0, h = d.length; g < h; g++) {\n        c(d[g], this, f, e);\n      }f.sort(b);return f;\n    } };\n})(THREE);\nTHREE.Object3D = function () {\n  Object.defineProperty(this, \"id\", { value: THREE.Object3DIdCount++ });this.uuid = THREE.Math.generateUUID();this.name = \"\";this.type = \"Object3D\";this.parent = void 0;this.children = [];this.up = THREE.Object3D.DefaultUp.clone();var a = new THREE.Vector3(),\n      b = new THREE.Euler(),\n      c = new THREE.Quaternion(),\n      d = new THREE.Vector3(1, 1, 1);b.onChange(function () {\n    c.setFromEuler(b, !1);\n  });c.onChange(function () {\n    b.setFromQuaternion(c, void 0, !1);\n  });Object.defineProperties(this, { position: { enumerable: !0, value: a }, rotation: { enumerable: !0,\n      value: b }, quaternion: { enumerable: !0, value: c }, scale: { enumerable: !0, value: d } });this.rotationAutoUpdate = !0;this.matrix = new THREE.Matrix4();this.matrixWorld = new THREE.Matrix4();this.matrixAutoUpdate = !0;this.matrixWorldNeedsUpdate = !1;this.visible = !0;this.receiveShadow = this.castShadow = !1;this.frustumCulled = !0;this.renderOrder = 0;this.userData = {};\n};THREE.Object3D.DefaultUp = new THREE.Vector3(0, 1, 0);\nTHREE.Object3D.prototype = { constructor: THREE.Object3D, get eulerOrder() {\n    THREE.warn(\"THREE.Object3D: .eulerOrder has been moved to .rotation.order.\");return this.rotation.order;\n  }, set eulerOrder(a) {\n    THREE.warn(\"THREE.Object3D: .eulerOrder has been moved to .rotation.order.\");this.rotation.order = a;\n  }, get useQuaternion() {\n    THREE.warn(\"THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.\");\n  }, set useQuaternion(a) {\n    THREE.warn(\"THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.\");\n  },\n  applyMatrix: function applyMatrix(a) {\n    this.matrix.multiplyMatrices(a, this.matrix);this.matrix.decompose(this.position, this.quaternion, this.scale);\n  }, setRotationFromAxisAngle: function setRotationFromAxisAngle(a, b) {\n    this.quaternion.setFromAxisAngle(a, b);\n  }, setRotationFromEuler: function setRotationFromEuler(a) {\n    this.quaternion.setFromEuler(a, !0);\n  }, setRotationFromMatrix: function setRotationFromMatrix(a) {\n    this.quaternion.setFromRotationMatrix(a);\n  }, setRotationFromQuaternion: function setRotationFromQuaternion(a) {\n    this.quaternion.copy(a);\n  }, rotateOnAxis: function () {\n    var a = new THREE.Quaternion();return function (b, c) {\n      a.setFromAxisAngle(b, c);this.quaternion.multiply(a);return this;\n    };\n  }(), rotateX: function () {\n    var a = new THREE.Vector3(1, 0, 0);return function (b) {\n      return this.rotateOnAxis(a, b);\n    };\n  }(), rotateY: function () {\n    var a = new THREE.Vector3(0, 1, 0);return function (b) {\n      return this.rotateOnAxis(a, b);\n    };\n  }(), rotateZ: function () {\n    var a = new THREE.Vector3(0, 0, 1);return function (b) {\n      return this.rotateOnAxis(a, b);\n    };\n  }(), translateOnAxis: function () {\n    var a = new THREE.Vector3();return function (b, c) {\n      a.copy(b).applyQuaternion(this.quaternion);this.position.add(a.multiplyScalar(c));\n      return this;\n    };\n  }(), translate: function translate(a, b) {\n    THREE.warn(\"THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.\");return this.translateOnAxis(b, a);\n  }, translateX: function () {\n    var a = new THREE.Vector3(1, 0, 0);return function (b) {\n      return this.translateOnAxis(a, b);\n    };\n  }(), translateY: function () {\n    var a = new THREE.Vector3(0, 1, 0);return function (b) {\n      return this.translateOnAxis(a, b);\n    };\n  }(), translateZ: function () {\n    var a = new THREE.Vector3(0, 0, 1);return function (b) {\n      return this.translateOnAxis(a, b);\n    };\n  }(), localToWorld: function localToWorld(a) {\n    return a.applyMatrix4(this.matrixWorld);\n  }, worldToLocal: function () {\n    var a = new THREE.Matrix4();return function (b) {\n      return b.applyMatrix4(a.getInverse(this.matrixWorld));\n    };\n  }(), lookAt: function () {\n    var a = new THREE.Matrix4();return function (b) {\n      a.lookAt(b, this.position, this.up);this.quaternion.setFromRotationMatrix(a);\n    };\n  }(), add: function add(a) {\n    if (1 < arguments.length) {\n      for (var b = 0; b < arguments.length; b++) {\n        this.add(arguments[b]);\n      }return this;\n    }if (a === this) return THREE.error(\"THREE.Object3D.add: object can't be added as a child of itself.\", a), this;a instanceof THREE.Object3D ? (void 0 !== a.parent && a.parent.remove(a), a.parent = this, a.dispatchEvent({ type: \"added\" }), this.children.push(a)) : THREE.error(\"THREE.Object3D.add: object not an instance of THREE.Object3D.\", a);return this;\n  }, remove: function remove(a) {\n    if (1 < arguments.length) for (var b = 0; b < arguments.length; b++) {\n      this.remove(arguments[b]);\n    }b = this.children.indexOf(a);-1 !== b && (a.parent = void 0, a.dispatchEvent({ type: \"removed\" }), this.children.splice(b, 1));\n  }, getChildByName: function getChildByName(a) {\n    THREE.warn(\"THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().\");\n    return this.getObjectByName(a);\n  }, getObjectById: function getObjectById(a) {\n    return this.getObjectByProperty(\"id\", a);\n  }, getObjectByName: function getObjectByName(a) {\n    return this.getObjectByProperty(\"name\", a);\n  }, getObjectByProperty: function getObjectByProperty(a, b) {\n    if (this[a] === b) return this;for (var c = 0, d = this.children.length; c < d; c++) {\n      var e = this.children[c].getObjectByProperty(a, b);if (void 0 !== e) return e;\n    }\n  }, getWorldPosition: function getWorldPosition(a) {\n    a = a || new THREE.Vector3();this.updateMatrixWorld(!0);return a.setFromMatrixPosition(this.matrixWorld);\n  }, getWorldQuaternion: function () {\n    var a = new THREE.Vector3(),\n        b = new THREE.Vector3();return function (c) {\n      c = c || new THREE.Quaternion();this.updateMatrixWorld(!0);this.matrixWorld.decompose(a, c, b);return c;\n    };\n  }(), getWorldRotation: function () {\n    var a = new THREE.Quaternion();return function (b) {\n      b = b || new THREE.Euler();this.getWorldQuaternion(a);return b.setFromQuaternion(a, this.rotation.order, !1);\n    };\n  }(), getWorldScale: function () {\n    var a = new THREE.Vector3(),\n        b = new THREE.Quaternion();return function (c) {\n      c = c || new THREE.Vector3();this.updateMatrixWorld(!0);this.matrixWorld.decompose(a, b, c);return c;\n    };\n  }(), getWorldDirection: function () {\n    var a = new THREE.Quaternion();return function (b) {\n      b = b || new THREE.Vector3();this.getWorldQuaternion(a);return b.set(0, 0, 1).applyQuaternion(a);\n    };\n  }(), raycast: function raycast() {}, traverse: function traverse(a) {\n    a(this);for (var b = 0, c = this.children.length; b < c; b++) {\n      this.children[b].traverse(a);\n    }\n  }, traverseVisible: function traverseVisible(a) {\n    if (!1 !== this.visible) {\n      a(this);for (var b = 0, c = this.children.length; b < c; b++) {\n        this.children[b].traverseVisible(a);\n      }\n    }\n  }, traverseAncestors: function traverseAncestors(a) {\n    this.parent && (a(this.parent), this.parent.traverseAncestors(a));\n  }, updateMatrix: function updateMatrix() {\n    this.matrix.compose(this.position, this.quaternion, this.scale);this.matrixWorldNeedsUpdate = !0;\n  }, updateMatrixWorld: function updateMatrixWorld(a) {\n    !0 === this.matrixAutoUpdate && this.updateMatrix();if (!0 === this.matrixWorldNeedsUpdate || !0 === a) void 0 === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, a = !0;for (var b = 0, c = this.children.length; b < c; b++) {\n      this.children[b].updateMatrixWorld(a);\n    }\n  },\n  toJSON: function toJSON() {\n    var a = { metadata: { version: 4.3, type: \"Object\", generator: \"ObjectExporter\" } },\n        b = {},\n        c = {},\n        d = function d(b) {\n      void 0 === a.materials && (a.materials = []);if (void 0 === c[b.uuid]) {\n        var d = b.toJSON();delete d.metadata;c[b.uuid] = d;a.materials.push(d);\n      }return b.uuid;\n    },\n        e = function e(c) {\n      var g = {};g.uuid = c.uuid;g.type = c.type;\"\" !== c.name && (g.name = c.name);\"{}\" !== JSON.stringify(c.userData) && (g.userData = c.userData);!0 !== c.visible && (g.visible = c.visible);if (c instanceof THREE.PerspectiveCamera) g.fov = c.fov, g.aspect = c.aspect, g.near = c.near, g.far = c.far;else if (c instanceof THREE.OrthographicCamera) g.left = c.left, g.right = c.right, g.top = c.top, g.bottom = c.bottom, g.near = c.near, g.far = c.far;else if (c instanceof THREE.AmbientLight) g.color = c.color.getHex();else if (c instanceof THREE.DirectionalLight) g.color = c.color.getHex(), g.intensity = c.intensity;else if (c instanceof THREE.PointLight) g.color = c.color.getHex(), g.intensity = c.intensity, g.distance = c.distance, g.decay = c.decay;else if (c instanceof THREE.SpotLight) g.color = c.color.getHex(), g.intensity = c.intensity, g.distance = c.distance, g.angle = c.angle, g.exponent = c.exponent, g.decay = c.decay;else if (c instanceof THREE.HemisphereLight) g.color = c.color.getHex(), g.groundColor = c.groundColor.getHex();else if (c instanceof THREE.Mesh || c instanceof THREE.Line || c instanceof THREE.PointCloud) {\n        var h = c.geometry;void 0 === a.geometries && (a.geometries = []);if (void 0 === b[h.uuid]) {\n          var k = h.toJSON();delete k.metadata;b[h.uuid] = k;a.geometries.push(k);\n        }g.geometry = h.uuid;g.material = d(c.material);c instanceof THREE.Line && (g.mode = c.mode);\n      } else c instanceof THREE.Sprite && (g.material = d(c.material));g.matrix = c.matrix.toArray();if (0 < c.children.length) for (g.children = [], h = 0; h < c.children.length; h++) {\n        g.children.push(e(c.children[h]));\n      }return g;\n    };a.object = e(this);return a;\n  }, clone: function clone(a, b) {\n    void 0 === a && (a = new THREE.Object3D());void 0 === b && (b = !0);a.name = this.name;a.up.copy(this.up);a.position.copy(this.position);a.quaternion.copy(this.quaternion);a.scale.copy(this.scale);a.rotationAutoUpdate = this.rotationAutoUpdate;a.matrix.copy(this.matrix);\n    a.matrixWorld.copy(this.matrixWorld);a.matrixAutoUpdate = this.matrixAutoUpdate;a.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;a.visible = this.visible;a.castShadow = this.castShadow;a.receiveShadow = this.receiveShadow;a.frustumCulled = this.frustumCulled;a.userData = JSON.parse(JSON.stringify(this.userData));if (!0 === b) for (var c = 0; c < this.children.length; c++) {\n      a.add(this.children[c].clone());\n    }return a;\n  } };THREE.EventDispatcher.prototype.apply(THREE.Object3D.prototype);THREE.Object3DIdCount = 0;\nTHREE.Face3 = function (a, b, c, d, e, f) {\n  this.a = a;this.b = b;this.c = c;this.normal = d instanceof THREE.Vector3 ? d : new THREE.Vector3();this.vertexNormals = d instanceof Array ? d : [];this.color = e instanceof THREE.Color ? e : new THREE.Color();this.vertexColors = e instanceof Array ? e : [];this.vertexTangents = [];this.materialIndex = void 0 !== f ? f : 0;\n};\nTHREE.Face3.prototype = { constructor: THREE.Face3, clone: function clone() {\n    var a = new THREE.Face3(this.a, this.b, this.c);a.normal.copy(this.normal);a.color.copy(this.color);a.materialIndex = this.materialIndex;for (var b = 0, c = this.vertexNormals.length; b < c; b++) {\n      a.vertexNormals[b] = this.vertexNormals[b].clone();\n    }b = 0;for (c = this.vertexColors.length; b < c; b++) {\n      a.vertexColors[b] = this.vertexColors[b].clone();\n    }b = 0;for (c = this.vertexTangents.length; b < c; b++) {\n      a.vertexTangents[b] = this.vertexTangents[b].clone();\n    }return a;\n  } };\nTHREE.Face4 = function (a, b, c, d, e, f, g) {\n  THREE.warn(\"THREE.Face4 has been removed. A THREE.Face3 will be created instead.\");return new THREE.Face3(a, b, c, e, f, g);\n};THREE.BufferAttribute = function (a, b) {\n  this.array = a;this.itemSize = b;this.needsUpdate = !1;\n};\nTHREE.BufferAttribute.prototype = { constructor: THREE.BufferAttribute, get length() {\n    return this.array.length;\n  }, copyAt: function copyAt(a, b, c) {\n    a *= this.itemSize;c *= b.itemSize;for (var d = 0, e = this.itemSize; d < e; d++) {\n      this.array[a + d] = b.array[c + d];\n    }return this;\n  }, set: function set(a, b) {\n    void 0 === b && (b = 0);this.array.set(a, b);return this;\n  }, setX: function setX(a, b) {\n    this.array[a * this.itemSize] = b;return this;\n  }, setY: function setY(a, b) {\n    this.array[a * this.itemSize + 1] = b;return this;\n  }, setZ: function setZ(a, b) {\n    this.array[a * this.itemSize + 2] = b;return this;\n  }, setXY: function setXY(a, b, c) {\n    a *= this.itemSize;this.array[a] = b;this.array[a + 1] = c;return this;\n  }, setXYZ: function setXYZ(a, b, c, d) {\n    a *= this.itemSize;this.array[a] = b;this.array[a + 1] = c;this.array[a + 2] = d;return this;\n  }, setXYZW: function setXYZW(a, b, c, d, e) {\n    a *= this.itemSize;this.array[a] = b;this.array[a + 1] = c;this.array[a + 2] = d;this.array[a + 3] = e;return this;\n  }, clone: function clone() {\n    return new THREE.BufferAttribute(new this.array.constructor(this.array), this.itemSize);\n  } };\nTHREE.Int8Attribute = function (a, b) {\n  THREE.warn(\"THREE.Int8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.\");return new THREE.BufferAttribute(a, b);\n};THREE.Uint8Attribute = function (a, b) {\n  THREE.warn(\"THREE.Uint8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.\");return new THREE.BufferAttribute(a, b);\n};\nTHREE.Uint8ClampedAttribute = function (a, b) {\n  THREE.warn(\"THREE.Uint8ClampedAttribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.\");return new THREE.BufferAttribute(a, b);\n};THREE.Int16Attribute = function (a, b) {\n  THREE.warn(\"THREE.Int16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.\");return new THREE.BufferAttribute(a, b);\n};\nTHREE.Uint16Attribute = function (a, b) {\n  THREE.warn(\"THREE.Uint16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.\");return new THREE.BufferAttribute(a, b);\n};THREE.Int32Attribute = function (a, b) {\n  THREE.warn(\"THREE.Int32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.\");return new THREE.BufferAttribute(a, b);\n};\nTHREE.Uint32Attribute = function (a, b) {\n  THREE.warn(\"THREE.Uint32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.\");return new THREE.BufferAttribute(a, b);\n};THREE.Float32Attribute = function (a, b) {\n  THREE.warn(\"THREE.Float32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.\");return new THREE.BufferAttribute(a, b);\n};\nTHREE.Float64Attribute = function (a, b) {\n  THREE.warn(\"THREE.Float64Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.\");return new THREE.BufferAttribute(a, b);\n};THREE.DynamicBufferAttribute = function (a, b) {\n  THREE.BufferAttribute.call(this, a, b);this.updateRange = { offset: 0, count: -1 };\n};THREE.DynamicBufferAttribute.prototype = Object.create(THREE.BufferAttribute.prototype);THREE.DynamicBufferAttribute.prototype.constructor = THREE.DynamicBufferAttribute;\nTHREE.DynamicBufferAttribute.prototype.clone = function () {\n  return new THREE.DynamicBufferAttribute(new this.array.constructor(this.array), this.itemSize);\n};THREE.BufferGeometry = function () {\n  Object.defineProperty(this, \"id\", { value: THREE.GeometryIdCount++ });this.uuid = THREE.Math.generateUUID();this.name = \"\";this.type = \"BufferGeometry\";this.attributes = {};this.attributesKeys = [];this.offsets = this.drawcalls = [];this.boundingSphere = this.boundingBox = null;\n};\nTHREE.BufferGeometry.prototype = { constructor: THREE.BufferGeometry, addAttribute: function addAttribute(a, b, c) {\n    !1 === b instanceof THREE.BufferAttribute ? (THREE.warn(\"THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).\"), this.attributes[a] = { array: b, itemSize: c }) : (this.attributes[a] = b, this.attributesKeys = Object.keys(this.attributes));\n  }, getAttribute: function getAttribute(a) {\n    return this.attributes[a];\n  }, addDrawCall: function addDrawCall(a, b, c) {\n    this.drawcalls.push({ start: a, count: b, index: void 0 !== c ? c : 0 });\n  }, applyMatrix: function applyMatrix(a) {\n    var b = this.attributes.position;void 0 !== b && (a.applyToVector3Array(b.array), b.needsUpdate = !0);b = this.attributes.normal;void 0 !== b && (new THREE.Matrix3().getNormalMatrix(a).applyToVector3Array(b.array), b.needsUpdate = !0);null !== this.boundingBox && this.computeBoundingBox();null !== this.boundingSphere && this.computeBoundingSphere();\n  }, center: function center() {\n    this.computeBoundingBox();var a = this.boundingBox.center().negate();this.applyMatrix(new THREE.Matrix4().setPosition(a));return a;\n  }, fromGeometry: function fromGeometry(a, b) {\n    b = b || { vertexColors: THREE.NoColors };\n    var c = a.vertices,\n        d = a.faces,\n        e = a.faceVertexUvs,\n        f = b.vertexColors,\n        g = 0 < e[0].length,\n        h = 3 == d[0].vertexNormals.length,\n        k = new Float32Array(9 * d.length);this.addAttribute(\"position\", new THREE.BufferAttribute(k, 3));var l = new Float32Array(9 * d.length);this.addAttribute(\"normal\", new THREE.BufferAttribute(l, 3));if (f !== THREE.NoColors) {\n      var p = new Float32Array(9 * d.length);this.addAttribute(\"color\", new THREE.BufferAttribute(p, 3));\n    }if (!0 === g) {\n      var q = new Float32Array(6 * d.length);this.addAttribute(\"uv\", new THREE.BufferAttribute(q, 2));\n    }for (var n = 0, t = 0, r = 0; n < d.length; n++, t += 6, r += 9) {\n      var s = d[n],\n          u = c[s.a],\n          v = c[s.b],\n          x = c[s.c];k[r] = u.x;k[r + 1] = u.y;k[r + 2] = u.z;k[r + 3] = v.x;k[r + 4] = v.y;k[r + 5] = v.z;k[r + 6] = x.x;k[r + 7] = x.y;k[r + 8] = x.z;!0 === h ? (u = s.vertexNormals[0], v = s.vertexNormals[1], x = s.vertexNormals[2], l[r] = u.x, l[r + 1] = u.y, l[r + 2] = u.z, l[r + 3] = v.x, l[r + 4] = v.y, l[r + 5] = v.z, l[r + 6] = x.x, l[r + 7] = x.y, l[r + 8] = x.z) : (u = s.normal, l[r] = u.x, l[r + 1] = u.y, l[r + 2] = u.z, l[r + 3] = u.x, l[r + 4] = u.y, l[r + 5] = u.z, l[r + 6] = u.x, l[r + 7] = u.y, l[r + 8] = u.z);f === THREE.FaceColors ? (s = s.color, p[r] = s.r, p[r + 1] = s.g, p[r + 2] = s.b, p[r + 3] = s.r, p[r + 4] = s.g, p[r + 5] = s.b, p[r + 6] = s.r, p[r + 7] = s.g, p[r + 8] = s.b) : f === THREE.VertexColors && (u = s.vertexColors[0], v = s.vertexColors[1], s = s.vertexColors[2], p[r] = u.r, p[r + 1] = u.g, p[r + 2] = u.b, p[r + 3] = v.r, p[r + 4] = v.g, p[r + 5] = v.b, p[r + 6] = s.r, p[r + 7] = s.g, p[r + 8] = s.b);!0 === g && (s = e[0][n][0], u = e[0][n][1], v = e[0][n][2], q[t] = s.x, q[t + 1] = s.y, q[t + 2] = u.x, q[t + 3] = u.y, q[t + 4] = v.x, q[t + 5] = v.y);\n    }this.computeBoundingSphere();return this;\n  }, computeBoundingBox: function () {\n    var a = new THREE.Vector3();return function () {\n      null === this.boundingBox && (this.boundingBox = new THREE.Box3());var b = this.attributes.position.array;if (b) {\n        var c = this.boundingBox;c.makeEmpty();for (var d = 0, e = b.length; d < e; d += 3) {\n          a.set(b[d], b[d + 1], b[d + 2]), c.expandByPoint(a);\n        }\n      }if (void 0 === b || 0 === b.length) this.boundingBox.min.set(0, 0, 0), this.boundingBox.max.set(0, 0, 0);(isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && THREE.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.');\n    };\n  }(),\n  computeBoundingSphere: function () {\n    var a = new THREE.Box3(),\n        b = new THREE.Vector3();return function () {\n      null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere());var c = this.attributes.position.array;if (c) {\n        a.makeEmpty();for (var d = this.boundingSphere.center, e = 0, f = c.length; e < f; e += 3) {\n          b.set(c[e], c[e + 1], c[e + 2]), a.expandByPoint(b);\n        }a.center(d);for (var g = 0, e = 0, f = c.length; e < f; e += 3) {\n          b.set(c[e], c[e + 1], c[e + 2]), g = Math.max(g, d.distanceToSquared(b));\n        }this.boundingSphere.radius = Math.sqrt(g);isNaN(this.boundingSphere.radius) && THREE.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.');\n      }\n    };\n  }(), computeFaceNormals: function computeFaceNormals() {}, computeVertexNormals: function computeVertexNormals() {\n    var a = this.attributes;if (a.position) {\n      var b = a.position.array;if (void 0 === a.normal) this.addAttribute(\"normal\", new THREE.BufferAttribute(new Float32Array(b.length), 3));else for (var c = a.normal.array, d = 0, e = c.length; d < e; d++) {\n        c[d] = 0;\n      }var c = a.normal.array,\n          f,\n          g,\n          h,\n          k = new THREE.Vector3(),\n          l = new THREE.Vector3(),\n          p = new THREE.Vector3(),\n          q = new THREE.Vector3(),\n          n = new THREE.Vector3();if (a.index) for (var t = a.index.array, r = 0 < this.offsets.length ? this.offsets : [{ start: 0, count: t.length, index: 0 }], s = 0, u = r.length; s < u; ++s) {\n        e = r[s].start;f = r[s].count;for (var v = r[s].index, d = e, e = e + f; d < e; d += 3) {\n          f = 3 * (v + t[d]), g = 3 * (v + t[d + 1]), h = 3 * (v + t[d + 2]), k.fromArray(b, f), l.fromArray(b, g), p.fromArray(b, h), q.subVectors(p, l), n.subVectors(k, l), q.cross(n), c[f] += q.x, c[f + 1] += q.y, c[f + 2] += q.z, c[g] += q.x, c[g + 1] += q.y, c[g + 2] += q.z, c[h] += q.x, c[h + 1] += q.y, c[h + 2] += q.z;\n        }\n      } else for (d = 0, e = b.length; d < e; d += 9) {\n        k.fromArray(b, d), l.fromArray(b, d + 3), p.fromArray(b, d + 6), q.subVectors(p, l), n.subVectors(k, l), q.cross(n), c[d] = q.x, c[d + 1] = q.y, c[d + 2] = q.z, c[d + 3] = q.x, c[d + 4] = q.y, c[d + 5] = q.z, c[d + 6] = q.x, c[d + 7] = q.y, c[d + 8] = q.z;\n      }this.normalizeNormals();a.normal.needsUpdate = !0;\n    }\n  }, computeTangents: function computeTangents() {\n    function a(a, b, c) {\n      q.fromArray(d, 3 * a);n.fromArray(d, 3 * b);t.fromArray(d, 3 * c);r.fromArray(f, 2 * a);s.fromArray(f, 2 * b);u.fromArray(f, 2 * c);v = n.x - q.x;x = t.x - q.x;D = n.y - q.y;w = t.y - q.y;y = n.z - q.z;A = t.z - q.z;E = s.x - r.x;G = u.x - r.x;F = s.y - r.y;z = u.y - r.y;I = 1 / (E * z - G * F);U.set((z * v - F * x) * I, (z * D - F * w) * I, (z * y - F * A) * I);M.set((E * x - G * v) * I, (E * w - G * D) * I, (E * A - G * y) * I);k[a].add(U);k[b].add(U);k[c].add(U);l[a].add(M);l[b].add(M);l[c].add(M);\n    }function b(a) {\n      ha.fromArray(e, 3 * a);O.copy(ha);ba = k[a];oa.copy(ba);oa.sub(ha.multiplyScalar(ha.dot(ba))).normalize();ja.crossVectors(O, ba);qa = ja.dot(l[a]);ca = 0 > qa ? -1 : 1;h[4 * a] = oa.x;h[4 * a + 1] = oa.y;h[4 * a + 2] = oa.z;h[4 * a + 3] = ca;\n    }if (void 0 === this.attributes.index || void 0 === this.attributes.position || void 0 === this.attributes.normal || void 0 === this.attributes.uv) THREE.warn(\"THREE.BufferGeometry: Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()\");else {\n      var c = this.attributes.index.array,\n          d = this.attributes.position.array,\n          e = this.attributes.normal.array,\n          f = this.attributes.uv.array,\n          g = d.length / 3;void 0 === this.attributes.tangent && this.addAttribute(\"tangent\", new THREE.BufferAttribute(new Float32Array(4 * g), 4));for (var h = this.attributes.tangent.array, k = [], l = [], p = 0; p < g; p++) {\n        k[p] = new THREE.Vector3(), l[p] = new THREE.Vector3();\n      }var q = new THREE.Vector3(),\n          n = new THREE.Vector3(),\n          t = new THREE.Vector3(),\n          r = new THREE.Vector2(),\n          s = new THREE.Vector2(),\n          u = new THREE.Vector2(),\n          v,\n          x,\n          D,\n          w,\n          y,\n          A,\n          E,\n          G,\n          F,\n          z,\n          I,\n          U = new THREE.Vector3(),\n          M = new THREE.Vector3(),\n          H,\n          L,\n          P,\n          N,\n          R;0 === this.drawcalls.length && this.addDrawCall(0, c.length, 0);var V = this.drawcalls,\n          p = 0;for (L = V.length; p < L; ++p) {\n        H = V[p].start;P = V[p].count;var J = V[p].index,\n            g = H;for (H += P; g < H; g += 3) {\n          P = J + c[g], N = J + c[g + 1], R = J + c[g + 2], a(P, N, R);\n        }\n      }var oa = new THREE.Vector3(),\n          ja = new THREE.Vector3(),\n          ha = new THREE.Vector3(),\n          O = new THREE.Vector3(),\n          ca,\n          ba,\n          qa,\n          p = 0;for (L = V.length; p < L; ++p) {\n        for (H = V[p].start, P = V[p].count, J = V[p].index, g = H, H += P; g < H; g += 3) {\n          P = J + c[g], N = J + c[g + 1], R = J + c[g + 2], b(P), b(N), b(R);\n        }\n      }\n    }\n  }, computeOffsets: function computeOffsets(a) {\n    void 0 === a && (a = 65535);for (var b = this.attributes.index.array, c = this.attributes.position.array, d = b.length / 3, e = new Uint16Array(b.length), f = 0, g = 0, h = [{ start: 0, count: 0, index: 0 }], k = h[0], l = 0, p = 0, q = new Int32Array(6), n = new Int32Array(c.length), t = new Int32Array(c.length), r = 0; r < c.length; r++) {\n      n[r] = -1, t[r] = -1;\n    }for (c = 0; c < d; c++) {\n      for (var s = p = 0; 3 > s; s++) {\n        r = b[3 * c + s], -1 == n[r] ? (q[2 * s] = r, q[2 * s + 1] = -1, p++) : n[r] < k.index ? (q[2 * s] = r, q[2 * s + 1] = -1, l++) : (q[2 * s] = r, q[2 * s + 1] = n[r]);\n      }if (g + p > k.index + a) for (k = { start: f, count: 0, index: g }, h.push(k), p = 0; 6 > p; p += 2) {\n        s = q[p + 1], -1 < s && s < k.index && (q[p + 1] = -1);\n      }for (p = 0; 6 > p; p += 2) {\n        r = q[p], s = q[p + 1], -1 === s && (s = g++), n[r] = s, t[s] = r, e[f++] = s - k.index, k.count++;\n      }\n    }this.reorderBuffers(e, t, g);return this.drawcalls = this.offsets = h;\n  }, merge: function merge(a, b) {\n    if (!1 === a instanceof THREE.BufferGeometry) THREE.error(\"THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.\", a);else {\n      void 0 === b && (b = 0);var c = this.attributes,\n          d;for (d in c) {\n        if (void 0 !== a.attributes[d]) for (var e = c[d].array, f = a.attributes[d], g = f.array, h = 0, f = f.itemSize * b; h < g.length; h++, f++) {\n          e[f] = g[h];\n        }\n      }return this;\n    }\n  }, normalizeNormals: function normalizeNormals() {\n    for (var a = this.attributes.normal.array, b, c, d, e = 0, f = a.length; e < f; e += 3) {\n      b = a[e], c = a[e + 1], d = a[e + 2], b = 1 / Math.sqrt(b * b + c * c + d * d), a[e] *= b, a[e + 1] *= b, a[e + 2] *= b;\n    }\n  }, reorderBuffers: function reorderBuffers(a, b, c) {\n    var d = {},\n        e;for (e in this.attributes) {\n      \"index\" != e && (d[e] = new this.attributes[e].array.constructor(this.attributes[e].itemSize * c));\n    }for (var f = 0; f < c; f++) {\n      var g = b[f];for (e in this.attributes) {\n        if (\"index\" != e) for (var h = this.attributes[e].array, k = this.attributes[e].itemSize, l = d[e], p = 0; p < k; p++) {\n          l[f * k + p] = h[g * k + p];\n        }\n      }\n    }this.attributes.index.array = a;for (e in this.attributes) {\n      \"index\" != e && (this.attributes[e].array = d[e], this.attributes[e].numItems = this.attributes[e].itemSize * c);\n    }\n  }, toJSON: function toJSON() {\n    var a = { metadata: { version: 4, type: \"BufferGeometry\", generator: \"BufferGeometryExporter\" }, uuid: this.uuid, type: this.type, data: { attributes: {} } },\n        b = this.attributes,\n        c = this.offsets,\n        d = this.boundingSphere,\n        e;for (e in b) {\n      var f = b[e],\n          g = Array.prototype.slice.call(f.array);a.data.attributes[e] = { itemSize: f.itemSize, type: f.array.constructor.name, array: g };\n    }0 < c.length && (a.data.offsets = JSON.parse(JSON.stringify(c)));null !== d && (a.data.boundingSphere = { center: d.center.toArray(), radius: d.radius });return a;\n  }, clone: function clone() {\n    var a = new THREE.BufferGeometry(),\n        b;for (b in this.attributes) {\n      a.addAttribute(b, this.attributes[b].clone());\n    }b = 0;for (var c = this.offsets.length; b < c; b++) {\n      var d = this.offsets[b];\n      a.offsets.push({ start: d.start, index: d.index, count: d.count });\n    }return a;\n  }, dispose: function dispose() {\n    this.dispatchEvent({ type: \"dispose\" });\n  } };THREE.EventDispatcher.prototype.apply(THREE.BufferGeometry.prototype);\nTHREE.Geometry = function () {\n  Object.defineProperty(this, \"id\", { value: THREE.GeometryIdCount++ });this.uuid = THREE.Math.generateUUID();this.name = \"\";this.type = \"Geometry\";this.vertices = [];this.colors = [];this.faces = [];this.faceVertexUvs = [[]];this.morphTargets = [];this.morphColors = [];this.morphNormals = [];this.skinWeights = [];this.skinIndices = [];this.lineDistances = [];this.boundingSphere = this.boundingBox = null;this.hasTangents = !1;this.dynamic = !0;this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.tangentsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.elementsNeedUpdate = this.verticesNeedUpdate = !1;\n};\nTHREE.Geometry.prototype = { constructor: THREE.Geometry, applyMatrix: function applyMatrix(a) {\n    for (var b = new THREE.Matrix3().getNormalMatrix(a), c = 0, d = this.vertices.length; c < d; c++) {\n      this.vertices[c].applyMatrix4(a);\n    }c = 0;for (d = this.faces.length; c < d; c++) {\n      a = this.faces[c];a.normal.applyMatrix3(b).normalize();for (var e = 0, f = a.vertexNormals.length; e < f; e++) {\n        a.vertexNormals[e].applyMatrix3(b).normalize();\n      }\n    }null !== this.boundingBox && this.computeBoundingBox();null !== this.boundingSphere && this.computeBoundingSphere();this.normalsNeedUpdate = this.verticesNeedUpdate = !0;\n  }, fromBufferGeometry: function fromBufferGeometry(a) {\n    for (var b = this, c = a.attributes, d = c.position.array, e = void 0 !== c.index ? c.index.array : void 0, f = void 0 !== c.normal ? c.normal.array : void 0, g = void 0 !== c.color ? c.color.array : void 0, h = void 0 !== c.uv ? c.uv.array : void 0, k = [], l = [], p = c = 0; c < d.length; c += 3, p += 2) {\n      b.vertices.push(new THREE.Vector3(d[c], d[c + 1], d[c + 2])), void 0 !== f && k.push(new THREE.Vector3(f[c], f[c + 1], f[c + 2])), void 0 !== g && b.colors.push(new THREE.Color(g[c], g[c + 1], g[c + 2])), void 0 !== h && l.push(new THREE.Vector2(h[p], h[p + 1]));\n    }var q = function q(a, c, d) {\n      var e = void 0 !== f ? [k[a].clone(), k[c].clone(), k[d].clone()] : [],\n          n = void 0 !== g ? [b.colors[a].clone(), b.colors[c].clone(), b.colors[d].clone()] : [];b.faces.push(new THREE.Face3(a, c, d, e, n));void 0 !== h && b.faceVertexUvs[0].push([l[a].clone(), l[c].clone(), l[d].clone()]);\n    };if (void 0 !== e) {\n      if (d = a.drawcalls, 0 < d.length) for (c = 0; c < d.length; c++) {\n        for (var p = d[c], n = p.start, t = p.count, r = p.index, p = n, n = n + t; p < n; p += 3) {\n          q(r + e[p], r + e[p + 1], r + e[p + 2]);\n        }\n      } else for (c = 0; c < e.length; c += 3) {\n        q(e[c], e[c + 1], e[c + 2]);\n      }\n    } else for (c = 0; c < d.length / 3; c += 3) {\n      q(c, c + 1, c + 2);\n    }this.computeFaceNormals();null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone());null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone());return this;\n  }, center: function center() {\n    this.computeBoundingBox();var a = this.boundingBox.center().negate();this.applyMatrix(new THREE.Matrix4().setPosition(a));return a;\n  }, computeFaceNormals: function computeFaceNormals() {\n    for (var a = new THREE.Vector3(), b = new THREE.Vector3(), c = 0, d = this.faces.length; c < d; c++) {\n      var e = this.faces[c],\n          f = this.vertices[e.a],\n          g = this.vertices[e.b];a.subVectors(this.vertices[e.c], g);b.subVectors(f, g);a.cross(b);a.normalize();e.normal.copy(a);\n    }\n  }, computeVertexNormals: function computeVertexNormals(a) {\n    var b, c, d;d = Array(this.vertices.length);b = 0;for (c = this.vertices.length; b < c; b++) {\n      d[b] = new THREE.Vector3();\n    }if (a) {\n      var e,\n          f,\n          g,\n          h = new THREE.Vector3(),\n          k = new THREE.Vector3();a = 0;for (b = this.faces.length; a < b; a++) {\n        c = this.faces[a], e = this.vertices[c.a], f = this.vertices[c.b], g = this.vertices[c.c], h.subVectors(g, f), k.subVectors(e, f), h.cross(k), d[c.a].add(h), d[c.b].add(h), d[c.c].add(h);\n      }\n    } else for (a = 0, b = this.faces.length; a < b; a++) {\n      c = this.faces[a], d[c.a].add(c.normal), d[c.b].add(c.normal), d[c.c].add(c.normal);\n    }b = 0;for (c = this.vertices.length; b < c; b++) {\n      d[b].normalize();\n    }a = 0;for (b = this.faces.length; a < b; a++) {\n      c = this.faces[a], c.vertexNormals[0] = d[c.a].clone(), c.vertexNormals[1] = d[c.b].clone(), c.vertexNormals[2] = d[c.c].clone();\n    }\n  }, computeMorphNormals: function computeMorphNormals() {\n    var a, b, c, d, e;c = 0;for (d = this.faces.length; c < d; c++) {\n      for (e = this.faces[c], e.__originalFaceNormal ? e.__originalFaceNormal.copy(e.normal) : e.__originalFaceNormal = e.normal.clone(), e.__originalVertexNormals || (e.__originalVertexNormals = []), a = 0, b = e.vertexNormals.length; a < b; a++) {\n        e.__originalVertexNormals[a] ? e.__originalVertexNormals[a].copy(e.vertexNormals[a]) : e.__originalVertexNormals[a] = e.vertexNormals[a].clone();\n      }\n    }var f = new THREE.Geometry();f.faces = this.faces;a = 0;for (b = this.morphTargets.length; a < b; a++) {\n      if (!this.morphNormals[a]) {\n        this.morphNormals[a] = {};this.morphNormals[a].faceNormals = [];this.morphNormals[a].vertexNormals = [];e = this.morphNormals[a].faceNormals;var g = this.morphNormals[a].vertexNormals,\n            h,\n            k;c = 0;for (d = this.faces.length; c < d; c++) {\n          h = new THREE.Vector3(), k = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() }, e.push(h), g.push(k);\n        }\n      }g = this.morphNormals[a];f.vertices = this.morphTargets[a].vertices;f.computeFaceNormals();f.computeVertexNormals();c = 0;for (d = this.faces.length; c < d; c++) {\n        e = this.faces[c], h = g.faceNormals[c], k = g.vertexNormals[c], h.copy(e.normal), k.a.copy(e.vertexNormals[0]), k.b.copy(e.vertexNormals[1]), k.c.copy(e.vertexNormals[2]);\n      }\n    }c = 0;for (d = this.faces.length; c < d; c++) {\n      e = this.faces[c], e.normal = e.__originalFaceNormal, e.vertexNormals = e.__originalVertexNormals;\n    }\n  }, computeTangents: function computeTangents() {\n    var a,\n        b,\n        c,\n        d,\n        e,\n        f,\n        g,\n        h,\n        k,\n        l,\n        p,\n        q,\n        n,\n        t,\n        r,\n        s,\n        u,\n        v = [],\n        x = [];c = new THREE.Vector3();var D = new THREE.Vector3(),\n        w = new THREE.Vector3(),\n        y = new THREE.Vector3(),\n        A = new THREE.Vector3();a = 0;for (b = this.vertices.length; a < b; a++) {\n      v[a] = new THREE.Vector3(), x[a] = new THREE.Vector3();\n    }a = 0;for (b = this.faces.length; a < b; a++) {\n      e = this.faces[a], f = this.faceVertexUvs[0][a], d = e.a, u = e.b, e = e.c, g = this.vertices[d], h = this.vertices[u], k = this.vertices[e], l = f[0], p = f[1], q = f[2], f = h.x - g.x, n = k.x - g.x, t = h.y - g.y, r = k.y - g.y, h = h.z - g.z, g = k.z - g.z, k = p.x - l.x, s = q.x - l.x, p = p.y - l.y, l = q.y - l.y, q = 1 / (k * l - s * p), c.set((l * f - p * n) * q, (l * t - p * r) * q, (l * h - p * g) * q), D.set((k * n - s * f) * q, (k * r - s * t) * q, (k * g - s * h) * q), v[d].add(c), v[u].add(c), v[e].add(c), x[d].add(D), x[u].add(D), x[e].add(D);\n    }D = [\"a\", \"b\", \"c\", \"d\"];a = 0;for (b = this.faces.length; a < b; a++) {\n      for (e = this.faces[a], c = 0; c < Math.min(e.vertexNormals.length, 3); c++) {\n        A.copy(e.vertexNormals[c]), d = e[D[c]], u = v[d], w.copy(u), w.sub(A.multiplyScalar(A.dot(u))).normalize(), y.crossVectors(e.vertexNormals[c], u), d = y.dot(x[d]), d = 0 > d ? -1 : 1, e.vertexTangents[c] = new THREE.Vector4(w.x, w.y, w.z, d);\n      }\n    }this.hasTangents = !0;\n  }, computeLineDistances: function computeLineDistances() {\n    for (var a = 0, b = this.vertices, c = 0, d = b.length; c < d; c++) {\n      0 < c && (a += b[c].distanceTo(b[c - 1])), this.lineDistances[c] = a;\n    }\n  }, computeBoundingBox: function computeBoundingBox() {\n    null === this.boundingBox && (this.boundingBox = new THREE.Box3());this.boundingBox.setFromPoints(this.vertices);\n  }, computeBoundingSphere: function computeBoundingSphere() {\n    null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere());\n    this.boundingSphere.setFromPoints(this.vertices);\n  }, merge: function merge(a, b, c) {\n    if (!1 === a instanceof THREE.Geometry) THREE.error(\"THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.\", a);else {\n      var d,\n          e = this.vertices.length,\n          f = this.vertices,\n          g = a.vertices,\n          h = this.faces,\n          k = a.faces,\n          l = this.faceVertexUvs[0];a = a.faceVertexUvs[0];void 0 === c && (c = 0);void 0 !== b && (d = new THREE.Matrix3().getNormalMatrix(b));for (var p = 0, q = g.length; p < q; p++) {\n        var n = g[p].clone();void 0 !== b && n.applyMatrix4(b);f.push(n);\n      }p = 0;for (q = k.length; p < q; p++) {\n        var g = k[p],\n            t,\n            r = g.vertexNormals,\n            s = g.vertexColors,\n            n = new THREE.Face3(g.a + e, g.b + e, g.c + e);n.normal.copy(g.normal);void 0 !== d && n.normal.applyMatrix3(d).normalize();b = 0;for (f = r.length; b < f; b++) {\n          t = r[b].clone(), void 0 !== d && t.applyMatrix3(d).normalize(), n.vertexNormals.push(t);\n        }n.color.copy(g.color);b = 0;for (f = s.length; b < f; b++) {\n          t = s[b], n.vertexColors.push(t.clone());\n        }n.materialIndex = g.materialIndex + c;h.push(n);\n      }p = 0;for (q = a.length; p < q; p++) {\n        if (c = a[p], d = [], void 0 !== c) {\n          b = 0;for (f = c.length; b < f; b++) {\n            d.push(c[b].clone());\n          }l.push(d);\n        }\n      }\n    }\n  }, mergeMesh: function mergeMesh(a) {\n    !1 === a instanceof THREE.Mesh ? THREE.error(\"THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.\", a) : (a.matrixAutoUpdate && a.updateMatrix(), this.merge(a.geometry, a.matrix));\n  }, mergeVertices: function mergeVertices() {\n    var a = {},\n        b = [],\n        c = [],\n        d,\n        e = Math.pow(10, 4),\n        f,\n        g;f = 0;for (g = this.vertices.length; f < g; f++) {\n      d = this.vertices[f], d = Math.round(d.x * e) + \"_\" + Math.round(d.y * e) + \"_\" + Math.round(d.z * e), void 0 === a[d] ? (a[d] = f, b.push(this.vertices[f]), c[f] = b.length - 1) : c[f] = c[a[d]];\n    }a = [];f = 0;for (g = this.faces.length; f < g; f++) {\n      for (e = this.faces[f], e.a = c[e.a], e.b = c[e.b], e.c = c[e.c], e = [e.a, e.b, e.c], d = 0; 3 > d; d++) {\n        if (e[d] == e[(d + 1) % 3]) {\n          a.push(f);break;\n        }\n      }\n    }for (f = a.length - 1; 0 <= f; f--) {\n      for (e = a[f], this.faces.splice(e, 1), c = 0, g = this.faceVertexUvs.length; c < g; c++) {\n        this.faceVertexUvs[c].splice(e, 1);\n      }\n    }f = this.vertices.length - b.length;this.vertices = b;return f;\n  }, toJSON: function toJSON() {\n    function a(a, b, c) {\n      return c ? a | 1 << b : a & ~(1 << b);\n    }function b(a) {\n      var b = a.x.toString() + a.y.toString() + a.z.toString();if (void 0 !== l[b]) return l[b];l[b] = k.length / 3;k.push(a.x, a.y, a.z);return l[b];\n    }function c(a) {\n      var b = a.r.toString() + a.g.toString() + a.b.toString();if (void 0 !== q[b]) return q[b];q[b] = p.length;p.push(a.getHex());return q[b];\n    }function d(a) {\n      var b = a.x.toString() + a.y.toString();if (void 0 !== t[b]) return t[b];t[b] = n.length / 2;n.push(a.x, a.y);return t[b];\n    }var e = { metadata: { version: 4, type: \"BufferGeometry\", generator: \"BufferGeometryExporter\" }, uuid: this.uuid, type: this.type };\"\" !== this.name && (e.name = this.name);if (void 0 !== this.parameters) {\n      var f = this.parameters,\n          g;for (g in f) {\n        void 0 !== f[g] && (e[g] = f[g]);\n      }return e;\n    }f = [];for (g = 0; g < this.vertices.length; g++) {\n      var h = this.vertices[g];f.push(h.x, h.y, h.z);\n    }var h = [],\n        k = [],\n        l = {},\n        p = [],\n        q = {},\n        n = [],\n        t = {};for (g = 0; g < this.faces.length; g++) {\n      var r = this.faces[g],\n          s = void 0 !== this.faceVertexUvs[0][g],\n          u = 0 < r.normal.length(),\n          v = 0 < r.vertexNormals.length,\n          x = 1 !== r.color.r || 1 !== r.color.g || 1 !== r.color.b,\n          D = 0 < r.vertexColors.length,\n          w = 0,\n          w = a(w, 0, 0),\n          w = a(w, 1, !1),\n          w = a(w, 2, !1),\n          w = a(w, 3, s),\n          w = a(w, 4, u),\n          w = a(w, 5, v),\n          w = a(w, 6, x),\n          w = a(w, 7, D);h.push(w);h.push(r.a, r.b, r.c);s && (s = this.faceVertexUvs[0][g], h.push(d(s[0]), d(s[1]), d(s[2])));u && h.push(b(r.normal));v && (u = r.vertexNormals, h.push(b(u[0]), b(u[1]), b(u[2])));x && h.push(c(r.color));D && (r = r.vertexColors, h.push(c(r[0]), c(r[1]), c(r[2])));\n    }e.data = {};e.data.vertices = f;e.data.normals = k;0 < p.length && (e.data.colors = p);0 < n.length && (e.data.uvs = [n]);e.data.faces = h;return e;\n  }, clone: function clone() {\n    for (var a = new THREE.Geometry(), b = this.vertices, c = 0, d = b.length; c < d; c++) {\n      a.vertices.push(b[c].clone());\n    }b = this.faces;c = 0;for (d = b.length; c < d; c++) {\n      a.faces.push(b[c].clone());\n    }c = 0;\n    for (d = this.faceVertexUvs.length; c < d; c++) {\n      b = this.faceVertexUvs[c];void 0 === a.faceVertexUvs[c] && (a.faceVertexUvs[c] = []);for (var e = 0, f = b.length; e < f; e++) {\n        for (var g = b[e], h = [], k = 0, l = g.length; k < l; k++) {\n          h.push(g[k].clone());\n        }a.faceVertexUvs[c].push(h);\n      }\n    }return a;\n  }, dispose: function dispose() {\n    this.dispatchEvent({ type: \"dispose\" });\n  } };THREE.EventDispatcher.prototype.apply(THREE.Geometry.prototype);THREE.GeometryIdCount = 0;\nTHREE.Camera = function () {\n  THREE.Object3D.call(this);this.type = \"Camera\";this.matrixWorldInverse = new THREE.Matrix4();this.projectionMatrix = new THREE.Matrix4();\n};THREE.Camera.prototype = Object.create(THREE.Object3D.prototype);THREE.Camera.prototype.constructor = THREE.Camera;THREE.Camera.prototype.getWorldDirection = function () {\n  var a = new THREE.Quaternion();return function (b) {\n    b = b || new THREE.Vector3();this.getWorldQuaternion(a);return b.set(0, 0, -1).applyQuaternion(a);\n  };\n}();\nTHREE.Camera.prototype.lookAt = function () {\n  var a = new THREE.Matrix4();return function (b) {\n    a.lookAt(this.position, b, this.up);this.quaternion.setFromRotationMatrix(a);\n  };\n}();THREE.Camera.prototype.clone = function (a) {\n  void 0 === a && (a = new THREE.Camera());THREE.Object3D.prototype.clone.call(this, a);a.matrixWorldInverse.copy(this.matrixWorldInverse);a.projectionMatrix.copy(this.projectionMatrix);return a;\n};\nTHREE.CubeCamera = function (a, b, c) {\n  THREE.Object3D.call(this);this.type = \"CubeCamera\";var d = new THREE.PerspectiveCamera(90, 1, a, b);d.up.set(0, -1, 0);d.lookAt(new THREE.Vector3(1, 0, 0));this.add(d);var e = new THREE.PerspectiveCamera(90, 1, a, b);e.up.set(0, -1, 0);e.lookAt(new THREE.Vector3(-1, 0, 0));this.add(e);var f = new THREE.PerspectiveCamera(90, 1, a, b);f.up.set(0, 0, 1);f.lookAt(new THREE.Vector3(0, 1, 0));this.add(f);var g = new THREE.PerspectiveCamera(90, 1, a, b);g.up.set(0, 0, -1);g.lookAt(new THREE.Vector3(0, -1, 0));\n  this.add(g);var h = new THREE.PerspectiveCamera(90, 1, a, b);h.up.set(0, -1, 0);h.lookAt(new THREE.Vector3(0, 0, 1));this.add(h);var k = new THREE.PerspectiveCamera(90, 1, a, b);k.up.set(0, -1, 0);k.lookAt(new THREE.Vector3(0, 0, -1));this.add(k);this.renderTarget = new THREE.WebGLRenderTargetCube(c, c, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter });this.updateCubeMap = function (a, b) {\n    var c = this.renderTarget,\n        n = c.generateMipmaps;c.generateMipmaps = !1;c.activeCubeFace = 0;a.render(b, d, c);c.activeCubeFace = 1;a.render(b, e, c);c.activeCubeFace = 2;a.render(b, f, c);c.activeCubeFace = 3;a.render(b, g, c);c.activeCubeFace = 4;a.render(b, h, c);c.generateMipmaps = n;c.activeCubeFace = 5;a.render(b, k, c);\n  };\n};THREE.CubeCamera.prototype = Object.create(THREE.Object3D.prototype);THREE.CubeCamera.prototype.constructor = THREE.CubeCamera;\nTHREE.OrthographicCamera = function (a, b, c, d, e, f) {\n  THREE.Camera.call(this);this.type = \"OrthographicCamera\";this.zoom = 1;this.left = a;this.right = b;this.top = c;this.bottom = d;this.near = void 0 !== e ? e : .1;this.far = void 0 !== f ? f : 2E3;this.updateProjectionMatrix();\n};THREE.OrthographicCamera.prototype = Object.create(THREE.Camera.prototype);THREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;\nTHREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {\n  var a = (this.right - this.left) / (2 * this.zoom),\n      b = (this.top - this.bottom) / (2 * this.zoom),\n      c = (this.right + this.left) / 2,\n      d = (this.top + this.bottom) / 2;this.projectionMatrix.makeOrthographic(c - a, c + a, d + b, d - b, this.near, this.far);\n};\nTHREE.OrthographicCamera.prototype.clone = function () {\n  var a = new THREE.OrthographicCamera();THREE.Camera.prototype.clone.call(this, a);a.zoom = this.zoom;a.left = this.left;a.right = this.right;a.top = this.top;a.bottom = this.bottom;a.near = this.near;a.far = this.far;a.projectionMatrix.copy(this.projectionMatrix);return a;\n};\nTHREE.PerspectiveCamera = function (a, b, c, d) {\n  THREE.Camera.call(this);this.type = \"PerspectiveCamera\";this.zoom = 1;this.fov = void 0 !== a ? a : 50;this.aspect = void 0 !== b ? b : 1;this.near = void 0 !== c ? c : .1;this.far = void 0 !== d ? d : 2E3;this.updateProjectionMatrix();\n};THREE.PerspectiveCamera.prototype = Object.create(THREE.Camera.prototype);THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;\nTHREE.PerspectiveCamera.prototype.setLens = function (a, b) {\n  void 0 === b && (b = 24);this.fov = 2 * THREE.Math.radToDeg(Math.atan(b / (2 * a)));this.updateProjectionMatrix();\n};THREE.PerspectiveCamera.prototype.setViewOffset = function (a, b, c, d, e, f) {\n  this.fullWidth = a;this.fullHeight = b;this.x = c;this.y = d;this.width = e;this.height = f;this.updateProjectionMatrix();\n};\nTHREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {\n  var a = THREE.Math.radToDeg(2 * Math.atan(Math.tan(.5 * THREE.Math.degToRad(this.fov)) / this.zoom));if (this.fullWidth) {\n    var b = this.fullWidth / this.fullHeight,\n        a = Math.tan(THREE.Math.degToRad(.5 * a)) * this.near,\n        c = -a,\n        d = b * c,\n        b = Math.abs(b * a - d),\n        c = Math.abs(a - c);this.projectionMatrix.makeFrustum(d + this.x * b / this.fullWidth, d + (this.x + this.width) * b / this.fullWidth, a - (this.y + this.height) * c / this.fullHeight, a - this.y * c / this.fullHeight, this.near, this.far);\n  } else this.projectionMatrix.makePerspective(a, this.aspect, this.near, this.far);\n};THREE.PerspectiveCamera.prototype.clone = function () {\n  var a = new THREE.PerspectiveCamera();THREE.Camera.prototype.clone.call(this, a);a.zoom = this.zoom;a.fov = this.fov;a.aspect = this.aspect;a.near = this.near;a.far = this.far;a.projectionMatrix.copy(this.projectionMatrix);return a;\n};THREE.Light = function (a) {\n  THREE.Object3D.call(this);this.type = \"Light\";this.color = new THREE.Color(a);\n};THREE.Light.prototype = Object.create(THREE.Object3D.prototype);THREE.Light.prototype.constructor = THREE.Light;\nTHREE.Light.prototype.clone = function (a) {\n  void 0 === a && (a = new THREE.Light());THREE.Object3D.prototype.clone.call(this, a);a.color.copy(this.color);return a;\n};THREE.AmbientLight = function (a) {\n  THREE.Light.call(this, a);this.type = \"AmbientLight\";\n};THREE.AmbientLight.prototype = Object.create(THREE.Light.prototype);THREE.AmbientLight.prototype.constructor = THREE.AmbientLight;THREE.AmbientLight.prototype.clone = function () {\n  var a = new THREE.AmbientLight();THREE.Light.prototype.clone.call(this, a);return a;\n};\nTHREE.AreaLight = function (a, b) {\n  THREE.Light.call(this, a);this.type = \"AreaLight\";this.normal = new THREE.Vector3(0, -1, 0);this.right = new THREE.Vector3(1, 0, 0);this.intensity = void 0 !== b ? b : 1;this.height = this.width = 1;this.constantAttenuation = 1.5;this.linearAttenuation = .5;this.quadraticAttenuation = .1;\n};THREE.AreaLight.prototype = Object.create(THREE.Light.prototype);THREE.AreaLight.prototype.constructor = THREE.AreaLight;\nTHREE.DirectionalLight = function (a, b) {\n  THREE.Light.call(this, a);this.type = \"DirectionalLight\";this.position.set(0, 1, 0);this.target = new THREE.Object3D();this.intensity = void 0 !== b ? b : 1;this.onlyShadow = this.castShadow = !1;this.shadowCameraNear = 50;this.shadowCameraFar = 5E3;this.shadowCameraLeft = -500;this.shadowCameraTop = this.shadowCameraRight = 500;this.shadowCameraBottom = -500;this.shadowCameraVisible = !1;this.shadowBias = 0;this.shadowDarkness = .5;this.shadowMapHeight = this.shadowMapWidth = 512;this.shadowCascade = !1;\n  this.shadowCascadeOffset = new THREE.Vector3(0, 0, -1E3);this.shadowCascadeCount = 2;this.shadowCascadeBias = [0, 0, 0];this.shadowCascadeWidth = [512, 512, 512];this.shadowCascadeHeight = [512, 512, 512];this.shadowCascadeNearZ = [-1, .99, .998];this.shadowCascadeFarZ = [.99, .998, 1];this.shadowCascadeArray = [];this.shadowMatrix = this.shadowCamera = this.shadowMapSize = this.shadowMap = null;\n};THREE.DirectionalLight.prototype = Object.create(THREE.Light.prototype);THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;\nTHREE.DirectionalLight.prototype.clone = function () {\n  var a = new THREE.DirectionalLight();THREE.Light.prototype.clone.call(this, a);a.target = this.target.clone();a.intensity = this.intensity;a.castShadow = this.castShadow;a.onlyShadow = this.onlyShadow;a.shadowCameraNear = this.shadowCameraNear;a.shadowCameraFar = this.shadowCameraFar;a.shadowCameraLeft = this.shadowCameraLeft;a.shadowCameraRight = this.shadowCameraRight;a.shadowCameraTop = this.shadowCameraTop;a.shadowCameraBottom = this.shadowCameraBottom;a.shadowCameraVisible = this.shadowCameraVisible;a.shadowBias = this.shadowBias;a.shadowDarkness = this.shadowDarkness;a.shadowMapWidth = this.shadowMapWidth;a.shadowMapHeight = this.shadowMapHeight;a.shadowCascade = this.shadowCascade;a.shadowCascadeOffset.copy(this.shadowCascadeOffset);a.shadowCascadeCount = this.shadowCascadeCount;a.shadowCascadeBias = this.shadowCascadeBias.slice(0);a.shadowCascadeWidth = this.shadowCascadeWidth.slice(0);a.shadowCascadeHeight = this.shadowCascadeHeight.slice(0);a.shadowCascadeNearZ = this.shadowCascadeNearZ.slice(0);\n  a.shadowCascadeFarZ = this.shadowCascadeFarZ.slice(0);return a;\n};THREE.HemisphereLight = function (a, b, c) {\n  THREE.Light.call(this, a);this.type = \"HemisphereLight\";this.position.set(0, 100, 0);this.groundColor = new THREE.Color(b);this.intensity = void 0 !== c ? c : 1;\n};THREE.HemisphereLight.prototype = Object.create(THREE.Light.prototype);THREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight;\nTHREE.HemisphereLight.prototype.clone = function () {\n  var a = new THREE.HemisphereLight();THREE.Light.prototype.clone.call(this, a);a.groundColor.copy(this.groundColor);a.intensity = this.intensity;return a;\n};THREE.PointLight = function (a, b, c, d) {\n  THREE.Light.call(this, a);this.type = \"PointLight\";this.intensity = void 0 !== b ? b : 1;this.distance = void 0 !== c ? c : 0;this.decay = void 0 !== d ? d : 1;\n};THREE.PointLight.prototype = Object.create(THREE.Light.prototype);THREE.PointLight.prototype.constructor = THREE.PointLight;\nTHREE.PointLight.prototype.clone = function () {\n  var a = new THREE.PointLight();THREE.Light.prototype.clone.call(this, a);a.intensity = this.intensity;a.distance = this.distance;a.decay = this.decay;return a;\n};\nTHREE.SpotLight = function (a, b, c, d, e, f) {\n  THREE.Light.call(this, a);this.type = \"SpotLight\";this.position.set(0, 1, 0);this.target = new THREE.Object3D();this.intensity = void 0 !== b ? b : 1;this.distance = void 0 !== c ? c : 0;this.angle = void 0 !== d ? d : Math.PI / 3;this.exponent = void 0 !== e ? e : 10;this.decay = void 0 !== f ? f : 1;this.onlyShadow = this.castShadow = !1;this.shadowCameraNear = 50;this.shadowCameraFar = 5E3;this.shadowCameraFov = 50;this.shadowCameraVisible = !1;this.shadowBias = 0;this.shadowDarkness = .5;this.shadowMapHeight = this.shadowMapWidth = 512;this.shadowMatrix = this.shadowCamera = this.shadowMapSize = this.shadowMap = null;\n};THREE.SpotLight.prototype = Object.create(THREE.Light.prototype);THREE.SpotLight.prototype.constructor = THREE.SpotLight;\nTHREE.SpotLight.prototype.clone = function () {\n  var a = new THREE.SpotLight();THREE.Light.prototype.clone.call(this, a);a.target = this.target.clone();a.intensity = this.intensity;a.distance = this.distance;a.angle = this.angle;a.exponent = this.exponent;a.decay = this.decay;a.castShadow = this.castShadow;a.onlyShadow = this.onlyShadow;a.shadowCameraNear = this.shadowCameraNear;a.shadowCameraFar = this.shadowCameraFar;a.shadowCameraFov = this.shadowCameraFov;a.shadowCameraVisible = this.shadowCameraVisible;a.shadowBias = this.shadowBias;\n  a.shadowDarkness = this.shadowDarkness;a.shadowMapWidth = this.shadowMapWidth;a.shadowMapHeight = this.shadowMapHeight;return a;\n};THREE.Cache = { files: {}, add: function add(a, b) {\n    this.files[a] = b;\n  }, get: function get(a) {\n    return this.files[a];\n  }, remove: function remove(a) {\n    delete this.files[a];\n  }, clear: function clear() {\n    this.files = {};\n  } };\nTHREE.Loader = function (a) {\n  this.statusDomElement = (this.showStatus = a) ? THREE.Loader.prototype.addStatusElement() : null;this.imageLoader = new THREE.ImageLoader();this.onLoadStart = function () {};this.onLoadProgress = function () {};this.onLoadComplete = function () {};\n};\nTHREE.Loader.prototype = { constructor: THREE.Loader, crossOrigin: void 0, addStatusElement: function addStatusElement() {\n    var a = document.createElement(\"div\");a.style.position = \"absolute\";a.style.right = \"0px\";a.style.top = \"0px\";a.style.fontSize = \"0.8em\";a.style.textAlign = \"left\";a.style.background = \"rgba(0,0,0,0.25)\";a.style.color = \"#fff\";a.style.width = \"120px\";a.style.padding = \"0.5em 0.5em 0.5em 0.5em\";a.style.zIndex = 1E3;a.innerHTML = \"Loading ...\";return a;\n  }, updateProgress: function updateProgress(a) {\n    var b = \"Loaded \",\n        b = a.total ? b + ((100 * a.loaded / a.total).toFixed(0) + \"%\") : b + ((a.loaded / 1024).toFixed(2) + \" KB\");this.statusDomElement.innerHTML = b;\n  }, extractUrlBase: function extractUrlBase(a) {\n    a = a.split(\"/\");if (1 === a.length) return \"./\";a.pop();return a.join(\"/\") + \"/\";\n  }, initMaterials: function initMaterials(a, b) {\n    for (var c = [], d = 0; d < a.length; ++d) {\n      c[d] = this.createMaterial(a[d], b);\n    }return c;\n  }, needsTangents: function needsTangents(a) {\n    for (var b = 0, c = a.length; b < c; b++) {\n      if (a[b] instanceof THREE.ShaderMaterial) return !0;\n    }return !1;\n  }, createMaterial: function createMaterial(a, b) {\n    function c(a) {\n      a = Math.log(a) / Math.LN2;return Math.pow(2, Math.round(a));\n    }function d(a, d, e, g, h, k, s) {\n      var u = b + e,\n          v,\n          x = THREE.Loader.Handlers.get(u);null !== x ? v = x.load(u) : (v = new THREE.Texture(), x = f.imageLoader, x.crossOrigin = f.crossOrigin, x.load(u, function (a) {\n        if (!1 === THREE.Math.isPowerOfTwo(a.width) || !1 === THREE.Math.isPowerOfTwo(a.height)) {\n          var b = c(a.width),\n              d = c(a.height),\n              e = document.createElement(\"canvas\");e.width = b;e.height = d;e.getContext(\"2d\").drawImage(a, 0, 0, b, d);v.image = e;\n        } else v.image = a;v.needsUpdate = !0;\n      }));v.sourceFile = e;g && (v.repeat.set(g[0], g[1]), 1 !== g[0] && (v.wrapS = THREE.RepeatWrapping), 1 !== g[1] && (v.wrapT = THREE.RepeatWrapping));h && v.offset.set(h[0], h[1]);k && (e = { repeat: THREE.RepeatWrapping, mirror: THREE.MirroredRepeatWrapping }, void 0 !== e[k[0]] && (v.wrapS = e[k[0]]), void 0 !== e[k[1]] && (v.wrapT = e[k[1]]));s && (v.anisotropy = s);a[d] = v;\n    }function e(a) {\n      return (255 * a[0] << 16) + (255 * a[1] << 8) + 255 * a[2];\n    }var f = this,\n        g = \"MeshLambertMaterial\",\n        h = { color: 15658734, opacity: 1, map: null, lightMap: null, normalMap: null, bumpMap: null, wireframe: !1 };if (a.shading) {\n      var k = a.shading.toLowerCase();\"phong\" === k ? g = \"MeshPhongMaterial\" : \"basic\" === k && (g = \"MeshBasicMaterial\");\n    }void 0 !== a.blending && void 0 !== THREE[a.blending] && (h.blending = THREE[a.blending]);void 0 !== a.transparent && (h.transparent = a.transparent);void 0 !== a.opacity && 1 > a.opacity && (h.transparent = !0);void 0 !== a.depthTest && (h.depthTest = a.depthTest);void 0 !== a.depthWrite && (h.depthWrite = a.depthWrite);void 0 !== a.visible && (h.visible = a.visible);void 0 !== a.flipSided && (h.side = THREE.BackSide);void 0 !== a.doubleSided && (h.side = THREE.DoubleSide);void 0 !== a.wireframe && (h.wireframe = a.wireframe);\n    void 0 !== a.vertexColors && (\"face\" === a.vertexColors ? h.vertexColors = THREE.FaceColors : a.vertexColors && (h.vertexColors = THREE.VertexColors));a.colorDiffuse ? h.color = e(a.colorDiffuse) : a.DbgColor && (h.color = a.DbgColor);a.colorSpecular && (h.specular = e(a.colorSpecular));a.colorEmissive && (h.emissive = e(a.colorEmissive));void 0 !== a.transparency && (console.warn(\"THREE.Loader: transparency has been renamed to opacity\"), a.opacity = a.transparency);void 0 !== a.opacity && (h.opacity = a.opacity);a.specularCoef && (h.shininess = a.specularCoef);a.mapDiffuse && b && d(h, \"map\", a.mapDiffuse, a.mapDiffuseRepeat, a.mapDiffuseOffset, a.mapDiffuseWrap, a.mapDiffuseAnisotropy);a.mapLight && b && d(h, \"lightMap\", a.mapLight, a.mapLightRepeat, a.mapLightOffset, a.mapLightWrap, a.mapLightAnisotropy);a.mapBump && b && d(h, \"bumpMap\", a.mapBump, a.mapBumpRepeat, a.mapBumpOffset, a.mapBumpWrap, a.mapBumpAnisotropy);a.mapNormal && b && d(h, \"normalMap\", a.mapNormal, a.mapNormalRepeat, a.mapNormalOffset, a.mapNormalWrap, a.mapNormalAnisotropy);a.mapSpecular && b && d(h, \"specularMap\", a.mapSpecular, a.mapSpecularRepeat, a.mapSpecularOffset, a.mapSpecularWrap, a.mapSpecularAnisotropy);a.mapAlpha && b && d(h, \"alphaMap\", a.mapAlpha, a.mapAlphaRepeat, a.mapAlphaOffset, a.mapAlphaWrap, a.mapAlphaAnisotropy);a.mapBumpScale && (h.bumpScale = a.mapBumpScale);a.mapNormalFactor && (h.normalScale = new THREE.Vector2(a.mapNormalFactor, a.mapNormalFactor));g = new THREE[g](h);void 0 !== a.DbgName && (g.name = a.DbgName);return g;\n  } };\nTHREE.Loader.Handlers = { handlers: [], add: function add(a, b) {\n    this.handlers.push(a, b);\n  }, get: function get(a) {\n    for (var b = 0, c = this.handlers.length; b < c; b += 2) {\n      var d = this.handlers[b + 1];if (this.handlers[b].test(a)) return d;\n    }return null;\n  } };THREE.XHRLoader = function (a) {\n  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;\n};\nTHREE.XHRLoader.prototype = { constructor: THREE.XHRLoader, load: function load(a, b, c, d) {\n    var e = this,\n        f = THREE.Cache.get(a);void 0 !== f ? b && b(f) : (f = new XMLHttpRequest(), f.open(\"GET\", a, !0), f.addEventListener(\"load\", function (c) {\n      THREE.Cache.add(a, this.response);b && b(this.response);e.manager.itemEnd(a);\n    }, !1), void 0 !== c && f.addEventListener(\"progress\", function (a) {\n      c(a);\n    }, !1), void 0 !== d && f.addEventListener(\"error\", function (a) {\n      d(a);\n    }, !1), void 0 !== this.crossOrigin && (f.crossOrigin = this.crossOrigin), void 0 !== this.responseType && (f.responseType = this.responseType), f.send(null), e.manager.itemStart(a));\n  }, setResponseType: function setResponseType(a) {\n    this.responseType = a;\n  }, setCrossOrigin: function setCrossOrigin(a) {\n    this.crossOrigin = a;\n  } };THREE.ImageLoader = function (a) {\n  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;\n};\nTHREE.ImageLoader.prototype = { constructor: THREE.ImageLoader, load: function load(a, b, c, d) {\n    var e = this,\n        f = THREE.Cache.get(a);if (void 0 !== f) b(f);else return f = document.createElement(\"img\"), f.addEventListener(\"load\", function (c) {\n      THREE.Cache.add(a, this);b && b(this);e.manager.itemEnd(a);\n    }, !1), void 0 !== c && f.addEventListener(\"progress\", function (a) {\n      c(a);\n    }, !1), void 0 !== d && f.addEventListener(\"error\", function (a) {\n      d(a);\n    }, !1), void 0 !== this.crossOrigin && (f.crossOrigin = this.crossOrigin), f.src = a, e.manager.itemStart(a), f;\n  }, setCrossOrigin: function setCrossOrigin(a) {\n    this.crossOrigin = a;\n  } };THREE.JSONLoader = function (a) {\n  THREE.Loader.call(this, a);this.withCredentials = !1;\n};THREE.JSONLoader.prototype = Object.create(THREE.Loader.prototype);THREE.JSONLoader.prototype.constructor = THREE.JSONLoader;THREE.JSONLoader.prototype.load = function (a, b, c) {\n  c = c && \"string\" === typeof c ? c : this.extractUrlBase(a);this.onLoadStart();this.loadAjaxJSON(this, a, b, c);\n};\nTHREE.JSONLoader.prototype.loadAjaxJSON = function (a, b, c, d, e) {\n  var f = new XMLHttpRequest(),\n      g = 0;f.onreadystatechange = function () {\n    if (f.readyState === f.DONE) {\n      if (200 === f.status || 0 === f.status) {\n        if (f.responseText) {\n          var h = JSON.parse(f.responseText),\n              k = h.metadata;if (void 0 !== k) {\n            if (\"object\" === k.type) {\n              THREE.error(\"THREE.JSONLoader: \" + b + \" should be loaded with THREE.ObjectLoader instead.\");return;\n            }if (\"scene\" === k.type) {\n              THREE.error(\"THREE.JSONLoader: \" + b + \" seems to be a Scene. Use THREE.SceneLoader instead.\");return;\n            }\n          }h = a.parse(h, d);c(h.geometry, h.materials);\n        } else THREE.error(\"THREE.JSONLoader: \" + b + \" seems to be unreachable or the file is empty.\");a.onLoadComplete();\n      } else THREE.error(\"THREE.JSONLoader: Couldn't load \" + b + \" (\" + f.status + \")\");\n    } else f.readyState === f.LOADING ? e && (0 === g && (g = f.getResponseHeader(\"Content-Length\")), e({ total: g, loaded: f.responseText.length })) : f.readyState === f.HEADERS_RECEIVED && void 0 !== e && (g = f.getResponseHeader(\"Content-Length\"));\n  };f.open(\"GET\", b, !0);f.withCredentials = this.withCredentials;f.send(null);\n};\nTHREE.JSONLoader.prototype.parse = function (a, b) {\n  var c = new THREE.Geometry(),\n      d = void 0 !== a.scale ? 1 / a.scale : 1;(function (b) {\n    var d,\n        g,\n        h,\n        k,\n        l,\n        p,\n        q,\n        n,\n        t,\n        r,\n        s,\n        u,\n        v,\n        x = a.faces;p = a.vertices;var D = a.normals,\n        w = a.colors,\n        y = 0;if (void 0 !== a.uvs) {\n      for (d = 0; d < a.uvs.length; d++) {\n        a.uvs[d].length && y++;\n      }for (d = 0; d < y; d++) {\n        c.faceVertexUvs[d] = [];\n      }\n    }k = 0;for (l = p.length; k < l;) {\n      d = new THREE.Vector3(), d.x = p[k++] * b, d.y = p[k++] * b, d.z = p[k++] * b, c.vertices.push(d);\n    }k = 0;for (l = x.length; k < l;) {\n      if (b = x[k++], t = b & 1, h = b & 2, d = b & 8, q = b & 16, r = b & 32, p = b & 64, b &= 128, t) {\n        t = new THREE.Face3();\n        t.a = x[k];t.b = x[k + 1];t.c = x[k + 3];s = new THREE.Face3();s.a = x[k + 1];s.b = x[k + 2];s.c = x[k + 3];k += 4;h && (h = x[k++], t.materialIndex = h, s.materialIndex = h);h = c.faces.length;if (d) for (d = 0; d < y; d++) {\n          for (u = a.uvs[d], c.faceVertexUvs[d][h] = [], c.faceVertexUvs[d][h + 1] = [], g = 0; 4 > g; g++) {\n            n = x[k++], v = u[2 * n], n = u[2 * n + 1], v = new THREE.Vector2(v, n), 2 !== g && c.faceVertexUvs[d][h].push(v), 0 !== g && c.faceVertexUvs[d][h + 1].push(v);\n          }\n        }q && (q = 3 * x[k++], t.normal.set(D[q++], D[q++], D[q]), s.normal.copy(t.normal));if (r) for (d = 0; 4 > d; d++) {\n          q = 3 * x[k++], r = new THREE.Vector3(D[q++], D[q++], D[q]), 2 !== d && t.vertexNormals.push(r), 0 !== d && s.vertexNormals.push(r);\n        }p && (p = x[k++], p = w[p], t.color.setHex(p), s.color.setHex(p));if (b) for (d = 0; 4 > d; d++) {\n          p = x[k++], p = w[p], 2 !== d && t.vertexColors.push(new THREE.Color(p)), 0 !== d && s.vertexColors.push(new THREE.Color(p));\n        }c.faces.push(t);c.faces.push(s);\n      } else {\n        t = new THREE.Face3();t.a = x[k++];t.b = x[k++];t.c = x[k++];h && (h = x[k++], t.materialIndex = h);h = c.faces.length;if (d) for (d = 0; d < y; d++) {\n          for (u = a.uvs[d], c.faceVertexUvs[d][h] = [], g = 0; 3 > g; g++) {\n            n = x[k++], v = u[2 * n], n = u[2 * n + 1], v = new THREE.Vector2(v, n), c.faceVertexUvs[d][h].push(v);\n          }\n        }q && (q = 3 * x[k++], t.normal.set(D[q++], D[q++], D[q]));if (r) for (d = 0; 3 > d; d++) {\n          q = 3 * x[k++], r = new THREE.Vector3(D[q++], D[q++], D[q]), t.vertexNormals.push(r);\n        }p && (p = x[k++], t.color.setHex(w[p]));if (b) for (d = 0; 3 > d; d++) {\n          p = x[k++], t.vertexColors.push(new THREE.Color(w[p]));\n        }c.faces.push(t);\n      }\n    }\n  })(d);(function () {\n    var b = void 0 !== a.influencesPerVertex ? a.influencesPerVertex : 2;if (a.skinWeights) for (var d = 0, g = a.skinWeights.length; d < g; d += b) {\n      c.skinWeights.push(new THREE.Vector4(a.skinWeights[d], 1 < b ? a.skinWeights[d + 1] : 0, 2 < b ? a.skinWeights[d + 2] : 0, 3 < b ? a.skinWeights[d + 3] : 0));\n    }if (a.skinIndices) for (d = 0, g = a.skinIndices.length; d < g; d += b) {\n      c.skinIndices.push(new THREE.Vector4(a.skinIndices[d], 1 < b ? a.skinIndices[d + 1] : 0, 2 < b ? a.skinIndices[d + 2] : 0, 3 < b ? a.skinIndices[d + 3] : 0));\n    }c.bones = a.bones;c.bones && 0 < c.bones.length && (c.skinWeights.length !== c.skinIndices.length || c.skinIndices.length !== c.vertices.length) && THREE.warn(\"THREE.JSONLoader: When skinning, number of vertices (\" + c.vertices.length + \"), skinIndices (\" + c.skinIndices.length + \"), and skinWeights (\" + c.skinWeights.length + \") should match.\");c.animation = a.animation;c.animations = a.animations;\n  })();(function (b) {\n    if (void 0 !== a.morphTargets) {\n      var d, g, h, k, l, p;d = 0;for (g = a.morphTargets.length; d < g; d++) {\n        for (c.morphTargets[d] = {}, c.morphTargets[d].name = a.morphTargets[d].name, c.morphTargets[d].vertices = [], l = c.morphTargets[d].vertices, p = a.morphTargets[d].vertices, h = 0, k = p.length; h < k; h += 3) {\n          var q = new THREE.Vector3();q.x = p[h] * b;q.y = p[h + 1] * b;q.z = p[h + 2] * b;l.push(q);\n        }\n      }\n    }if (void 0 !== a.morphColors) for (d = 0, g = a.morphColors.length; d < g; d++) {\n      for (c.morphColors[d] = {}, c.morphColors[d].name = a.morphColors[d].name, c.morphColors[d].colors = [], k = c.morphColors[d].colors, l = a.morphColors[d].colors, b = 0, h = l.length; b < h; b += 3) {\n        p = new THREE.Color(16755200), p.setRGB(l[b], l[b + 1], l[b + 2]), k.push(p);\n      }\n    }\n  })(d);c.computeFaceNormals();c.computeBoundingSphere();if (void 0 === a.materials || 0 === a.materials.length) return { geometry: c };d = this.initMaterials(a.materials, b);this.needsTangents(d) && c.computeTangents();return { geometry: c,\n    materials: d };\n};THREE.LoadingManager = function (a, b, c) {\n  var d = this,\n      e = 0,\n      f = 0;this.onLoad = a;this.onProgress = b;this.onError = c;this.itemStart = function (a) {\n    f++;\n  };this.itemEnd = function (a) {\n    e++;if (void 0 !== d.onProgress) d.onProgress(a, e, f);if (e === f && void 0 !== d.onLoad) d.onLoad();\n  };\n};THREE.DefaultLoadingManager = new THREE.LoadingManager();THREE.BufferGeometryLoader = function (a) {\n  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;\n};\nTHREE.BufferGeometryLoader.prototype = { constructor: THREE.BufferGeometryLoader, load: function load(a, b, c, d) {\n    var e = this,\n        f = new THREE.XHRLoader(e.manager);f.setCrossOrigin(this.crossOrigin);f.load(a, function (a) {\n      b(e.parse(JSON.parse(a)));\n    }, c, d);\n  }, setCrossOrigin: function setCrossOrigin(a) {\n    this.crossOrigin = a;\n  }, parse: function parse(a) {\n    var b = new THREE.BufferGeometry(),\n        c = a.data.attributes,\n        d;for (d in c) {\n      var e = c[d],\n          f = new self[e.type](e.array);b.addAttribute(d, new THREE.BufferAttribute(f, e.itemSize));\n    }c = a.data.offsets;void 0 !== c && (b.offsets = JSON.parse(JSON.stringify(c)));\n    a = a.data.boundingSphere;void 0 !== a && (c = new THREE.Vector3(), void 0 !== a.center && c.fromArray(a.center), b.boundingSphere = new THREE.Sphere(c, a.radius));return b;\n  } };THREE.MaterialLoader = function (a) {\n  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;\n};\nTHREE.MaterialLoader.prototype = { constructor: THREE.MaterialLoader, load: function load(a, b, c, d) {\n    var e = this,\n        f = new THREE.XHRLoader(e.manager);f.setCrossOrigin(this.crossOrigin);f.load(a, function (a) {\n      b(e.parse(JSON.parse(a)));\n    }, c, d);\n  }, setCrossOrigin: function setCrossOrigin(a) {\n    this.crossOrigin = a;\n  }, parse: function parse(a) {\n    var b = new THREE[a.type]();void 0 !== a.color && b.color.setHex(a.color);void 0 !== a.emissive && b.emissive.setHex(a.emissive);void 0 !== a.specular && b.specular.setHex(a.specular);void 0 !== a.shininess && (b.shininess = a.shininess);\n    void 0 !== a.uniforms && (b.uniforms = a.uniforms);void 0 !== a.vertexShader && (b.vertexShader = a.vertexShader);void 0 !== a.fragmentShader && (b.fragmentShader = a.fragmentShader);void 0 !== a.vertexColors && (b.vertexColors = a.vertexColors);void 0 !== a.shading && (b.shading = a.shading);void 0 !== a.blending && (b.blending = a.blending);void 0 !== a.side && (b.side = a.side);void 0 !== a.opacity && (b.opacity = a.opacity);void 0 !== a.transparent && (b.transparent = a.transparent);void 0 !== a.wireframe && (b.wireframe = a.wireframe);void 0 !== a.size && (b.size = a.size);void 0 !== a.sizeAttenuation && (b.sizeAttenuation = a.sizeAttenuation);if (void 0 !== a.materials) for (var c = 0, d = a.materials.length; c < d; c++) {\n      b.materials.push(this.parse(a.materials[c]));\n    }return b;\n  } };THREE.ObjectLoader = function (a) {\n  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;this.texturePath = \"\";\n};\nTHREE.ObjectLoader.prototype = { constructor: THREE.ObjectLoader, load: function load(a, b, c, d) {\n    \"\" === this.texturePath && (this.texturePath = a.substring(0, a.lastIndexOf(\"/\") + 1));var e = this,\n        f = new THREE.XHRLoader(e.manager);f.setCrossOrigin(this.crossOrigin);f.load(a, function (a) {\n      e.parse(JSON.parse(a), b);\n    }, c, d);\n  }, setTexturePath: function setTexturePath(a) {\n    this.texturePath = a;\n  }, setCrossOrigin: function setCrossOrigin(a) {\n    this.crossOrigin = a;\n  }, parse: function parse(a, b) {\n    var c = this.parseGeometries(a.geometries),\n        d = this.parseImages(a.images, function () {\n      void 0 !== b && b(e);\n    }),\n        d = this.parseTextures(a.textures, d),\n        d = this.parseMaterials(a.materials, d),\n        e = this.parseObject(a.object, c, d);void 0 !== a.images && 0 !== a.images.length || void 0 === b || b(e);return e;\n  }, parseGeometries: function parseGeometries(a) {\n    var b = {};if (void 0 !== a) for (var c = new THREE.JSONLoader(), d = new THREE.BufferGeometryLoader(), e = 0, f = a.length; e < f; e++) {\n      var g,\n          h = a[e];switch (h.type) {case \"PlaneGeometry\":case \"PlaneBufferGeometry\":\n          g = new THREE[h.type](h.width, h.height, h.widthSegments, h.heightSegments);break;case \"BoxGeometry\":case \"CubeGeometry\":\n          g = new THREE.BoxGeometry(h.width, h.height, h.depth, h.widthSegments, h.heightSegments, h.depthSegments);break;case \"CircleGeometry\":\n          g = new THREE.CircleGeometry(h.radius, h.segments);break;case \"CylinderGeometry\":\n          g = new THREE.CylinderGeometry(h.radiusTop, h.radiusBottom, h.height, h.radialSegments, h.heightSegments, h.openEnded);break;case \"SphereGeometry\":\n          g = new THREE.SphereGeometry(h.radius, h.widthSegments, h.heightSegments, h.phiStart, h.phiLength, h.thetaStart, h.thetaLength);break;case \"IcosahedronGeometry\":\n          g = new THREE.IcosahedronGeometry(h.radius, h.detail);break;case \"TorusGeometry\":\n          g = new THREE.TorusGeometry(h.radius, h.tube, h.radialSegments, h.tubularSegments, h.arc);break;case \"TorusKnotGeometry\":\n          g = new THREE.TorusKnotGeometry(h.radius, h.tube, h.radialSegments, h.tubularSegments, h.p, h.q, h.heightScale);break;case \"BufferGeometry\":\n          g = d.parse(h);break;case \"Geometry\":\n          g = c.parse(h.data).geometry;}g.uuid = h.uuid;void 0 !== h.name && (g.name = h.name);b[h.uuid] = g;\n    }return b;\n  }, parseMaterials: function parseMaterials(a, b) {\n    var c = {};if (void 0 !== a) for (var d = function d(a) {\n      void 0 === b[a] && THREE.warn(\"THREE.ObjectLoader: Undefined texture\", a);return b[a];\n    }, e = new THREE.MaterialLoader(), f = 0, g = a.length; f < g; f++) {\n      var h = a[f],\n          k = e.parse(h);k.uuid = h.uuid;void 0 !== h.name && (k.name = h.name);void 0 !== h.map && (k.map = d(h.map));void 0 !== h.bumpMap && (k.bumpMap = d(h.bumpMap), h.bumpScale && (k.bumpScale = new THREE.Vector2(h.bumpScale, h.bumpScale)));void 0 !== h.alphaMap && (k.alphaMap = d(h.alphaMap));void 0 !== h.envMap && (k.envMap = d(h.envMap));void 0 !== h.normalMap && (k.normalMap = d(h.normalMap), h.normalScale && (k.normalScale = new THREE.Vector2(h.normalScale, h.normalScale)));void 0 !== h.lightMap && (k.lightMap = d(h.lightMap));void 0 !== h.specularMap && (k.specularMap = d(h.specularMap));c[h.uuid] = k;\n    }return c;\n  }, parseImages: function parseImages(a, b) {\n    var c = this,\n        d = {};if (void 0 !== a && 0 < a.length) {\n      var e = new THREE.LoadingManager(b),\n          f = new THREE.ImageLoader(e);f.setCrossOrigin(this.crossOrigin);for (var e = function e(a) {\n        c.manager.itemStart(a);return f.load(a, function () {\n          c.manager.itemEnd(a);\n        });\n      }, g = 0, h = a.length; g < h; g++) {\n        var k = a[g],\n            l = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test(k.url) ? k.url : c.texturePath + k.url;d[k.uuid] = e(l);\n      }\n    }return d;\n  }, parseTextures: function parseTextures(a, b) {\n    var c = {};if (void 0 !== a) for (var d = 0, e = a.length; d < e; d++) {\n      var f = a[d];void 0 === f.image && THREE.warn('THREE.ObjectLoader: No \"image\" speficied for', f.uuid);void 0 === b[f.image] && THREE.warn(\"THREE.ObjectLoader: Undefined image\", f.image);var g = new THREE.Texture(b[f.image]);g.needsUpdate = !0;g.uuid = f.uuid;void 0 !== f.name && (g.name = f.name);void 0 !== f.repeat && (g.repeat = new THREE.Vector2(f.repeat[0], f.repeat[1]));void 0 !== f.minFilter && (g.minFilter = THREE[f.minFilter]);void 0 !== f.magFilter && (g.magFilter = THREE[f.magFilter]);void 0 !== f.anisotropy && (g.anisotropy = f.anisotropy);f.wrap instanceof Array && (g.wrapS = THREE[f.wrap[0]], g.wrapT = THREE[f.wrap[1]]);c[f.uuid] = g;\n    }return c;\n  }, parseObject: function () {\n    var a = new THREE.Matrix4();return function (b, c, d) {\n      var e;e = function e(a) {\n        void 0 === c[a] && THREE.warn(\"THREE.ObjectLoader: Undefined geometry\", a);return c[a];\n      };var f = function f(a) {\n        void 0 === d[a] && THREE.warn(\"THREE.ObjectLoader: Undefined material\", a);return d[a];\n      };\n      switch (b.type) {case \"Scene\":\n          e = new THREE.Scene();break;case \"PerspectiveCamera\":\n          e = new THREE.PerspectiveCamera(b.fov, b.aspect, b.near, b.far);break;case \"OrthographicCamera\":\n          e = new THREE.OrthographicCamera(b.left, b.right, b.top, b.bottom, b.near, b.far);break;case \"AmbientLight\":\n          e = new THREE.AmbientLight(b.color);break;case \"DirectionalLight\":\n          e = new THREE.DirectionalLight(b.color, b.intensity);break;case \"PointLight\":\n          e = new THREE.PointLight(b.color, b.intensity, b.distance, b.decay);break;case \"SpotLight\":\n          e = new THREE.SpotLight(b.color, b.intensity, b.distance, b.angle, b.exponent, b.decay);break;case \"HemisphereLight\":\n          e = new THREE.HemisphereLight(b.color, b.groundColor, b.intensity);break;case \"Mesh\":\n          e = new THREE.Mesh(e(b.geometry), f(b.material));break;case \"Line\":\n          e = new THREE.Line(e(b.geometry), f(b.material), b.mode);break;case \"PointCloud\":\n          e = new THREE.PointCloud(e(b.geometry), f(b.material));break;case \"Sprite\":\n          e = new THREE.Sprite(f(b.material));break;case \"Group\":\n          e = new THREE.Group();break;default:\n          e = new THREE.Object3D();}e.uuid = b.uuid;void 0 !== b.name && (e.name = b.name);void 0 !== b.matrix ? (a.fromArray(b.matrix), a.decompose(e.position, e.quaternion, e.scale)) : (void 0 !== b.position && e.position.fromArray(b.position), void 0 !== b.rotation && e.rotation.fromArray(b.rotation), void 0 !== b.scale && e.scale.fromArray(b.scale));void 0 !== b.visible && (e.visible = b.visible);void 0 !== b.userData && (e.userData = b.userData);if (void 0 !== b.children) for (var g in b.children) {\n        e.add(this.parseObject(b.children[g], c, d));\n      }return e;\n    };\n  }() };\nTHREE.TextureLoader = function (a) {\n  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;\n};THREE.TextureLoader.prototype = { constructor: THREE.TextureLoader, load: function load(a, b, c, d) {\n    var e = new THREE.ImageLoader(this.manager);e.setCrossOrigin(this.crossOrigin);e.load(a, function (a) {\n      a = new THREE.Texture(a);a.needsUpdate = !0;void 0 !== b && b(a);\n    }, c, d);\n  }, setCrossOrigin: function setCrossOrigin(a) {\n    this.crossOrigin = a;\n  } };THREE.DataTextureLoader = THREE.BinaryTextureLoader = function () {\n  this._parser = null;\n};\nTHREE.BinaryTextureLoader.prototype = { constructor: THREE.BinaryTextureLoader, load: function load(a, b, c, d) {\n    var e = this,\n        f = new THREE.DataTexture(),\n        g = new THREE.XHRLoader();g.setResponseType(\"arraybuffer\");g.load(a, function (a) {\n      if (a = e._parser(a)) void 0 !== a.image ? f.image = a.image : void 0 !== a.data && (f.image.width = a.width, f.image.height = a.height, f.image.data = a.data), f.wrapS = void 0 !== a.wrapS ? a.wrapS : THREE.ClampToEdgeWrapping, f.wrapT = void 0 !== a.wrapT ? a.wrapT : THREE.ClampToEdgeWrapping, f.magFilter = void 0 !== a.magFilter ? a.magFilter : THREE.LinearFilter, f.minFilter = void 0 !== a.minFilter ? a.minFilter : THREE.LinearMipMapLinearFilter, f.anisotropy = void 0 !== a.anisotropy ? a.anisotropy : 1, void 0 !== a.format && (f.format = a.format), void 0 !== a.type && (f.type = a.type), void 0 !== a.mipmaps && (f.mipmaps = a.mipmaps), 1 === a.mipmapCount && (f.minFilter = THREE.LinearFilter), f.needsUpdate = !0, b && b(f, a);\n    }, c, d);return f;\n  } };THREE.CompressedTextureLoader = function () {\n  this._parser = null;\n};\nTHREE.CompressedTextureLoader.prototype = { constructor: THREE.CompressedTextureLoader, load: function load(a, b, c) {\n    var d = this,\n        e = [],\n        f = new THREE.CompressedTexture();f.image = e;var g = new THREE.XHRLoader();g.setResponseType(\"arraybuffer\");if (a instanceof Array) {\n      var h = 0;c = function c(_c) {\n        g.load(a[_c], function (a) {\n          a = d._parser(a, !0);e[_c] = { width: a.width, height: a.height, format: a.format, mipmaps: a.mipmaps };h += 1;6 === h && (1 == a.mipmapCount && (f.minFilter = THREE.LinearFilter), f.format = a.format, f.needsUpdate = !0, b && b(f));\n        });\n      };for (var k = 0, l = a.length; k < l; ++k) {\n        c(k);\n      }\n    } else g.load(a, function (a) {\n      a = d._parser(a, !0);if (a.isCubemap) for (var c = a.mipmaps.length / a.mipmapCount, g = 0; g < c; g++) {\n        e[g] = { mipmaps: [] };for (var h = 0; h < a.mipmapCount; h++) {\n          e[g].mipmaps.push(a.mipmaps[g * a.mipmapCount + h]), e[g].format = a.format, e[g].width = a.width, e[g].height = a.height;\n        }\n      } else f.image.width = a.width, f.image.height = a.height, f.mipmaps = a.mipmaps;1 === a.mipmapCount && (f.minFilter = THREE.LinearFilter);f.format = a.format;f.needsUpdate = !0;b && b(f);\n    });return f;\n  } };\nTHREE.Material = function () {\n  Object.defineProperty(this, \"id\", { value: THREE.MaterialIdCount++ });this.uuid = THREE.Math.generateUUID();this.name = \"\";this.type = \"Material\";this.side = THREE.FrontSide;this.opacity = 1;this.transparent = !1;this.blending = THREE.NormalBlending;this.blendSrc = THREE.SrcAlphaFactor;this.blendDst = THREE.OneMinusSrcAlphaFactor;this.blendEquation = THREE.AddEquation;this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null;this.colorWrite = this.depthWrite = this.depthTest = !0;this.polygonOffset = !1;this.overdraw = this.alphaTest = this.polygonOffsetUnits = this.polygonOffsetFactor = 0;this._needsUpdate = this.visible = !0;\n};\nTHREE.Material.prototype = { constructor: THREE.Material, get needsUpdate() {\n    return this._needsUpdate;\n  }, set needsUpdate(a) {\n    !0 === a && this.update();this._needsUpdate = a;\n  }, setValues: function setValues(a) {\n    if (void 0 !== a) for (var b in a) {\n      var c = a[b];if (void 0 === c) THREE.warn(\"THREE.Material: '\" + b + \"' parameter is undefined.\");else if (b in this) {\n        var d = this[b];d instanceof THREE.Color ? d.set(c) : d instanceof THREE.Vector3 && c instanceof THREE.Vector3 ? d.copy(c) : this[b] = \"overdraw\" == b ? Number(c) : c;\n      }\n    }\n  }, toJSON: function toJSON() {\n    var a = { metadata: { version: 4.2,\n        type: \"material\", generator: \"MaterialExporter\" }, uuid: this.uuid, type: this.type };\"\" !== this.name && (a.name = this.name);this instanceof THREE.MeshBasicMaterial ? (a.color = this.color.getHex(), this.vertexColors !== THREE.NoColors && (a.vertexColors = this.vertexColors), this.blending !== THREE.NormalBlending && (a.blending = this.blending), this.side !== THREE.FrontSide && (a.side = this.side)) : this instanceof THREE.MeshLambertMaterial ? (a.color = this.color.getHex(), a.emissive = this.emissive.getHex(), this.vertexColors !== THREE.NoColors && (a.vertexColors = this.vertexColors), this.shading !== THREE.SmoothShading && (a.shading = this.shading), this.blending !== THREE.NormalBlending && (a.blending = this.blending), this.side !== THREE.FrontSide && (a.side = this.side)) : this instanceof THREE.MeshPhongMaterial ? (a.color = this.color.getHex(), a.emissive = this.emissive.getHex(), a.specular = this.specular.getHex(), a.shininess = this.shininess, this.vertexColors !== THREE.NoColors && (a.vertexColors = this.vertexColors), this.shading !== THREE.SmoothShading && (a.shading = this.shading), this.blending !== THREE.NormalBlending && (a.blending = this.blending), this.side !== THREE.FrontSide && (a.side = this.side)) : this instanceof THREE.MeshNormalMaterial ? (this.blending !== THREE.NormalBlending && (a.blending = this.blending), this.side !== THREE.FrontSide && (a.side = this.side)) : this instanceof THREE.MeshDepthMaterial ? (this.blending !== THREE.NormalBlending && (a.blending = this.blending), this.side !== THREE.FrontSide && (a.side = this.side)) : this instanceof THREE.PointCloudMaterial ? (a.size = this.size, a.sizeAttenuation = this.sizeAttenuation, a.color = this.color.getHex(), this.vertexColors !== THREE.NoColors && (a.vertexColors = this.vertexColors), this.blending !== THREE.NormalBlending && (a.blending = this.blending)) : this instanceof THREE.ShaderMaterial ? (a.uniforms = this.uniforms, a.vertexShader = this.vertexShader, a.fragmentShader = this.fragmentShader) : this instanceof THREE.SpriteMaterial && (a.color = this.color.getHex());1 > this.opacity && (a.opacity = this.opacity);!1 !== this.transparent && (a.transparent = this.transparent);!1 !== this.wireframe && (a.wireframe = this.wireframe);return a;\n  }, clone: function clone(a) {\n    void 0 === a && (a = new THREE.Material());a.name = this.name;a.side = this.side;a.opacity = this.opacity;a.transparent = this.transparent;a.blending = this.blending;a.blendSrc = this.blendSrc;a.blendDst = this.blendDst;a.blendEquation = this.blendEquation;a.blendSrcAlpha = this.blendSrcAlpha;a.blendDstAlpha = this.blendDstAlpha;a.blendEquationAlpha = this.blendEquationAlpha;a.depthTest = this.depthTest;a.depthWrite = this.depthWrite;a.polygonOffset = this.polygonOffset;a.polygonOffsetFactor = this.polygonOffsetFactor;a.polygonOffsetUnits = this.polygonOffsetUnits;a.alphaTest = this.alphaTest;a.overdraw = this.overdraw;a.visible = this.visible;return a;\n  }, update: function update() {\n    this.dispatchEvent({ type: \"update\" });\n  }, dispose: function dispose() {\n    this.dispatchEvent({ type: \"dispose\" });\n  } };THREE.EventDispatcher.prototype.apply(THREE.Material.prototype);THREE.MaterialIdCount = 0;\nTHREE.LineBasicMaterial = function (a) {\n  THREE.Material.call(this);this.type = \"LineBasicMaterial\";this.color = new THREE.Color(16777215);this.linewidth = 1;this.linejoin = this.linecap = \"round\";this.vertexColors = THREE.NoColors;this.fog = !0;this.setValues(a);\n};THREE.LineBasicMaterial.prototype = Object.create(THREE.Material.prototype);THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;\nTHREE.LineBasicMaterial.prototype.clone = function () {\n  var a = new THREE.LineBasicMaterial();THREE.Material.prototype.clone.call(this, a);a.color.copy(this.color);a.linewidth = this.linewidth;a.linecap = this.linecap;a.linejoin = this.linejoin;a.vertexColors = this.vertexColors;a.fog = this.fog;return a;\n};\nTHREE.LineDashedMaterial = function (a) {\n  THREE.Material.call(this);this.type = \"LineDashedMaterial\";this.color = new THREE.Color(16777215);this.scale = this.linewidth = 1;this.dashSize = 3;this.gapSize = 1;this.vertexColors = !1;this.fog = !0;this.setValues(a);\n};THREE.LineDashedMaterial.prototype = Object.create(THREE.Material.prototype);THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;\nTHREE.LineDashedMaterial.prototype.clone = function () {\n  var a = new THREE.LineDashedMaterial();THREE.Material.prototype.clone.call(this, a);a.color.copy(this.color);a.linewidth = this.linewidth;a.scale = this.scale;a.dashSize = this.dashSize;a.gapSize = this.gapSize;a.vertexColors = this.vertexColors;a.fog = this.fog;return a;\n};\nTHREE.MeshBasicMaterial = function (a) {\n  THREE.Material.call(this);this.type = \"MeshBasicMaterial\";this.color = new THREE.Color(16777215);this.envMap = this.alphaMap = this.specularMap = this.lightMap = this.map = null;this.combine = THREE.MultiplyOperation;this.reflectivity = 1;this.refractionRatio = .98;this.fog = !0;this.shading = THREE.SmoothShading;this.wireframe = !1;this.wireframeLinewidth = 1;this.wireframeLinejoin = this.wireframeLinecap = \"round\";this.vertexColors = THREE.NoColors;this.morphTargets = this.skinning = !1;this.setValues(a);\n};\nTHREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype);THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;\nTHREE.MeshBasicMaterial.prototype.clone = function () {\n  var a = new THREE.MeshBasicMaterial();THREE.Material.prototype.clone.call(this, a);a.color.copy(this.color);a.map = this.map;a.lightMap = this.lightMap;a.specularMap = this.specularMap;a.alphaMap = this.alphaMap;a.envMap = this.envMap;a.combine = this.combine;a.reflectivity = this.reflectivity;a.refractionRatio = this.refractionRatio;a.fog = this.fog;a.shading = this.shading;a.wireframe = this.wireframe;a.wireframeLinewidth = this.wireframeLinewidth;a.wireframeLinecap = this.wireframeLinecap;\n  a.wireframeLinejoin = this.wireframeLinejoin;a.vertexColors = this.vertexColors;a.skinning = this.skinning;a.morphTargets = this.morphTargets;return a;\n};\nTHREE.MeshLambertMaterial = function (a) {\n  THREE.Material.call(this);this.type = \"MeshLambertMaterial\";this.color = new THREE.Color(16777215);this.emissive = new THREE.Color(0);this.wrapAround = !1;this.wrapRGB = new THREE.Vector3(1, 1, 1);this.envMap = this.alphaMap = this.specularMap = this.lightMap = this.map = null;this.combine = THREE.MultiplyOperation;this.reflectivity = 1;this.refractionRatio = .98;this.fog = !0;this.shading = THREE.SmoothShading;this.wireframe = !1;this.wireframeLinewidth = 1;this.wireframeLinejoin = this.wireframeLinecap = \"round\";this.vertexColors = THREE.NoColors;this.morphNormals = this.morphTargets = this.skinning = !1;this.setValues(a);\n};THREE.MeshLambertMaterial.prototype = Object.create(THREE.Material.prototype);THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;\nTHREE.MeshLambertMaterial.prototype.clone = function () {\n  var a = new THREE.MeshLambertMaterial();THREE.Material.prototype.clone.call(this, a);a.color.copy(this.color);a.emissive.copy(this.emissive);a.wrapAround = this.wrapAround;a.wrapRGB.copy(this.wrapRGB);a.map = this.map;a.lightMap = this.lightMap;a.specularMap = this.specularMap;a.alphaMap = this.alphaMap;a.envMap = this.envMap;a.combine = this.combine;a.reflectivity = this.reflectivity;a.refractionRatio = this.refractionRatio;a.fog = this.fog;a.shading = this.shading;a.wireframe = this.wireframe;a.wireframeLinewidth = this.wireframeLinewidth;a.wireframeLinecap = this.wireframeLinecap;a.wireframeLinejoin = this.wireframeLinejoin;a.vertexColors = this.vertexColors;a.skinning = this.skinning;a.morphTargets = this.morphTargets;a.morphNormals = this.morphNormals;return a;\n};\nTHREE.MeshPhongMaterial = function (a) {\n  THREE.Material.call(this);this.type = \"MeshPhongMaterial\";this.color = new THREE.Color(16777215);this.emissive = new THREE.Color(0);this.specular = new THREE.Color(1118481);this.shininess = 30;this.wrapAround = this.metal = !1;this.wrapRGB = new THREE.Vector3(1, 1, 1);this.bumpMap = this.lightMap = this.map = null;this.bumpScale = 1;this.normalMap = null;this.normalScale = new THREE.Vector2(1, 1);this.envMap = this.alphaMap = this.specularMap = null;this.combine = THREE.MultiplyOperation;this.reflectivity = 1;this.refractionRatio = .98;this.fog = !0;this.shading = THREE.SmoothShading;this.wireframe = !1;this.wireframeLinewidth = 1;this.wireframeLinejoin = this.wireframeLinecap = \"round\";this.vertexColors = THREE.NoColors;this.morphNormals = this.morphTargets = this.skinning = !1;this.setValues(a);\n};THREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype);THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;\nTHREE.MeshPhongMaterial.prototype.clone = function () {\n  var a = new THREE.MeshPhongMaterial();THREE.Material.prototype.clone.call(this, a);a.color.copy(this.color);a.emissive.copy(this.emissive);a.specular.copy(this.specular);a.shininess = this.shininess;a.metal = this.metal;a.wrapAround = this.wrapAround;a.wrapRGB.copy(this.wrapRGB);a.map = this.map;a.lightMap = this.lightMap;a.bumpMap = this.bumpMap;a.bumpScale = this.bumpScale;a.normalMap = this.normalMap;a.normalScale.copy(this.normalScale);a.specularMap = this.specularMap;\n  a.alphaMap = this.alphaMap;a.envMap = this.envMap;a.combine = this.combine;a.reflectivity = this.reflectivity;a.refractionRatio = this.refractionRatio;a.fog = this.fog;a.shading = this.shading;a.wireframe = this.wireframe;a.wireframeLinewidth = this.wireframeLinewidth;a.wireframeLinecap = this.wireframeLinecap;a.wireframeLinejoin = this.wireframeLinejoin;a.vertexColors = this.vertexColors;a.skinning = this.skinning;a.morphTargets = this.morphTargets;a.morphNormals = this.morphNormals;return a;\n};\nTHREE.MeshDepthMaterial = function (a) {\n  THREE.Material.call(this);this.type = \"MeshDepthMaterial\";this.wireframe = this.morphTargets = !1;this.wireframeLinewidth = 1;this.setValues(a);\n};THREE.MeshDepthMaterial.prototype = Object.create(THREE.Material.prototype);THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;\nTHREE.MeshDepthMaterial.prototype.clone = function () {\n  var a = new THREE.MeshDepthMaterial();THREE.Material.prototype.clone.call(this, a);a.wireframe = this.wireframe;a.wireframeLinewidth = this.wireframeLinewidth;return a;\n};THREE.MeshNormalMaterial = function (a) {\n  THREE.Material.call(this, a);this.type = \"MeshNormalMaterial\";this.wireframe = !1;this.wireframeLinewidth = 1;this.morphTargets = !1;this.setValues(a);\n};THREE.MeshNormalMaterial.prototype = Object.create(THREE.Material.prototype);\nTHREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;THREE.MeshNormalMaterial.prototype.clone = function () {\n  var a = new THREE.MeshNormalMaterial();THREE.Material.prototype.clone.call(this, a);a.wireframe = this.wireframe;a.wireframeLinewidth = this.wireframeLinewidth;return a;\n};THREE.MeshFaceMaterial = function (a) {\n  this.uuid = THREE.Math.generateUUID();this.type = \"MeshFaceMaterial\";this.materials = a instanceof Array ? a : [];\n};\nTHREE.MeshFaceMaterial.prototype = { constructor: THREE.MeshFaceMaterial, toJSON: function toJSON() {\n    for (var a = { metadata: { version: 4.2, type: \"material\", generator: \"MaterialExporter\" }, uuid: this.uuid, type: this.type, materials: [] }, b = 0, c = this.materials.length; b < c; b++) {\n      a.materials.push(this.materials[b].toJSON());\n    }return a;\n  }, clone: function clone() {\n    for (var a = new THREE.MeshFaceMaterial(), b = 0; b < this.materials.length; b++) {\n      a.materials.push(this.materials[b].clone());\n    }return a;\n  } };\nTHREE.PointCloudMaterial = function (a) {\n  THREE.Material.call(this);this.type = \"PointCloudMaterial\";this.color = new THREE.Color(16777215);this.map = null;this.size = 1;this.sizeAttenuation = !0;this.vertexColors = THREE.NoColors;this.fog = !0;this.setValues(a);\n};THREE.PointCloudMaterial.prototype = Object.create(THREE.Material.prototype);THREE.PointCloudMaterial.prototype.constructor = THREE.PointCloudMaterial;\nTHREE.PointCloudMaterial.prototype.clone = function () {\n  var a = new THREE.PointCloudMaterial();THREE.Material.prototype.clone.call(this, a);a.color.copy(this.color);a.map = this.map;a.size = this.size;a.sizeAttenuation = this.sizeAttenuation;a.vertexColors = this.vertexColors;a.fog = this.fog;return a;\n};THREE.ParticleBasicMaterial = function (a) {\n  THREE.warn(\"THREE.ParticleBasicMaterial has been renamed to THREE.PointCloudMaterial.\");return new THREE.PointCloudMaterial(a);\n};\nTHREE.ParticleSystemMaterial = function (a) {\n  THREE.warn(\"THREE.ParticleSystemMaterial has been renamed to THREE.PointCloudMaterial.\");return new THREE.PointCloudMaterial(a);\n};\nTHREE.ShaderMaterial = function (a) {\n  THREE.Material.call(this);this.type = \"ShaderMaterial\";this.defines = {};this.uniforms = {};this.attributes = null;this.vertexShader = \"void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\";this.fragmentShader = \"void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}\";this.shading = THREE.SmoothShading;this.linewidth = 1;this.wireframe = !1;this.wireframeLinewidth = 1;this.lights = this.fog = !1;this.vertexColors = THREE.NoColors;this.morphNormals = this.morphTargets = this.skinning = !1;this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] };this.index0AttributeName = void 0;this.setValues(a);\n};THREE.ShaderMaterial.prototype = Object.create(THREE.Material.prototype);THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;\nTHREE.ShaderMaterial.prototype.clone = function () {\n  var a = new THREE.ShaderMaterial();THREE.Material.prototype.clone.call(this, a);a.fragmentShader = this.fragmentShader;a.vertexShader = this.vertexShader;a.uniforms = THREE.UniformsUtils.clone(this.uniforms);a.attributes = this.attributes;a.defines = this.defines;a.shading = this.shading;a.wireframe = this.wireframe;a.wireframeLinewidth = this.wireframeLinewidth;a.fog = this.fog;a.lights = this.lights;a.vertexColors = this.vertexColors;a.skinning = this.skinning;a.morphTargets = this.morphTargets;a.morphNormals = this.morphNormals;return a;\n};THREE.RawShaderMaterial = function (a) {\n  THREE.ShaderMaterial.call(this, a);this.type = \"RawShaderMaterial\";\n};THREE.RawShaderMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype);THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;THREE.RawShaderMaterial.prototype.clone = function () {\n  var a = new THREE.RawShaderMaterial();THREE.ShaderMaterial.prototype.clone.call(this, a);return a;\n};\nTHREE.SpriteMaterial = function (a) {\n  THREE.Material.call(this);this.type = \"SpriteMaterial\";this.color = new THREE.Color(16777215);this.map = null;this.rotation = 0;this.fog = !1;this.setValues(a);\n};THREE.SpriteMaterial.prototype = Object.create(THREE.Material.prototype);THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;\nTHREE.SpriteMaterial.prototype.clone = function () {\n  var a = new THREE.SpriteMaterial();THREE.Material.prototype.clone.call(this, a);a.color.copy(this.color);a.map = this.map;a.rotation = this.rotation;a.fog = this.fog;return a;\n};\nTHREE.Texture = function (a, b, c, d, e, f, g, h, k) {\n  Object.defineProperty(this, \"id\", { value: THREE.TextureIdCount++ });this.uuid = THREE.Math.generateUUID();this.sourceFile = this.name = \"\";this.image = void 0 !== a ? a : THREE.Texture.DEFAULT_IMAGE;this.mipmaps = [];this.mapping = void 0 !== b ? b : THREE.Texture.DEFAULT_MAPPING;this.wrapS = void 0 !== c ? c : THREE.ClampToEdgeWrapping;this.wrapT = void 0 !== d ? d : THREE.ClampToEdgeWrapping;this.magFilter = void 0 !== e ? e : THREE.LinearFilter;this.minFilter = void 0 !== f ? f : THREE.LinearMipMapLinearFilter;\n  this.anisotropy = void 0 !== k ? k : 1;this.format = void 0 !== g ? g : THREE.RGBAFormat;this.type = void 0 !== h ? h : THREE.UnsignedByteType;this.offset = new THREE.Vector2(0, 0);this.repeat = new THREE.Vector2(1, 1);this.generateMipmaps = !0;this.premultiplyAlpha = !1;this.flipY = !0;this.unpackAlignment = 4;this._needsUpdate = !1;this.onUpdate = null;\n};THREE.Texture.DEFAULT_IMAGE = void 0;THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;\nTHREE.Texture.prototype = { constructor: THREE.Texture, get needsUpdate() {\n    return this._needsUpdate;\n  }, set needsUpdate(a) {\n    !0 === a && this.update();this._needsUpdate = a;\n  }, clone: function clone(a) {\n    void 0 === a && (a = new THREE.Texture());a.image = this.image;a.mipmaps = this.mipmaps.slice(0);a.mapping = this.mapping;a.wrapS = this.wrapS;a.wrapT = this.wrapT;a.magFilter = this.magFilter;a.minFilter = this.minFilter;a.anisotropy = this.anisotropy;a.format = this.format;a.type = this.type;a.offset.copy(this.offset);a.repeat.copy(this.repeat);a.generateMipmaps = this.generateMipmaps;a.premultiplyAlpha = this.premultiplyAlpha;a.flipY = this.flipY;a.unpackAlignment = this.unpackAlignment;return a;\n  }, update: function update() {\n    this.dispatchEvent({ type: \"update\" });\n  }, dispose: function dispose() {\n    this.dispatchEvent({ type: \"dispose\" });\n  } };THREE.EventDispatcher.prototype.apply(THREE.Texture.prototype);THREE.TextureIdCount = 0;THREE.CubeTexture = function (a, b, c, d, e, f, g, h, k) {\n  b = void 0 !== b ? b : THREE.CubeReflectionMapping;THREE.Texture.call(this, a, b, c, d, e, f, g, h, k);this.images = a;\n};\nTHREE.CubeTexture.prototype = Object.create(THREE.Texture.prototype);THREE.CubeTexture.prototype.constructor = THREE.CubeTexture;THREE.CubeTexture.clone = function (a) {\n  void 0 === a && (a = new THREE.CubeTexture());THREE.Texture.prototype.clone.call(this, a);a.images = this.images;return a;\n};THREE.CompressedTexture = function (a, b, c, d, e, f, g, h, k, l, p) {\n  THREE.Texture.call(this, null, f, g, h, k, l, d, e, p);this.image = { width: b, height: c };this.mipmaps = a;this.generateMipmaps = this.flipY = !1;\n};THREE.CompressedTexture.prototype = Object.create(THREE.Texture.prototype);\nTHREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;THREE.CompressedTexture.prototype.clone = function () {\n  var a = new THREE.CompressedTexture();THREE.Texture.prototype.clone.call(this, a);return a;\n};THREE.DataTexture = function (a, b, c, d, e, f, g, h, k, l, p) {\n  THREE.Texture.call(this, null, f, g, h, k, l, d, e, p);this.image = { data: a, width: b, height: c };\n};THREE.DataTexture.prototype = Object.create(THREE.Texture.prototype);THREE.DataTexture.prototype.constructor = THREE.DataTexture;\nTHREE.DataTexture.prototype.clone = function () {\n  var a = new THREE.DataTexture();THREE.Texture.prototype.clone.call(this, a);return a;\n};THREE.VideoTexture = function (a, b, c, d, e, f, g, h, k) {\n  THREE.Texture.call(this, a, b, c, d, e, f, g, h, k);this.generateMipmaps = !1;var l = this,\n      p = function p() {\n    requestAnimationFrame(p);a.readyState === a.HAVE_ENOUGH_DATA && (l.needsUpdate = !0);\n  };p();\n};THREE.VideoTexture.prototype = Object.create(THREE.Texture.prototype);THREE.VideoTexture.prototype.constructor = THREE.VideoTexture;\nTHREE.Group = function () {\n  THREE.Object3D.call(this);this.type = \"Group\";\n};THREE.Group.prototype = Object.create(THREE.Object3D.prototype);THREE.Group.prototype.constructor = THREE.Group;THREE.PointCloud = function (a, b) {\n  THREE.Object3D.call(this);this.type = \"PointCloud\";this.geometry = void 0 !== a ? a : new THREE.Geometry();this.material = void 0 !== b ? b : new THREE.PointCloudMaterial({ color: 16777215 * Math.random() });\n};THREE.PointCloud.prototype = Object.create(THREE.Object3D.prototype);THREE.PointCloud.prototype.constructor = THREE.PointCloud;\nTHREE.PointCloud.prototype.raycast = function () {\n  var a = new THREE.Matrix4(),\n      b = new THREE.Ray();return function (c, d) {\n    var e = this,\n        f = e.geometry,\n        g = c.params.PointCloud.threshold;a.getInverse(this.matrixWorld);b.copy(c.ray).applyMatrix4(a);if (null === f.boundingBox || !1 !== b.isIntersectionBox(f.boundingBox)) {\n      var h = g / ((this.scale.x + this.scale.y + this.scale.z) / 3),\n          k = new THREE.Vector3(),\n          g = function g(a, f) {\n        var g = b.distanceToPoint(a);if (g < h) {\n          var k = b.closestPointToPoint(a);k.applyMatrix4(e.matrixWorld);var n = c.ray.origin.distanceTo(k);\n          d.push({ distance: n, distanceToRay: g, point: k.clone(), index: f, face: null, object: e });\n        }\n      };if (f instanceof THREE.BufferGeometry) {\n        var l = f.attributes,\n            p = l.position.array;if (void 0 !== l.index) {\n          var l = l.index.array,\n              q = f.offsets;0 === q.length && (q = [{ start: 0, count: l.length, index: 0 }]);for (var n = 0, t = q.length; n < t; ++n) {\n            for (var r = q[n].start, s = q[n].index, f = r, r = r + q[n].count; f < r; f++) {\n              var u = s + l[f];k.fromArray(p, 3 * u);g(k, u);\n            }\n          }\n        } else for (l = p.length / 3, f = 0; f < l; f++) {\n          k.set(p[3 * f], p[3 * f + 1], p[3 * f + 2]), g(k, f);\n        }\n      } else for (k = this.geometry.vertices, f = 0; f < k.length; f++) {\n        g(k[f], f);\n      }\n    }\n  };\n}();THREE.PointCloud.prototype.clone = function (a) {\n  void 0 === a && (a = new THREE.PointCloud(this.geometry, this.material));THREE.Object3D.prototype.clone.call(this, a);return a;\n};THREE.ParticleSystem = function (a, b) {\n  THREE.warn(\"THREE.ParticleSystem has been renamed to THREE.PointCloud.\");return new THREE.PointCloud(a, b);\n};\nTHREE.Line = function (a, b, c) {\n  THREE.Object3D.call(this);this.type = \"Line\";this.geometry = void 0 !== a ? a : new THREE.Geometry();this.material = void 0 !== b ? b : new THREE.LineBasicMaterial({ color: 16777215 * Math.random() });this.mode = void 0 !== c ? c : THREE.LineStrip;\n};THREE.LineStrip = 0;THREE.LinePieces = 1;THREE.Line.prototype = Object.create(THREE.Object3D.prototype);THREE.Line.prototype.constructor = THREE.Line;\nTHREE.Line.prototype.raycast = function () {\n  var a = new THREE.Matrix4(),\n      b = new THREE.Ray(),\n      c = new THREE.Sphere();return function (d, e) {\n    var f = d.linePrecision,\n        f = f * f,\n        g = this.geometry;null === g.boundingSphere && g.computeBoundingSphere();c.copy(g.boundingSphere);c.applyMatrix4(this.matrixWorld);if (!1 !== d.ray.isIntersectionSphere(c)) {\n      a.getInverse(this.matrixWorld);b.copy(d.ray).applyMatrix4(a);var h = new THREE.Vector3(),\n          k = new THREE.Vector3(),\n          l = new THREE.Vector3(),\n          p = new THREE.Vector3(),\n          q = this.mode === THREE.LineStrip ? 1 : 2;if (g instanceof THREE.BufferGeometry) {\n        var n = g.attributes;if (void 0 !== n.index) {\n          var t = n.index.array,\n              n = n.position.array,\n              r = g.offsets;0 === r.length && (r = [{ start: 0, count: t.length, index: 0 }]);for (var s = 0; s < r.length; s++) {\n            for (var u = r[s].start, v = r[s].count, x = r[s].index, g = u; g < u + v - 1; g += q) {\n              var D = x + t[g + 1];h.fromArray(n, 3 * (x + t[g]));k.fromArray(n, 3 * D);D = b.distanceSqToSegment(h, k, p, l);D > f || (D = b.origin.distanceTo(p), D < d.near || D > d.far || e.push({ distance: D, point: l.clone().applyMatrix4(this.matrixWorld), index: g, offsetIndex: s, face: null, faceIndex: null,\n                object: this }));\n            }\n          }\n        } else for (n = n.position.array, g = 0; g < n.length / 3 - 1; g += q) {\n          h.fromArray(n, 3 * g), k.fromArray(n, 3 * g + 3), D = b.distanceSqToSegment(h, k, p, l), D > f || (D = b.origin.distanceTo(p), D < d.near || D > d.far || e.push({ distance: D, point: l.clone().applyMatrix4(this.matrixWorld), index: g, face: null, faceIndex: null, object: this }));\n        }\n      } else if (g instanceof THREE.Geometry) for (h = g.vertices, k = h.length, g = 0; g < k - 1; g += q) {\n        D = b.distanceSqToSegment(h[g], h[g + 1], p, l), D > f || (D = b.origin.distanceTo(p), D < d.near || D > d.far || e.push({ distance: D, point: l.clone().applyMatrix4(this.matrixWorld),\n          index: g, face: null, faceIndex: null, object: this }));\n      }\n    }\n  };\n}();THREE.Line.prototype.clone = function (a) {\n  void 0 === a && (a = new THREE.Line(this.geometry, this.material, this.mode));THREE.Object3D.prototype.clone.call(this, a);return a;\n};THREE.Mesh = function (a, b) {\n  THREE.Object3D.call(this);this.type = \"Mesh\";this.geometry = void 0 !== a ? a : new THREE.Geometry();this.material = void 0 !== b ? b : new THREE.MeshBasicMaterial({ color: 16777215 * Math.random() });this.updateMorphTargets();\n};THREE.Mesh.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.Mesh.prototype.constructor = THREE.Mesh;THREE.Mesh.prototype.updateMorphTargets = function () {\n  if (void 0 !== this.geometry.morphTargets && 0 < this.geometry.morphTargets.length) {\n    this.morphTargetBase = -1;this.morphTargetForcedOrder = [];this.morphTargetInfluences = [];this.morphTargetDictionary = {};for (var a = 0, b = this.geometry.morphTargets.length; a < b; a++) {\n      this.morphTargetInfluences.push(0), this.morphTargetDictionary[this.geometry.morphTargets[a].name] = a;\n    }\n  }\n};\nTHREE.Mesh.prototype.getMorphTargetIndexByName = function (a) {\n  if (void 0 !== this.morphTargetDictionary[a]) return this.morphTargetDictionary[a];THREE.warn(\"THREE.Mesh.getMorphTargetIndexByName: morph target \" + a + \" does not exist. Returning 0.\");return 0;\n};\nTHREE.Mesh.prototype.raycast = function () {\n  var a = new THREE.Matrix4(),\n      b = new THREE.Ray(),\n      c = new THREE.Sphere(),\n      d = new THREE.Vector3(),\n      e = new THREE.Vector3(),\n      f = new THREE.Vector3();return function (g, h) {\n    var k = this.geometry;null === k.boundingSphere && k.computeBoundingSphere();c.copy(k.boundingSphere);c.applyMatrix4(this.matrixWorld);if (!1 !== g.ray.isIntersectionSphere(c) && (a.getInverse(this.matrixWorld), b.copy(g.ray).applyMatrix4(a), null === k.boundingBox || !1 !== b.isIntersectionBox(k.boundingBox))) if (k instanceof THREE.BufferGeometry) {\n      var l = this.material;if (void 0 !== l) {\n        var p = k.attributes,\n            q,\n            n,\n            t = g.precision;if (void 0 !== p.index) {\n          var r = p.index.array,\n              s = p.position.array,\n              u = k.offsets;0 === u.length && (u = [{ start: 0, count: r.length, index: 0 }]);for (var v = 0, x = u.length; v < x; ++v) {\n            for (var p = u[v].start, D = u[v].index, k = p, w = p + u[v].count; k < w; k += 3) {\n              p = D + r[k];q = D + r[k + 1];n = D + r[k + 2];d.fromArray(s, 3 * p);e.fromArray(s, 3 * q);f.fromArray(s, 3 * n);var y = l.side === THREE.BackSide ? b.intersectTriangle(f, e, d, !0) : b.intersectTriangle(d, e, f, l.side !== THREE.DoubleSide);if (null !== y) {\n                y.applyMatrix4(this.matrixWorld);\n                var A = g.ray.origin.distanceTo(y);A < t || A < g.near || A > g.far || h.push({ distance: A, point: y, face: new THREE.Face3(p, q, n, THREE.Triangle.normal(d, e, f)), faceIndex: null, object: this });\n              }\n            }\n          }\n        } else for (s = p.position.array, r = k = 0, w = s.length; k < w; k += 3, r += 9) {\n          p = k, q = k + 1, n = k + 2, d.fromArray(s, r), e.fromArray(s, r + 3), f.fromArray(s, r + 6), y = l.side === THREE.BackSide ? b.intersectTriangle(f, e, d, !0) : b.intersectTriangle(d, e, f, l.side !== THREE.DoubleSide), null !== y && (y.applyMatrix4(this.matrixWorld), A = g.ray.origin.distanceTo(y), A < t || A < g.near || A > g.far || h.push({ distance: A, point: y, face: new THREE.Face3(p, q, n, THREE.Triangle.normal(d, e, f)), faceIndex: null, object: this }));\n        }\n      }\n    } else if (k instanceof THREE.Geometry) for (r = this.material instanceof THREE.MeshFaceMaterial, s = !0 === r ? this.material.materials : null, t = g.precision, u = k.vertices, v = 0, x = k.faces.length; v < x; v++) {\n      if (D = k.faces[v], l = !0 === r ? s[D.materialIndex] : this.material, void 0 !== l) {\n        p = u[D.a];q = u[D.b];n = u[D.c];if (!0 === l.morphTargets) {\n          y = k.morphTargets;A = this.morphTargetInfluences;d.set(0, 0, 0);e.set(0, 0, 0);f.set(0, 0, 0);for (var w = 0, E = y.length; w < E; w++) {\n            var G = A[w];if (0 !== G) {\n              var F = y[w].vertices;d.x += (F[D.a].x - p.x) * G;d.y += (F[D.a].y - p.y) * G;d.z += (F[D.a].z - p.z) * G;e.x += (F[D.b].x - q.x) * G;e.y += (F[D.b].y - q.y) * G;e.z += (F[D.b].z - q.z) * G;f.x += (F[D.c].x - n.x) * G;f.y += (F[D.c].y - n.y) * G;f.z += (F[D.c].z - n.z) * G;\n            }\n          }d.add(p);e.add(q);f.add(n);p = d;q = e;n = f;\n        }y = l.side === THREE.BackSide ? b.intersectTriangle(n, q, p, !0) : b.intersectTriangle(p, q, n, l.side !== THREE.DoubleSide);null !== y && (y.applyMatrix4(this.matrixWorld), A = g.ray.origin.distanceTo(y), A < t || A < g.near || A > g.far || h.push({ distance: A, point: y, face: D, faceIndex: v, object: this }));\n      }\n    }\n  };\n}();THREE.Mesh.prototype.clone = function (a, b) {\n  void 0 === a && (a = new THREE.Mesh(this.geometry, this.material));THREE.Object3D.prototype.clone.call(this, a, b);return a;\n};THREE.Bone = function (a) {\n  THREE.Object3D.call(this);this.type = \"Bone\";this.skin = a;\n};THREE.Bone.prototype = Object.create(THREE.Object3D.prototype);THREE.Bone.prototype.constructor = THREE.Bone;\nTHREE.Skeleton = function (a, b, c) {\n  this.useVertexTexture = void 0 !== c ? c : !0;this.identityMatrix = new THREE.Matrix4();a = a || [];this.bones = a.slice(0);this.useVertexTexture ? (this.boneTextureHeight = this.boneTextureWidth = a = 256 < this.bones.length ? 64 : 64 < this.bones.length ? 32 : 16 < this.bones.length ? 16 : 8, this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4), this.boneTexture = new THREE.DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType), this.boneTexture.minFilter = THREE.NearestFilter, this.boneTexture.magFilter = THREE.NearestFilter, this.boneTexture.generateMipmaps = !1, this.boneTexture.flipY = !1) : this.boneMatrices = new Float32Array(16 * this.bones.length);if (void 0 === b) this.calculateInverses();else if (this.bones.length === b.length) this.boneInverses = b.slice(0);else for (THREE.warn(\"THREE.Skeleton bonInverses is the wrong length.\"), this.boneInverses = [], b = 0, a = this.bones.length; b < a; b++) {\n    this.boneInverses.push(new THREE.Matrix4());\n  }\n};\nTHREE.Skeleton.prototype.calculateInverses = function () {\n  this.boneInverses = [];for (var a = 0, b = this.bones.length; a < b; a++) {\n    var c = new THREE.Matrix4();this.bones[a] && c.getInverse(this.bones[a].matrixWorld);this.boneInverses.push(c);\n  }\n};\nTHREE.Skeleton.prototype.pose = function () {\n  for (var a, b = 0, c = this.bones.length; b < c; b++) {\n    (a = this.bones[b]) && a.matrixWorld.getInverse(this.boneInverses[b]);\n  }b = 0;for (c = this.bones.length; b < c; b++) {\n    if (a = this.bones[b]) a.parent ? (a.matrix.getInverse(a.parent.matrixWorld), a.matrix.multiply(a.matrixWorld)) : a.matrix.copy(a.matrixWorld), a.matrix.decompose(a.position, a.quaternion, a.scale);\n  }\n};\nTHREE.Skeleton.prototype.update = function () {\n  var a = new THREE.Matrix4();return function () {\n    for (var b = 0, c = this.bones.length; b < c; b++) {\n      a.multiplyMatrices(this.bones[b] ? this.bones[b].matrixWorld : this.identityMatrix, this.boneInverses[b]), a.flattenToArrayOffset(this.boneMatrices, 16 * b);\n    }this.useVertexTexture && (this.boneTexture.needsUpdate = !0);\n  };\n}();\nTHREE.SkinnedMesh = function (a, b, c) {\n  THREE.Mesh.call(this, a, b);this.type = \"SkinnedMesh\";this.bindMode = \"attached\";this.bindMatrix = new THREE.Matrix4();this.bindMatrixInverse = new THREE.Matrix4();a = [];if (this.geometry && void 0 !== this.geometry.bones) {\n    for (var d, e, f, g, h = 0, k = this.geometry.bones.length; h < k; ++h) {\n      d = this.geometry.bones[h], e = d.pos, f = d.rotq, g = d.scl, b = new THREE.Bone(this), a.push(b), b.name = d.name, b.position.set(e[0], e[1], e[2]), b.quaternion.set(f[0], f[1], f[2], f[3]), void 0 !== g ? b.scale.set(g[0], g[1], g[2]) : b.scale.set(1, 1, 1);\n    }h = 0;for (k = this.geometry.bones.length; h < k; ++h) {\n      d = this.geometry.bones[h], -1 !== d.parent ? a[d.parent].add(a[h]) : this.add(a[h]);\n    }\n  }this.normalizeSkinWeights();this.updateMatrixWorld(!0);this.bind(new THREE.Skeleton(a, void 0, c));\n};THREE.SkinnedMesh.prototype = Object.create(THREE.Mesh.prototype);THREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;THREE.SkinnedMesh.prototype.bind = function (a, b) {\n  this.skeleton = a;void 0 === b && (this.updateMatrixWorld(!0), b = this.matrixWorld);this.bindMatrix.copy(b);this.bindMatrixInverse.getInverse(b);\n};\nTHREE.SkinnedMesh.prototype.pose = function () {\n  this.skeleton.pose();\n};THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {\n  if (this.geometry instanceof THREE.Geometry) for (var a = 0; a < this.geometry.skinIndices.length; a++) {\n    var b = this.geometry.skinWeights[a],\n        c = 1 / b.lengthManhattan();Infinity !== c ? b.multiplyScalar(c) : b.set(1);\n  }\n};\nTHREE.SkinnedMesh.prototype.updateMatrixWorld = function (a) {\n  THREE.Mesh.prototype.updateMatrixWorld.call(this, !0);\"attached\" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : \"detached\" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : THREE.warn(\"THREE.SkinnedMesh unreckognized bindMode: \" + this.bindMode);\n};\nTHREE.SkinnedMesh.prototype.clone = function (a) {\n  void 0 === a && (a = new THREE.SkinnedMesh(this.geometry, this.material, this.useVertexTexture));THREE.Mesh.prototype.clone.call(this, a);return a;\n};THREE.MorphAnimMesh = function (a, b) {\n  THREE.Mesh.call(this, a, b);this.type = \"MorphAnimMesh\";this.duration = 1E3;this.mirroredLoop = !1;this.currentKeyframe = this.lastKeyframe = this.time = 0;this.direction = 1;this.directionBackwards = !1;this.setFrameRange(0, this.geometry.morphTargets.length - 1);\n};THREE.MorphAnimMesh.prototype = Object.create(THREE.Mesh.prototype);\nTHREE.MorphAnimMesh.prototype.constructor = THREE.MorphAnimMesh;THREE.MorphAnimMesh.prototype.setFrameRange = function (a, b) {\n  this.startKeyframe = a;this.endKeyframe = b;this.length = this.endKeyframe - this.startKeyframe + 1;\n};THREE.MorphAnimMesh.prototype.setDirectionForward = function () {\n  this.direction = 1;this.directionBackwards = !1;\n};THREE.MorphAnimMesh.prototype.setDirectionBackward = function () {\n  this.direction = -1;this.directionBackwards = !0;\n};\nTHREE.MorphAnimMesh.prototype.parseAnimations = function () {\n  var a = this.geometry;a.animations || (a.animations = {});for (var b, c = a.animations, d = /([a-z]+)_?(\\d+)/, e = 0, f = a.morphTargets.length; e < f; e++) {\n    var g = a.morphTargets[e].name.match(d);if (g && 1 < g.length) {\n      g = g[1];c[g] || (c[g] = { start: Infinity, end: -Infinity });var h = c[g];e < h.start && (h.start = e);e > h.end && (h.end = e);b || (b = g);\n    }\n  }a.firstAnimation = b;\n};\nTHREE.MorphAnimMesh.prototype.setAnimationLabel = function (a, b, c) {\n  this.geometry.animations || (this.geometry.animations = {});this.geometry.animations[a] = { start: b, end: c };\n};THREE.MorphAnimMesh.prototype.playAnimation = function (a, b) {\n  var c = this.geometry.animations[a];c ? (this.setFrameRange(c.start, c.end), this.duration = (c.end - c.start) / b * 1E3, this.time = 0) : THREE.warn(\"THREE.MorphAnimMesh: animation[\" + a + \"] undefined in .playAnimation()\");\n};\nTHREE.MorphAnimMesh.prototype.updateAnimation = function (a) {\n  var b = this.duration / this.length;this.time += this.direction * a;if (this.mirroredLoop) {\n    if (this.time > this.duration || 0 > this.time) this.direction *= -1, this.time > this.duration && (this.time = this.duration, this.directionBackwards = !0), 0 > this.time && (this.time = 0, this.directionBackwards = !1);\n  } else this.time %= this.duration, 0 > this.time && (this.time += this.duration);a = this.startKeyframe + THREE.Math.clamp(Math.floor(this.time / b), 0, this.length - 1);a !== this.currentKeyframe && (this.morphTargetInfluences[this.lastKeyframe] = 0, this.morphTargetInfluences[this.currentKeyframe] = 1, this.morphTargetInfluences[a] = 0, this.lastKeyframe = this.currentKeyframe, this.currentKeyframe = a);b = this.time % b / b;this.directionBackwards && (b = 1 - b);this.morphTargetInfluences[this.currentKeyframe] = b;this.morphTargetInfluences[this.lastKeyframe] = 1 - b;\n};\nTHREE.MorphAnimMesh.prototype.interpolateTargets = function (a, b, c) {\n  for (var d = this.morphTargetInfluences, e = 0, f = d.length; e < f; e++) {\n    d[e] = 0;\n  }-1 < a && (d[a] = 1 - c);-1 < b && (d[b] = c);\n};\nTHREE.MorphAnimMesh.prototype.clone = function (a) {\n  void 0 === a && (a = new THREE.MorphAnimMesh(this.geometry, this.material));a.duration = this.duration;a.mirroredLoop = this.mirroredLoop;a.time = this.time;a.lastKeyframe = this.lastKeyframe;a.currentKeyframe = this.currentKeyframe;a.direction = this.direction;a.directionBackwards = this.directionBackwards;THREE.Mesh.prototype.clone.call(this, a);return a;\n};THREE.LOD = function () {\n  THREE.Object3D.call(this);this.objects = [];\n};THREE.LOD.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.LOD.prototype.constructor = THREE.LOD;THREE.LOD.prototype.addLevel = function (a, b) {\n  void 0 === b && (b = 0);b = Math.abs(b);for (var c = 0; c < this.objects.length && !(b < this.objects[c].distance); c++) {}this.objects.splice(c, 0, { distance: b, object: a });this.add(a);\n};THREE.LOD.prototype.getObjectForDistance = function (a) {\n  for (var b = 1, c = this.objects.length; b < c && !(a < this.objects[b].distance); b++) {}return this.objects[b - 1].object;\n};\nTHREE.LOD.prototype.raycast = function () {\n  var a = new THREE.Vector3();return function (b, c) {\n    a.setFromMatrixPosition(this.matrixWorld);var d = b.ray.origin.distanceTo(a);this.getObjectForDistance(d).raycast(b, c);\n  };\n}();\nTHREE.LOD.prototype.update = function () {\n  var a = new THREE.Vector3(),\n      b = new THREE.Vector3();return function (c) {\n    if (1 < this.objects.length) {\n      a.setFromMatrixPosition(c.matrixWorld);b.setFromMatrixPosition(this.matrixWorld);c = a.distanceTo(b);this.objects[0].object.visible = !0;for (var d = 1, e = this.objects.length; d < e; d++) {\n        if (c >= this.objects[d].distance) this.objects[d - 1].object.visible = !1, this.objects[d].object.visible = !0;else break;\n      }for (; d < e; d++) {\n        this.objects[d].object.visible = !1;\n      }\n    }\n  };\n}();\nTHREE.LOD.prototype.clone = function (a) {\n  void 0 === a && (a = new THREE.LOD());THREE.Object3D.prototype.clone.call(this, a);for (var b = 0, c = this.objects.length; b < c; b++) {\n    var d = this.objects[b].object.clone();d.visible = 0 === b;a.addLevel(d, this.objects[b].distance);\n  }return a;\n};\nTHREE.Sprite = function () {\n  var a = new Uint16Array([0, 1, 2, 0, 2, 3]),\n      b = new Float32Array([-.5, -.5, 0, .5, -.5, 0, .5, .5, 0, -.5, .5, 0]),\n      c = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      d = new THREE.BufferGeometry();d.addAttribute(\"index\", new THREE.BufferAttribute(a, 1));d.addAttribute(\"position\", new THREE.BufferAttribute(b, 3));d.addAttribute(\"uv\", new THREE.BufferAttribute(c, 2));return function (a) {\n    THREE.Object3D.call(this);this.type = \"Sprite\";this.geometry = d;this.material = void 0 !== a ? a : new THREE.SpriteMaterial();\n  };\n}();\nTHREE.Sprite.prototype = Object.create(THREE.Object3D.prototype);THREE.Sprite.prototype.constructor = THREE.Sprite;THREE.Sprite.prototype.raycast = function () {\n  var a = new THREE.Vector3();return function (b, c) {\n    a.setFromMatrixPosition(this.matrixWorld);var d = b.ray.distanceToPoint(a);d > this.scale.x || c.push({ distance: d, point: this.position, face: null, object: this });\n  };\n}();THREE.Sprite.prototype.clone = function (a) {\n  void 0 === a && (a = new THREE.Sprite(this.material));THREE.Object3D.prototype.clone.call(this, a);return a;\n};\nTHREE.Particle = THREE.Sprite;THREE.LensFlare = function (a, b, c, d, e) {\n  THREE.Object3D.call(this);this.lensFlares = [];this.positionScreen = new THREE.Vector3();this.customUpdateCallback = void 0;void 0 !== a && this.add(a, b, c, d, e);\n};THREE.LensFlare.prototype = Object.create(THREE.Object3D.prototype);THREE.LensFlare.prototype.constructor = THREE.LensFlare;\nTHREE.LensFlare.prototype.add = function (a, b, c, d, e, f) {\n  void 0 === b && (b = -1);void 0 === c && (c = 0);void 0 === f && (f = 1);void 0 === e && (e = new THREE.Color(16777215));void 0 === d && (d = THREE.NormalBlending);c = Math.min(c, Math.max(0, c));this.lensFlares.push({ texture: a, size: b, distance: c, x: 0, y: 0, z: 0, scale: 1, rotation: 1, opacity: f, color: e, blending: d });\n};\nTHREE.LensFlare.prototype.updateLensFlares = function () {\n  var a,\n      b = this.lensFlares.length,\n      c,\n      d = 2 * -this.positionScreen.x,\n      e = 2 * -this.positionScreen.y;for (a = 0; a < b; a++) {\n    c = this.lensFlares[a], c.x = this.positionScreen.x + d * c.distance, c.y = this.positionScreen.y + e * c.distance, c.wantedRotation = c.x * Math.PI * .25, c.rotation += .25 * (c.wantedRotation - c.rotation);\n  }\n};THREE.Scene = function () {\n  THREE.Object3D.call(this);this.type = \"Scene\";this.overrideMaterial = this.fog = null;this.autoUpdate = !0;\n};THREE.Scene.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.Scene.prototype.constructor = THREE.Scene;THREE.Scene.prototype.clone = function (a) {\n  void 0 === a && (a = new THREE.Scene());THREE.Object3D.prototype.clone.call(this, a);null !== this.fog && (a.fog = this.fog.clone());null !== this.overrideMaterial && (a.overrideMaterial = this.overrideMaterial.clone());a.autoUpdate = this.autoUpdate;a.matrixAutoUpdate = this.matrixAutoUpdate;return a;\n};THREE.Fog = function (a, b, c) {\n  this.name = \"\";this.color = new THREE.Color(a);this.near = void 0 !== b ? b : 1;this.far = void 0 !== c ? c : 1E3;\n};\nTHREE.Fog.prototype.clone = function () {\n  return new THREE.Fog(this.color.getHex(), this.near, this.far);\n};THREE.FogExp2 = function (a, b) {\n  this.name = \"\";this.color = new THREE.Color(a);this.density = void 0 !== b ? b : 2.5E-4;\n};THREE.FogExp2.prototype.clone = function () {\n  return new THREE.FogExp2(this.color.getHex(), this.density);\n};THREE.ShaderChunk = {};THREE.ShaderChunk.common = \"#define PI 3.14159\\n#define PI2 6.28318\\n#define RECIPROCAL_PI2 0.15915494\\n#define LOG2 1.442695\\n#define EPSILON 1e-6\\n\\nfloat square( in float a ) { return a*a; }\\nvec2  square( in vec2 a )  { return vec2( a.x*a.x, a.y*a.y ); }\\nvec3  square( in vec3 a )  { return vec3( a.x*a.x, a.y*a.y, a.z*a.z ); }\\nvec4  square( in vec4 a )  { return vec4( a.x*a.x, a.y*a.y, a.z*a.z, a.w*a.w ); }\\nfloat saturate( in float a ) { return clamp( a, 0.0, 1.0 ); }\\nvec2  saturate( in vec2 a )  { return clamp( a, 0.0, 1.0 ); }\\nvec3  saturate( in vec3 a )  { return clamp( a, 0.0, 1.0 ); }\\nvec4  saturate( in vec4 a )  { return clamp( a, 0.0, 1.0 ); }\\nfloat average( in float a ) { return a; }\\nfloat average( in vec2 a )  { return ( a.x + a.y) * 0.5; }\\nfloat average( in vec3 a )  { return ( a.x + a.y + a.z) / 3.0; }\\nfloat average( in vec4 a )  { return ( a.x + a.y + a.z + a.w) * 0.25; }\\nfloat whiteCompliment( in float a ) { return saturate( 1.0 - a ); }\\nvec2  whiteCompliment( in vec2 a )  { return saturate( vec2(1.0) - a ); }\\nvec3  whiteCompliment( in vec3 a )  { return saturate( vec3(1.0) - a ); }\\nvec4  whiteCompliment( in vec4 a )  { return saturate( vec4(1.0) - a ); }\\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\\n\\treturn normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\\n}\\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\\n\\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal) {\\n\\tfloat distance = dot( planeNormal, point-pointOnPlane );\\n\\treturn point - distance * planeNormal;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn pointOnLine + lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) );\\n}\\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\\n\\tif ( decayExponent > 0.0 ) {\\n\\t  return pow( saturate( 1.0 - lightDistance / cutoffDistance ), decayExponent );\\n\\t}\\n\\treturn 1.0;\\n}\\n\\nvec3 inputToLinear( in vec3 a ) {\\n#ifdef GAMMA_INPUT\\n\\treturn pow( a, vec3( float( GAMMA_FACTOR ) ) );\\n#else\\n\\treturn a;\\n#endif\\n}\\nvec3 linearToOutput( in vec3 a ) {\\n#ifdef GAMMA_OUTPUT\\n\\treturn pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\\n#else\\n\\treturn a;\\n#endif\\n}\\n\";\nTHREE.ShaderChunk.alphatest_fragment = \"#ifdef ALPHATEST\\n\\n\\tif ( diffuseColor.a < ALPHATEST ) discard;\\n\\n#endif\\n\";THREE.ShaderChunk.lights_lambert_vertex = \"vLightFront = vec3( 0.0 );\\n\\n#ifdef DOUBLE_SIDED\\n\\n\\tvLightBack = vec3( 0.0 );\\n\\n#endif\\n\\ntransformedNormal = normalize( transformedNormal );\\n\\n#if MAX_DIR_LIGHTS > 0\\n\\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\\n\\n\\tvec3 dirVector = transformDirection( directionalLightDirection[ i ], viewMatrix );\\n\\n\\tfloat dotProduct = dot( transformedNormal, dirVector );\\n\\tvec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\\n\\n\\t#ifdef DOUBLE_SIDED\\n\\n\\t\\tvec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\\n\\n\\t\\t#ifdef WRAP_AROUND\\n\\n\\t\\t\\tvec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\\n\\n\\t\\t#endif\\n\\n\\t#endif\\n\\n\\t#ifdef WRAP_AROUND\\n\\n\\t\\tvec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\\n\\t\\tdirectionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\\n\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\n\\t\\t\\tdirectionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\\n\\n\\t\\t#endif\\n\\n\\t#endif\\n\\n\\tvLightFront += directionalLightColor[ i ] * directionalLightWeighting;\\n\\n\\t#ifdef DOUBLE_SIDED\\n\\n\\t\\tvLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\\n\\n\\t#endif\\n\\n}\\n\\n#endif\\n\\n#if MAX_POINT_LIGHTS > 0\\n\\n\\tfor( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\\n\\n\\t\\tvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\\n\\t\\tvec3 lVector = lPosition.xyz - mvPosition.xyz;\\n\\n\\t\\tfloat attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\\n\\n\\t\\tlVector = normalize( lVector );\\n\\t\\tfloat dotProduct = dot( transformedNormal, lVector );\\n\\n\\t\\tvec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\\n\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\n\\t\\t\\tvec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\\n\\n\\t\\t\\t#ifdef WRAP_AROUND\\n\\n\\t\\t\\t\\tvec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\\n\\n\\t\\t\\t#endif\\n\\n\\t\\t#endif\\n\\n\\t\\t#ifdef WRAP_AROUND\\n\\n\\t\\t\\tvec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\\n\\t\\t\\tpointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\\n\\n\\t\\t\\t#ifdef DOUBLE_SIDED\\n\\n\\t\\t\\t\\tpointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\\n\\n\\t\\t\\t#endif\\n\\n\\t\\t#endif\\n\\n\\t\\tvLightFront += pointLightColor[ i ] * pointLightWeighting * attenuation;\\n\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\n\\t\\t\\tvLightBack += pointLightColor[ i ] * pointLightWeightingBack * attenuation;\\n\\n\\t\\t#endif\\n\\n\\t}\\n\\n#endif\\n\\n#if MAX_SPOT_LIGHTS > 0\\n\\n\\tfor( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\\n\\n\\t\\tvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\\n\\t\\tvec3 lVector = lPosition.xyz - mvPosition.xyz;\\n\\n\\t\\tfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\\n\\n\\t\\tif ( spotEffect > spotLightAngleCos[ i ] ) {\\n\\n\\t\\t\\tspotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\\n\\n\\t\\t\\tfloat attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\\n\\n\\t\\t\\tlVector = normalize( lVector );\\n\\n\\t\\t\\tfloat dotProduct = dot( transformedNormal, lVector );\\n\\t\\t\\tvec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\\n\\n\\t\\t\\t#ifdef DOUBLE_SIDED\\n\\n\\t\\t\\t\\tvec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\\n\\n\\t\\t\\t\\t#ifdef WRAP_AROUND\\n\\n\\t\\t\\t\\t\\tvec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\\n\\n\\t\\t\\t\\t#endif\\n\\n\\t\\t\\t#endif\\n\\n\\t\\t\\t#ifdef WRAP_AROUND\\n\\n\\t\\t\\t\\tvec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\\n\\t\\t\\t\\tspotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\\n\\n\\t\\t\\t\\t#ifdef DOUBLE_SIDED\\n\\n\\t\\t\\t\\t\\tspotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\\n\\n\\t\\t\\t\\t#endif\\n\\n\\t\\t\\t#endif\\n\\n\\t\\t\\tvLightFront += spotLightColor[ i ] * spotLightWeighting * attenuation * spotEffect;\\n\\n\\t\\t\\t#ifdef DOUBLE_SIDED\\n\\n\\t\\t\\t\\tvLightBack += spotLightColor[ i ] * spotLightWeightingBack * attenuation * spotEffect;\\n\\n\\t\\t\\t#endif\\n\\n\\t\\t}\\n\\n\\t}\\n\\n#endif\\n\\n#if MAX_HEMI_LIGHTS > 0\\n\\n\\tfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\\n\\n\\t\\tvec3 lVector = transformDirection( hemisphereLightDirection[ i ], viewMatrix );\\n\\n\\t\\tfloat dotProduct = dot( transformedNormal, lVector );\\n\\n\\t\\tfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\\n\\t\\tfloat hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\\n\\n\\t\\tvLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\\n\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\n\\t\\t\\tvLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\\n\\n\\t\\t#endif\\n\\n\\t}\\n\\n#endif\\n\\nvLightFront += ambientLightColor;\\n\\n#ifdef DOUBLE_SIDED\\n\\n\\tvLightBack += ambientLightColor;\\n\\n#endif\\n\";\nTHREE.ShaderChunk.map_particle_pars_fragment = \"#ifdef USE_MAP\\n\\n\\tuniform vec4 offsetRepeat;\\n\\tuniform sampler2D map;\\n\\n#endif\\n\";THREE.ShaderChunk.default_vertex = \"#ifdef USE_SKINNING\\n\\n\\tvec4 mvPosition = modelViewMatrix * skinned;\\n\\n#elif defined( USE_MORPHTARGETS )\\n\\n\\tvec4 mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\\n\\n#else\\n\\n\\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\\n#endif\\n\\ngl_Position = projectionMatrix * mvPosition;\\n\";\nTHREE.ShaderChunk.map_pars_fragment = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\\n\\n\\tvarying vec2 vUv;\\n\\n#endif\\n\\n#ifdef USE_MAP\\n\\n\\tuniform sampler2D map;\\n\\n#endif\";THREE.ShaderChunk.skinnormal_vertex = \"#ifdef USE_SKINNING\\n\\n\\tmat4 skinMatrix = mat4( 0.0 );\\n\\tskinMatrix += skinWeight.x * boneMatX;\\n\\tskinMatrix += skinWeight.y * boneMatY;\\n\\tskinMatrix += skinWeight.z * boneMatZ;\\n\\tskinMatrix += skinWeight.w * boneMatW;\\n\\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\n\\n\\t#ifdef USE_MORPHNORMALS\\n\\n\\tvec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\\n\\n\\t#else\\n\\n\\tvec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\\n\\n\\t#endif\\n\\n#endif\\n\";\nTHREE.ShaderChunk.logdepthbuf_pars_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\n\\t\\tvarying float vFragDepth;\\n\\n\\t#endif\\n\\n\\tuniform float logDepthBufFC;\\n\\n#endif\";THREE.ShaderChunk.lightmap_pars_vertex = \"#ifdef USE_LIGHTMAP\\n\\n\\tvarying vec2 vUv2;\\n\\n#endif\";THREE.ShaderChunk.lights_phong_fragment = \"#ifndef FLAT_SHADED\\n\\n\\tvec3 normal = normalize( vNormal );\\n\\n\\t#ifdef DOUBLE_SIDED\\n\\n\\t\\tnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\\n\\n\\t#endif\\n\\n#else\\n\\n\\tvec3 fdx = dFdx( vViewPosition );\\n\\tvec3 fdy = dFdy( vViewPosition );\\n\\tvec3 normal = normalize( cross( fdx, fdy ) );\\n\\n#endif\\n\\nvec3 viewPosition = normalize( vViewPosition );\\n\\n#ifdef USE_NORMALMAP\\n\\n\\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\n\\n#elif defined( USE_BUMPMAP )\\n\\n\\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n\\n#endif\\n\\nvec3 totalDiffuseLight = vec3( 0.0 );\\nvec3 totalSpecularLight = vec3( 0.0 );\\n\\n#if MAX_POINT_LIGHTS > 0\\n\\n\\tfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\\n\\n\\t\\tvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\\n\\t\\tvec3 lVector = lPosition.xyz + vViewPosition.xyz;\\n\\n\\t\\tfloat attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\\n\\n\\t\\tlVector = normalize( lVector );\\n\\n\\t\\t// diffuse\\n\\n\\t\\tfloat dotProduct = dot( normal, lVector );\\n\\n\\t\\t#ifdef WRAP_AROUND\\n\\n\\t\\t\\tfloat pointDiffuseWeightFull = max( dotProduct, 0.0 );\\n\\t\\t\\tfloat pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\\n\\n\\t\\t\\tvec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\\n\\n\\t\\t#else\\n\\n\\t\\t\\tfloat pointDiffuseWeight = max( dotProduct, 0.0 );\\n\\n\\t\\t#endif\\n\\n\\t\\ttotalDiffuseLight += pointLightColor[ i ] * pointDiffuseWeight * attenuation;\\n\\n\\t\\t\\t\\t// specular\\n\\n\\t\\tvec3 pointHalfVector = normalize( lVector + viewPosition );\\n\\t\\tfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\\n\\t\\tfloat pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\\n\\n\\t\\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\\n\\n\\t\\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\\n\\t\\ttotalSpecularLight += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * attenuation * specularNormalization;\\n\\n\\t}\\n\\n#endif\\n\\n#if MAX_SPOT_LIGHTS > 0\\n\\n\\tfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\\n\\n\\t\\tvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\\n\\t\\tvec3 lVector = lPosition.xyz + vViewPosition.xyz;\\n\\n\\t\\tfloat attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\\n\\n\\t\\tlVector = normalize( lVector );\\n\\n\\t\\tfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\\n\\n\\t\\tif ( spotEffect > spotLightAngleCos[ i ] ) {\\n\\n\\t\\t\\tspotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\\n\\n\\t\\t\\t// diffuse\\n\\n\\t\\t\\tfloat dotProduct = dot( normal, lVector );\\n\\n\\t\\t\\t#ifdef WRAP_AROUND\\n\\n\\t\\t\\t\\tfloat spotDiffuseWeightFull = max( dotProduct, 0.0 );\\n\\t\\t\\t\\tfloat spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\\n\\n\\t\\t\\t\\tvec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\\n\\n\\t\\t\\t#else\\n\\n\\t\\t\\t\\tfloat spotDiffuseWeight = max( dotProduct, 0.0 );\\n\\n\\t\\t\\t#endif\\n\\n\\t\\t\\ttotalDiffuseLight += spotLightColor[ i ] * spotDiffuseWeight * attenuation * spotEffect;\\n\\n\\t\\t\\t// specular\\n\\n\\t\\t\\tvec3 spotHalfVector = normalize( lVector + viewPosition );\\n\\t\\t\\tfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\\n\\t\\t\\tfloat spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\\n\\n\\t\\t\\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\\n\\n\\t\\t\\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );\\n\\t\\t\\ttotalSpecularLight += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * attenuation * specularNormalization * spotEffect;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n#endif\\n\\n#if MAX_DIR_LIGHTS > 0\\n\\n\\tfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\\n\\n\\t\\tvec3 dirVector = transformDirection( directionalLightDirection[ i ], viewMatrix );\\n\\n\\t\\t// diffuse\\n\\n\\t\\tfloat dotProduct = dot( normal, dirVector );\\n\\n\\t\\t#ifdef WRAP_AROUND\\n\\n\\t\\t\\tfloat dirDiffuseWeightFull = max( dotProduct, 0.0 );\\n\\t\\t\\tfloat dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\\n\\n\\t\\t\\tvec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\\n\\n\\t\\t#else\\n\\n\\t\\t\\tfloat dirDiffuseWeight = max( dotProduct, 0.0 );\\n\\n\\t\\t#endif\\n\\n\\t\\ttotalDiffuseLight += directionalLightColor[ i ] * dirDiffuseWeight;\\n\\n\\t\\t// specular\\n\\n\\t\\tvec3 dirHalfVector = normalize( dirVector + viewPosition );\\n\\t\\tfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\\n\\t\\tfloat dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\\n\\n\\t\\t/*\\n\\t\\t// fresnel term from skin shader\\n\\t\\tconst float F0 = 0.128;\\n\\n\\t\\tfloat base = 1.0 - dot( viewPosition, dirHalfVector );\\n\\t\\tfloat exponential = pow( base, 5.0 );\\n\\n\\t\\tfloat fresnel = exponential + F0 * ( 1.0 - exponential );\\n\\t\\t*/\\n\\n\\t\\t/*\\n\\t\\t// fresnel term from fresnel shader\\n\\t\\tconst float mFresnelBias = 0.08;\\n\\t\\tconst float mFresnelScale = 0.3;\\n\\t\\tconst float mFresnelPower = 5.0;\\n\\n\\t\\tfloat fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );\\n\\t\\t*/\\n\\n\\t\\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\\n\\n\\t\\t// \\t\\tdirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\\n\\n\\t\\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\\n\\t\\ttotalSpecularLight += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\\n\\n\\n\\t}\\n\\n#endif\\n\\n#if MAX_HEMI_LIGHTS > 0\\n\\n\\tfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\\n\\n\\t\\tvec3 lVector = transformDirection( hemisphereLightDirection[ i ], viewMatrix );\\n\\n\\t\\t// diffuse\\n\\n\\t\\tfloat dotProduct = dot( normal, lVector );\\n\\t\\tfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\\n\\n\\t\\tvec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\\n\\n\\t\\ttotalDiffuseLight += hemiColor;\\n\\n\\t\\t// specular (sky light)\\n\\n\\t\\tvec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\\n\\t\\tfloat hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\\n\\t\\tfloat hemiSpecularWeightSky = specularStrength * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );\\n\\n\\t\\t// specular (ground light)\\n\\n\\t\\tvec3 lVectorGround = -lVector;\\n\\n\\t\\tvec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\\n\\t\\tfloat hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\\n\\t\\tfloat hemiSpecularWeightGround = specularStrength * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );\\n\\n\\t\\tfloat dotProductGround = dot( normal, lVectorGround );\\n\\n\\t\\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\\n\\n\\t\\tvec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\\n\\t\\tvec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\\n\\t\\ttotalSpecularLight += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\\n\\n\\t}\\n\\n#endif\\n\\n#ifdef METAL\\n\\n\\toutgoingLight += diffuseColor.rgb * ( totalDiffuseLight + ambientLightColor ) * specular + totalSpecularLight + emissive;\\n\\n#else\\n\\n\\toutgoingLight += diffuseColor.rgb * ( totalDiffuseLight + ambientLightColor ) + totalSpecularLight + emissive;\\n\\n#endif\\n\";\nTHREE.ShaderChunk.fog_pars_fragment = \"#ifdef USE_FOG\\n\\n\\tuniform vec3 fogColor;\\n\\n\\t#ifdef FOG_EXP2\\n\\n\\t\\tuniform float fogDensity;\\n\\n\\t#else\\n\\n\\t\\tuniform float fogNear;\\n\\t\\tuniform float fogFar;\\n\\t#endif\\n\\n#endif\";THREE.ShaderChunk.morphnormal_vertex = \"#ifdef USE_MORPHNORMALS\\n\\n\\tvec3 morphedNormal = vec3( 0.0 );\\n\\n\\tmorphedNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\n\\tmorphedNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\n\\tmorphedNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\n\\tmorphedNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\n\\n\\tmorphedNormal += normal;\\n\\n#endif\";\nTHREE.ShaderChunk.envmap_pars_fragment = \"#ifdef USE_ENVMAP\\n\\n\\tuniform float reflectivity;\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tuniform samplerCube envMap;\\n\\t#else\\n\\t\\tuniform sampler2D envMap;\\n\\t#endif\\n\\tuniform float flipEnvMap;\\n\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\n\\t\\tuniform float refractionRatio;\\n\\n\\t#else\\n\\n\\t\\tvarying vec3 vReflect;\\n\\n\\t#endif\\n\\n#endif\\n\";THREE.ShaderChunk.logdepthbuf_fragment = \"#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\\n\\n\\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\\n\\n#endif\";\nTHREE.ShaderChunk.normalmap_pars_fragment = \"#ifdef USE_NORMALMAP\\n\\n\\tuniform sampler2D normalMap;\\n\\tuniform vec2 normalScale;\\n\\n\\t// Per-Pixel Tangent Space Normal Mapping\\n\\t// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\\n\\n\\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\n\\n\\t\\tvec3 q0 = dFdx( eye_pos.xyz );\\n\\t\\tvec3 q1 = dFdy( eye_pos.xyz );\\n\\t\\tvec2 st0 = dFdx( vUv.st );\\n\\t\\tvec2 st1 = dFdy( vUv.st );\\n\\n\\t\\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\\n\\t\\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\n\\t\\tvec3 N = normalize( surf_norm );\\n\\n\\t\\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\t\\tmapN.xy = normalScale * mapN.xy;\\n\\t\\tmat3 tsn = mat3( S, T, N );\\n\\t\\treturn normalize( tsn * mapN );\\n\\n\\t}\\n\\n#endif\\n\";\nTHREE.ShaderChunk.lights_phong_pars_vertex = \"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\\n\\n\\tvarying vec3 vWorldPosition;\\n\\n#endif\\n\";THREE.ShaderChunk.lightmap_pars_fragment = \"#ifdef USE_LIGHTMAP\\n\\n\\tvarying vec2 vUv2;\\n\\tuniform sampler2D lightMap;\\n\\n#endif\";THREE.ShaderChunk.shadowmap_vertex = \"#ifdef USE_SHADOWMAP\\n\\n\\tfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\\n\\n\\t\\tvShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\\n\\n\\t}\\n\\n#endif\";\nTHREE.ShaderChunk.lights_phong_vertex = \"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\\n\\n\\tvWorldPosition = worldPosition.xyz;\\n\\n#endif\";THREE.ShaderChunk.map_fragment = \"#ifdef USE_MAP\\n\\n\\tvec4 texelColor = texture2D( map, vUv );\\n\\n\\ttexelColor.xyz = inputToLinear( texelColor.xyz );\\n\\n\\tdiffuseColor *= texelColor;\\n\\n#endif\";THREE.ShaderChunk.lightmap_vertex = \"#ifdef USE_LIGHTMAP\\n\\n\\tvUv2 = uv2;\\n\\n#endif\";THREE.ShaderChunk.map_particle_fragment = \"#ifdef USE_MAP\\n\\n\\tdiffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\\n\\n#endif\\n\";\nTHREE.ShaderChunk.color_pars_fragment = \"#ifdef USE_COLOR\\n\\n\\tvarying vec3 vColor;\\n\\n#endif\\n\";THREE.ShaderChunk.color_vertex = \"#ifdef USE_COLOR\\n\\n\\tvColor.xyz = inputToLinear( color.xyz );\\n\\n#endif\";THREE.ShaderChunk.skinning_vertex = \"#ifdef USE_SKINNING\\n\\n\\t#ifdef USE_MORPHTARGETS\\n\\n\\tvec4 skinVertex = bindMatrix * vec4( morphed, 1.0 );\\n\\n\\t#else\\n\\n\\tvec4 skinVertex = bindMatrix * vec4( position, 1.0 );\\n\\n\\t#endif\\n\\n\\tvec4 skinned = vec4( 0.0 );\\n\\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\\tskinned  = bindMatrixInverse * skinned;\\n\\n#endif\\n\";\nTHREE.ShaderChunk.envmap_pars_vertex = \"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\\n\\n\\tvarying vec3 vReflect;\\n\\n\\tuniform float refractionRatio;\\n\\n#endif\\n\";THREE.ShaderChunk.linear_to_gamma_fragment = \"\\n\\toutgoingLight = linearToOutput( outgoingLight );\\n\";THREE.ShaderChunk.color_pars_vertex = \"#ifdef USE_COLOR\\n\\n\\tvarying vec3 vColor;\\n\\n#endif\";THREE.ShaderChunk.lights_lambert_pars_vertex = \"uniform vec3 ambientLightColor;\\n\\n#if MAX_DIR_LIGHTS > 0\\n\\n\\tuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\\n\\tuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_HEMI_LIGHTS > 0\\n\\n\\tuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\\n\\tuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\\n\\tuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_POINT_LIGHTS > 0\\n\\n\\tuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\\n\\tuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\\n\\tuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\\n\\tuniform float pointLightDecay[ MAX_POINT_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_SPOT_LIGHTS > 0\\n\\n\\tuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\\n\\tuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\\n\\tuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\\n\\tuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\\n\\tuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\\n\\tuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\\n\\tuniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\\n\\n#endif\\n\\n#ifdef WRAP_AROUND\\n\\n\\tuniform vec3 wrapRGB;\\n\\n#endif\\n\";\nTHREE.ShaderChunk.map_pars_vertex = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\\n\\n\\tvarying vec2 vUv;\\n\\tuniform vec4 offsetRepeat;\\n\\n#endif\\n\";THREE.ShaderChunk.envmap_fragment = \"#ifdef USE_ENVMAP\\n\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\n\\t\\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\n\\n\\t\\t// Transforming Normal Vectors with the Inverse Transformation\\n\\t\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\n\\t\\t\\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\n\\n\\t\\t#else\\n\\n\\t\\t\\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\n\\t\\t#endif\\n\\n\\t#else\\n\\n\\t\\tvec3 reflectVec = vReflect;\\n\\n\\t#endif\\n\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\tfloat flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\\n\\t#else\\n\\t\\tfloat flipNormal = 1.0;\\n\\t#endif\\n\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\\n\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\\t\\tvec2 sampleUV;\\n\\t\\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\\t\\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\\t\\tvec4 envColor = texture2D( envMap, sampleUV );\\n\\n\\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\\t\\tvec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\\n\\t\\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\n\\t#endif\\n\\n\\tenvColor.xyz = inputToLinear( envColor.xyz );\\n\\n\\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\\n\\t\\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\\n\\t#elif defined( ENVMAP_BLENDING_MIX )\\n\\n\\t\\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\\n\\t#elif defined( ENVMAP_BLENDING_ADD )\\n\\n\\t\\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\\n\\t#endif\\n\\n#endif\\n\";\nTHREE.ShaderChunk.specularmap_pars_fragment = \"#ifdef USE_SPECULARMAP\\n\\n\\tuniform sampler2D specularMap;\\n\\n#endif\";THREE.ShaderChunk.logdepthbuf_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\n\\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\\n\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\n\\t\\tvFragDepth = 1.0 + gl_Position.w;\\n\\n#else\\n\\n\\t\\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\\n\\n\\t#endif\\n\\n#endif\";THREE.ShaderChunk.morphtarget_pars_vertex = \"#ifdef USE_MORPHTARGETS\\n\\n\\t#ifndef USE_MORPHNORMALS\\n\\n\\tuniform float morphTargetInfluences[ 8 ];\\n\\n\\t#else\\n\\n\\tuniform float morphTargetInfluences[ 4 ];\\n\\n\\t#endif\\n\\n#endif\";\nTHREE.ShaderChunk.specularmap_fragment = \"float specularStrength;\\n\\n#ifdef USE_SPECULARMAP\\n\\n\\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\\tspecularStrength = texelSpecular.r;\\n\\n#else\\n\\n\\tspecularStrength = 1.0;\\n\\n#endif\";THREE.ShaderChunk.fog_fragment = \"#ifdef USE_FOG\\n\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\n\\t\\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\\n\\n\\t#else\\n\\n\\t\\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\n\\n\\t#endif\\n\\n\\t#ifdef FOG_EXP2\\n\\n\\t\\tfloat fogFactor = exp2( - square( fogDensity ) * square( depth ) * LOG2 );\\n\\t\\tfogFactor = whiteCompliment( fogFactor );\\n\\n\\t#else\\n\\n\\t\\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\\n\\n\\t#endif\\n\\t\\n\\toutgoingLight = mix( outgoingLight, fogColor, fogFactor );\\n\\n#endif\";\nTHREE.ShaderChunk.bumpmap_pars_fragment = \"#ifdef USE_BUMPMAP\\n\\n\\tuniform sampler2D bumpMap;\\n\\tuniform float bumpScale;\\n\\n\\t// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\\n\\t// http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\\n\\n\\t// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\\n\\n\\tvec2 dHdxy_fwd() {\\n\\n\\t\\tvec2 dSTdx = dFdx( vUv );\\n\\t\\tvec2 dSTdy = dFdy( vUv );\\n\\n\\t\\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\\t\\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\\t\\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\\n\\t\\treturn vec2( dBx, dBy );\\n\\n\\t}\\n\\n\\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n\\n\\t\\tvec3 vSigmaX = dFdx( surf_pos );\\n\\t\\tvec3 vSigmaY = dFdy( surf_pos );\\n\\t\\tvec3 vN = surf_norm;\\t\\t// normalized\\n\\n\\t\\tvec3 R1 = cross( vSigmaY, vN );\\n\\t\\tvec3 R2 = cross( vN, vSigmaX );\\n\\n\\t\\tfloat fDet = dot( vSigmaX, R1 );\\n\\n\\t\\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\\t\\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\\n\\t}\\n\\n#endif\\n\";\nTHREE.ShaderChunk.defaultnormal_vertex = \"#ifdef USE_SKINNING\\n\\n\\tvec3 objectNormal = skinnedNormal.xyz;\\n\\n#elif defined( USE_MORPHNORMALS )\\n\\n\\tvec3 objectNormal = morphedNormal;\\n\\n#else\\n\\n\\tvec3 objectNormal = normal;\\n\\n#endif\\n\\n#ifdef FLIP_SIDED\\n\\n\\tobjectNormal = -objectNormal;\\n\\n#endif\\n\\nvec3 transformedNormal = normalMatrix * objectNormal;\\n\";THREE.ShaderChunk.lights_phong_pars_fragment = \"uniform vec3 ambientLightColor;\\n\\n#if MAX_DIR_LIGHTS > 0\\n\\n\\tuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\\n\\tuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_HEMI_LIGHTS > 0\\n\\n\\tuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\\n\\tuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\\n\\tuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_POINT_LIGHTS > 0\\n\\n\\tuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\\n\\n\\tuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\\n\\tuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\\n\\tuniform float pointLightDecay[ MAX_POINT_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_SPOT_LIGHTS > 0\\n\\n\\tuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\\n\\tuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\\n\\tuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\\n\\tuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\\n\\tuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\\n\\tuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\\n\\tuniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\\n\\n\\tvarying vec3 vWorldPosition;\\n\\n#endif\\n\\n#ifdef WRAP_AROUND\\n\\n\\tuniform vec3 wrapRGB;\\n\\n#endif\\n\\nvarying vec3 vViewPosition;\\n\\n#ifndef FLAT_SHADED\\n\\n\\tvarying vec3 vNormal;\\n\\n#endif\\n\";\nTHREE.ShaderChunk.skinbase_vertex = \"#ifdef USE_SKINNING\\n\\n\\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n\\n#endif\";THREE.ShaderChunk.map_vertex = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\\n\\n\\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\\n\\n#endif\";\nTHREE.ShaderChunk.lightmap_fragment = \"#ifdef USE_LIGHTMAP\\n\\n\\toutgoingLight *= diffuseColor.xyz * texture2D( lightMap, vUv2 ).xyz;\\n\\n#endif\";THREE.ShaderChunk.shadowmap_pars_vertex = \"#ifdef USE_SHADOWMAP\\n\\n\\tvarying vec4 vShadowCoord[ MAX_SHADOWS ];\\n\\tuniform mat4 shadowMatrix[ MAX_SHADOWS ];\\n\\n#endif\";THREE.ShaderChunk.color_fragment = \"#ifdef USE_COLOR\\n\\n\\tdiffuseColor.rgb *= vColor;\\n\\n#endif\";THREE.ShaderChunk.morphtarget_vertex = \"#ifdef USE_MORPHTARGETS\\n\\n\\tvec3 morphed = vec3( 0.0 );\\n\\tmorphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\n\\tmorphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\n\\tmorphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\n\\tmorphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n\\n\\t#ifndef USE_MORPHNORMALS\\n\\n\\tmorphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\n\\tmorphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\n\\tmorphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\n\\tmorphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n\\n\\t#endif\\n\\n\\tmorphed += position;\\n\\n#endif\";\nTHREE.ShaderChunk.envmap_vertex = \"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\\n\\n\\tvec3 worldNormal = transformDirection( objectNormal, modelMatrix );\\n\\n\\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\\n\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\n\\t\\tvReflect = reflect( cameraToVertex, worldNormal );\\n\\n\\t#else\\n\\n\\t\\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\n\\t#endif\\n\\n#endif\\n\";\nTHREE.ShaderChunk.shadowmap_fragment = \"#ifdef USE_SHADOWMAP\\n\\n\\t#ifdef SHADOWMAP_DEBUG\\n\\n\\t\\tvec3 frustumColors[3];\\n\\t\\tfrustumColors[0] = vec3( 1.0, 0.5, 0.0 );\\n\\t\\tfrustumColors[1] = vec3( 0.0, 1.0, 0.8 );\\n\\t\\tfrustumColors[2] = vec3( 0.0, 0.5, 1.0 );\\n\\n\\t#endif\\n\\n\\t#ifdef SHADOWMAP_CASCADE\\n\\n\\t\\tint inFrustumCount = 0;\\n\\n\\t#endif\\n\\n\\tfloat fDepth;\\n\\tvec3 shadowColor = vec3( 1.0 );\\n\\n\\tfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\\n\\n\\t\\tvec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\\n\\n\\t\\t\\t\\t// if ( something && something ) breaks ATI OpenGL shader compiler\\n\\t\\t\\t\\t// if ( all( something, something ) ) using this instead\\n\\n\\t\\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\\t\\tbool inFrustum = all( inFrustumVec );\\n\\n\\t\\t\\t\\t// don't shadow pixels outside of light frustum\\n\\t\\t\\t\\t// use just first frustum (for cascades)\\n\\t\\t\\t\\t// don't shadow pixels behind far plane of light frustum\\n\\n\\t\\t#ifdef SHADOWMAP_CASCADE\\n\\n\\t\\t\\tinFrustumCount += int( inFrustum );\\n\\t\\t\\tbvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\\n\\n\\t\\t#else\\n\\n\\t\\t\\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\\n\\t\\t#endif\\n\\n\\t\\tbool frustumTest = all( frustumTestVec );\\n\\n\\t\\tif ( frustumTest ) {\\n\\n\\t\\t\\tshadowCoord.z += shadowBias[ i ];\\n\\n\\t\\t\\t#if defined( SHADOWMAP_TYPE_PCF )\\n\\n\\t\\t\\t\\t\\t\\t// Percentage-close filtering\\n\\t\\t\\t\\t\\t\\t// (9 pixel kernel)\\n\\t\\t\\t\\t\\t\\t// http://fabiensanglard.net/shadowmappingPCF/\\n\\n\\t\\t\\t\\tfloat shadow = 0.0;\\n\\n\\t\\t/*\\n\\t\\t\\t\\t\\t\\t// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\\n\\t\\t\\t\\t\\t\\t// must enroll loop manually\\n\\n\\t\\t\\t\\tfor ( float y = -1.25; y <= 1.25; y += 1.25 )\\n\\t\\t\\t\\t\\tfor ( float x = -1.25; x <= 1.25; x += 1.25 ) {\\n\\n\\t\\t\\t\\t\\t\\tvec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\\n\\t\\t\\t\\t\\t\\t\\t\\t//vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\\n\\n\\t\\t\\t\\t\\t\\tfloat fDepth = unpackDepth( rgbaDepth );\\n\\n\\t\\t\\t\\t\\t\\tif ( fDepth < shadowCoord.z )\\n\\t\\t\\t\\t\\t\\t\\tshadow += 1.0;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tshadow /= 9.0;\\n\\n\\t\\t*/\\n\\n\\t\\t\\t\\tconst float shadowDelta = 1.0 / 9.0;\\n\\n\\t\\t\\t\\tfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\\n\\t\\t\\t\\tfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\\n\\n\\t\\t\\t\\tfloat dx0 = -1.25 * xPixelOffset;\\n\\t\\t\\t\\tfloat dy0 = -1.25 * yPixelOffset;\\n\\t\\t\\t\\tfloat dx1 = 1.25 * xPixelOffset;\\n\\t\\t\\t\\tfloat dy1 = 1.25 * yPixelOffset;\\n\\n\\t\\t\\t\\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\\n\\t\\t\\t\\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\\t\\t\\t\\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\\n\\t\\t\\t\\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\\t\\t\\t\\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\\n\\t\\t\\t\\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\\t\\t\\t\\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\\n\\t\\t\\t\\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\\t\\t\\t\\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\\n\\t\\t\\t\\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\\t\\t\\t\\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\\n\\t\\t\\t\\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\\t\\t\\t\\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\\n\\t\\t\\t\\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\\t\\t\\t\\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\\n\\t\\t\\t\\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\\t\\t\\t\\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\\n\\t\\t\\t\\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\\t\\t\\t\\tshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\\n\\n\\t\\t\\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\n\\t\\t\\t\\t\\t\\t// Percentage-close filtering\\n\\t\\t\\t\\t\\t\\t// (9 pixel kernel)\\n\\t\\t\\t\\t\\t\\t// http://fabiensanglard.net/shadowmappingPCF/\\n\\n\\t\\t\\t\\tfloat shadow = 0.0;\\n\\n\\t\\t\\t\\tfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\\n\\t\\t\\t\\tfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\\n\\n\\t\\t\\t\\tfloat dx0 = -1.0 * xPixelOffset;\\n\\t\\t\\t\\tfloat dy0 = -1.0 * yPixelOffset;\\n\\t\\t\\t\\tfloat dx1 = 1.0 * xPixelOffset;\\n\\t\\t\\t\\tfloat dy1 = 1.0 * yPixelOffset;\\n\\n\\t\\t\\t\\tmat3 shadowKernel;\\n\\t\\t\\t\\tmat3 depthKernel;\\n\\n\\t\\t\\t\\tdepthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\\n\\t\\t\\t\\tdepthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\\n\\t\\t\\t\\tdepthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\\n\\t\\t\\t\\tdepthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\\n\\t\\t\\t\\tdepthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\\n\\t\\t\\t\\tdepthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\\n\\t\\t\\t\\tdepthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\\n\\t\\t\\t\\tdepthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\\n\\t\\t\\t\\tdepthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\\n\\n\\t\\t\\t\\tvec3 shadowZ = vec3( shadowCoord.z );\\n\\t\\t\\t\\tshadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\\n\\t\\t\\t\\tshadowKernel[0] *= vec3(0.25);\\n\\n\\t\\t\\t\\tshadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\\n\\t\\t\\t\\tshadowKernel[1] *= vec3(0.25);\\n\\n\\t\\t\\t\\tshadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\\n\\t\\t\\t\\tshadowKernel[2] *= vec3(0.25);\\n\\n\\t\\t\\t\\tvec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\\n\\n\\t\\t\\t\\tshadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\\n\\t\\t\\t\\tshadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\\n\\n\\t\\t\\t\\tvec4 shadowValues;\\n\\t\\t\\t\\tshadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\\n\\t\\t\\t\\tshadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\\n\\t\\t\\t\\tshadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\\n\\t\\t\\t\\tshadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\\n\\n\\t\\t\\t\\tshadow = dot( shadowValues, vec4( 1.0 ) );\\n\\n\\t\\t\\t\\tshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\\n\\n\\t\\t\\t#else\\n\\n\\t\\t\\t\\tvec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\\n\\t\\t\\t\\tfloat fDepth = unpackDepth( rgbaDepth );\\n\\n\\t\\t\\t\\tif ( fDepth < shadowCoord.z )\\n\\n\\t\\t// spot with multiple shadows is darker\\n\\n\\t\\t\\t\\t\\tshadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\\n\\n\\t\\t// spot with multiple shadows has the same color as single shadow spot\\n\\n\\t\\t// \\t\\t\\t\\t\\tshadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\\n\\n\\t\\t\\t#endif\\n\\n\\t\\t}\\n\\n\\n\\t\\t#ifdef SHADOWMAP_DEBUG\\n\\n\\t\\t\\t#ifdef SHADOWMAP_CASCADE\\n\\n\\t\\t\\t\\tif ( inFrustum && inFrustumCount == 1 ) outgoingLight *= frustumColors[ i ];\\n\\n\\t\\t\\t#else\\n\\n\\t\\t\\t\\tif ( inFrustum ) outgoingLight *= frustumColors[ i ];\\n\\n\\t\\t\\t#endif\\n\\n\\t\\t#endif\\n\\n\\t}\\n\\n\\t// NOTE: I am unsure if this is correct in linear space.  -bhouston, Dec 29, 2014\\n\\tshadowColor = inputToLinear( shadowColor );\\n\\n\\toutgoingLight = outgoingLight * shadowColor;\\n\\n#endif\\n\";\nTHREE.ShaderChunk.worldpos_vertex = \"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\\n\\n\\t#ifdef USE_SKINNING\\n\\n\\t\\tvec4 worldPosition = modelMatrix * skinned;\\n\\n\\t#elif defined( USE_MORPHTARGETS )\\n\\n\\t\\tvec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\\n\\n\\t#else\\n\\n\\t\\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\\n\\n\\t#endif\\n\\n#endif\\n\";THREE.ShaderChunk.shadowmap_pars_fragment = \"#ifdef USE_SHADOWMAP\\n\\n\\tuniform sampler2D shadowMap[ MAX_SHADOWS ];\\n\\tuniform vec2 shadowMapSize[ MAX_SHADOWS ];\\n\\n\\tuniform float shadowDarkness[ MAX_SHADOWS ];\\n\\tuniform float shadowBias[ MAX_SHADOWS ];\\n\\n\\tvarying vec4 vShadowCoord[ MAX_SHADOWS ];\\n\\n\\tfloat unpackDepth( const in vec4 rgba_depth ) {\\n\\n\\t\\tconst vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\\n\\t\\tfloat depth = dot( rgba_depth, bit_shift );\\n\\t\\treturn depth;\\n\\n\\t}\\n\\n#endif\";\nTHREE.ShaderChunk.skinning_pars_vertex = \"#ifdef USE_SKINNING\\n\\n\\tuniform mat4 bindMatrix;\\n\\tuniform mat4 bindMatrixInverse;\\n\\n\\t#ifdef BONE_TEXTURE\\n\\n\\t\\tuniform sampler2D boneTexture;\\n\\t\\tuniform int boneTextureWidth;\\n\\t\\tuniform int boneTextureHeight;\\n\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\n\\t\\t\\tfloat j = i * 4.0;\\n\\t\\t\\tfloat x = mod( j, float( boneTextureWidth ) );\\n\\t\\t\\tfloat y = floor( j / float( boneTextureWidth ) );\\n\\n\\t\\t\\tfloat dx = 1.0 / float( boneTextureWidth );\\n\\t\\t\\tfloat dy = 1.0 / float( boneTextureHeight );\\n\\n\\t\\t\\ty = dy * ( y + 0.5 );\\n\\n\\t\\t\\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\\t\\t\\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\\t\\t\\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\\t\\t\\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\\n\\t\\t\\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\\n\\t\\t\\treturn bone;\\n\\n\\t\\t}\\n\\n\\t#else\\n\\n\\t\\tuniform mat4 boneGlobalMatrices[ MAX_BONES ];\\n\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\n\\t\\t\\tmat4 bone = boneGlobalMatrices[ int(i) ];\\n\\t\\t\\treturn bone;\\n\\n\\t\\t}\\n\\n\\t#endif\\n\\n#endif\\n\";\nTHREE.ShaderChunk.logdepthbuf_pars_fragment = \"#ifdef USE_LOGDEPTHBUF\\n\\n\\tuniform float logDepthBufFC;\\n\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\n\\t\\t#extension GL_EXT_frag_depth : enable\\n\\t\\tvarying float vFragDepth;\\n\\n\\t#endif\\n\\n#endif\";THREE.ShaderChunk.alphamap_fragment = \"#ifdef USE_ALPHAMAP\\n\\n\\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n\\n#endif\\n\";THREE.ShaderChunk.alphamap_pars_fragment = \"#ifdef USE_ALPHAMAP\\n\\n\\tuniform sampler2D alphaMap;\\n\\n#endif\\n\";\nTHREE.UniformsUtils = { merge: function merge(a) {\n    for (var b = {}, c = 0; c < a.length; c++) {\n      var d = this.clone(a[c]),\n          e;for (e in d) {\n        b[e] = d[e];\n      }\n    }return b;\n  }, clone: function clone(a) {\n    var b = {},\n        c;for (c in a) {\n      b[c] = {};for (var d in a[c]) {\n        var e = a[c][d];b[c][d] = e instanceof THREE.Color || e instanceof THREE.Vector2 || e instanceof THREE.Vector3 || e instanceof THREE.Vector4 || e instanceof THREE.Matrix4 || e instanceof THREE.Texture ? e.clone() : e instanceof Array ? e.slice() : e;\n      }\n    }return b;\n  } };\nTHREE.UniformsLib = { common: { diffuse: { type: \"c\", value: new THREE.Color(15658734) }, opacity: { type: \"f\", value: 1 }, map: { type: \"t\", value: null }, offsetRepeat: { type: \"v4\", value: new THREE.Vector4(0, 0, 1, 1) }, lightMap: { type: \"t\", value: null }, specularMap: { type: \"t\", value: null }, alphaMap: { type: \"t\", value: null }, envMap: { type: \"t\", value: null }, flipEnvMap: { type: \"f\", value: -1 }, reflectivity: { type: \"f\", value: 1 }, refractionRatio: { type: \"f\", value: .98 }, morphTargetInfluences: { type: \"f\", value: 0 } }, bump: { bumpMap: { type: \"t\", value: null }, bumpScale: { type: \"f\",\n      value: 1 } }, normalmap: { normalMap: { type: \"t\", value: null }, normalScale: { type: \"v2\", value: new THREE.Vector2(1, 1) } }, fog: { fogDensity: { type: \"f\", value: 2.5E-4 }, fogNear: { type: \"f\", value: 1 }, fogFar: { type: \"f\", value: 2E3 }, fogColor: { type: \"c\", value: new THREE.Color(16777215) } }, lights: { ambientLightColor: { type: \"fv\", value: [] }, directionalLightDirection: { type: \"fv\", value: [] }, directionalLightColor: { type: \"fv\", value: [] }, hemisphereLightDirection: { type: \"fv\", value: [] }, hemisphereLightSkyColor: { type: \"fv\", value: [] }, hemisphereLightGroundColor: { type: \"fv\",\n      value: [] }, pointLightColor: { type: \"fv\", value: [] }, pointLightPosition: { type: \"fv\", value: [] }, pointLightDistance: { type: \"fv1\", value: [] }, pointLightDecay: { type: \"fv1\", value: [] }, spotLightColor: { type: \"fv\", value: [] }, spotLightPosition: { type: \"fv\", value: [] }, spotLightDirection: { type: \"fv\", value: [] }, spotLightDistance: { type: \"fv1\", value: [] }, spotLightAngleCos: { type: \"fv1\", value: [] }, spotLightExponent: { type: \"fv1\", value: [] }, spotLightDecay: { type: \"fv1\", value: [] } }, particle: { psColor: { type: \"c\", value: new THREE.Color(15658734) }, opacity: { type: \"f\",\n      value: 1 }, size: { type: \"f\", value: 1 }, scale: { type: \"f\", value: 1 }, map: { type: \"t\", value: null }, offsetRepeat: { type: \"v4\", value: new THREE.Vector4(0, 0, 1, 1) }, fogDensity: { type: \"f\", value: 2.5E-4 }, fogNear: { type: \"f\", value: 1 }, fogFar: { type: \"f\", value: 2E3 }, fogColor: { type: \"c\", value: new THREE.Color(16777215) } }, shadowmap: { shadowMap: { type: \"tv\", value: [] }, shadowMapSize: { type: \"v2v\", value: [] }, shadowBias: { type: \"fv1\", value: [] }, shadowDarkness: { type: \"fv1\", value: [] }, shadowMatrix: { type: \"m4v\", value: [] } } };\nTHREE.ShaderLib = { basic: { uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, THREE.UniformsLib.shadowmap]), vertexShader: [THREE.ShaderChunk.common, THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, \"void main() {\", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.skinbase_vertex, \"\\t#ifdef USE_ENVMAP\", THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, \"\\t#endif\", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.shadowmap_vertex, \"}\"].join(\"\\n\"), fragmentShader: [\"uniform vec3 diffuse;\\nuniform float opacity;\", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.alphamap_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, \"void main() {\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.alphamap_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, \"\\toutgoingLight = diffuseColor.rgb;\", THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, \"\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n}\"].join(\"\\n\") },\n  lambert: { uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap, { emissive: { type: \"c\", value: new THREE.Color(0) }, wrapRGB: { type: \"v3\", value: new THREE.Vector3(1, 1, 1) } }]), vertexShader: [\"#define LAMBERT\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n#endif\", THREE.ShaderChunk.common, THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.lights_lambert_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, \"void main() {\", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.lights_lambert_vertex, THREE.ShaderChunk.shadowmap_vertex, \"}\"].join(\"\\n\"), fragmentShader: [\"uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n#endif\", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.alphamap_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, \"void main() {\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.alphamap_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, \"\\t#ifdef DOUBLE_SIDED\\n\\t\\tif ( gl_FrontFacing )\\n\\t\\t\\toutgoingLight += diffuseColor.rgb * vLightFront + emissive;\\n\\t\\telse\\n\\t\\t\\toutgoingLight += diffuseColor.rgb * vLightBack + emissive;\\n\\t#else\\n\\t\\toutgoingLight += diffuseColor.rgb * vLightFront + emissive;\\n\\t#endif\", THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, \"\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n}\"].join(\"\\n\") },\n  phong: { uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.bump, THREE.UniformsLib.normalmap, THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap, { emissive: { type: \"c\", value: new THREE.Color(0) }, specular: { type: \"c\", value: new THREE.Color(1118481) }, shininess: { type: \"f\", value: 30 }, wrapRGB: { type: \"v3\", value: new THREE.Vector3(1, 1, 1) } }]), vertexShader: [\"#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\", THREE.ShaderChunk.common, THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.lights_phong_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, \"void main() {\", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, \"#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, \"\\tvViewPosition = -mvPosition.xyz;\", THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.lights_phong_vertex, THREE.ShaderChunk.shadowmap_vertex, \"}\"].join(\"\\n\"), fragmentShader: [\"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.alphamap_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.lights_phong_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.bumpmap_pars_fragment, THREE.ShaderChunk.normalmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, \"void main() {\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.alphamap_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, THREE.ShaderChunk.lights_phong_fragment, THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, \"\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n}\"].join(\"\\n\") }, particle_basic: { uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.particle, THREE.UniformsLib.shadowmap]), vertexShader: [\"uniform float size;\\nuniform float scale;\", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, \"void main() {\", THREE.ShaderChunk.color_vertex, \"\\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\\t#ifdef USE_SIZEATTENUATION\\n\\t\\tgl_PointSize = size * ( scale / length( mvPosition.xyz ) );\\n\\t#else\\n\\t\\tgl_PointSize = size;\\n\\t#endif\\n\\tgl_Position = projectionMatrix * mvPosition;\", THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.shadowmap_vertex, \"}\"].join(\"\\n\"), fragmentShader: [\"uniform vec3 psColor;\\nuniform float opacity;\", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_particle_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, \"void main() {\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( psColor, opacity );\", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_particle_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.alphatest_fragment, \"\\toutgoingLight = diffuseColor.rgb;\", THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.fog_fragment, \"\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n}\"].join(\"\\n\") }, dashed: { uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, { scale: { type: \"f\", value: 1 }, dashSize: { type: \"f\", value: 1 }, totalSize: { type: \"f\", value: 2 } }]),\n    vertexShader: [\"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, \"void main() {\", THREE.ShaderChunk.color_vertex, \"\\tvLineDistance = scale * lineDistance;\\n\\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\\tgl_Position = projectionMatrix * mvPosition;\", THREE.ShaderChunk.logdepthbuf_vertex, \"}\"].join(\"\\n\"), fragmentShader: [\"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\", THREE.ShaderChunk.common, THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, \"void main() {\\n\\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\\t\\tdiscard;\\n\\t}\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.color_fragment, \"\\toutgoingLight = diffuseColor.rgb;\", THREE.ShaderChunk.fog_fragment, \"\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n}\"].join(\"\\n\") },\n  depth: { uniforms: { mNear: { type: \"f\", value: 1 }, mFar: { type: \"f\", value: 2E3 }, opacity: { type: \"f\", value: 1 } }, vertexShader: [THREE.ShaderChunk.common, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, \"void main() {\", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, \"}\"].join(\"\\n\"), fragmentShader: [\"uniform float mNear;\\nuniform float mFar;\\nuniform float opacity;\", THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_fragment, \"void main() {\", THREE.ShaderChunk.logdepthbuf_fragment, \"\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\\n\\t#else\\n\\t\\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\n\\t#endif\\n\\tfloat color = 1.0 - smoothstep( mNear, mFar, depth );\\n\\tgl_FragColor = vec4( vec3( color ), opacity );\\n}\"].join(\"\\n\") }, normal: { uniforms: { opacity: { type: \"f\", value: 1 } }, vertexShader: [\"varying vec3 vNormal;\", THREE.ShaderChunk.common, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, \"void main() {\\n\\tvNormal = normalize( normalMatrix * normal );\", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, \"}\"].join(\"\\n\"), fragmentShader: [\"uniform float opacity;\\nvarying vec3 vNormal;\", THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_fragment, \"void main() {\\n\\tgl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );\", THREE.ShaderChunk.logdepthbuf_fragment, \"}\"].join(\"\\n\") }, cube: { uniforms: { tCube: { type: \"t\", value: null },\n      tFlip: { type: \"f\", value: -1 } }, vertexShader: [\"varying vec3 vWorldPosition;\", THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_vertex, \"void main() {\\n\\tvWorldPosition = transformDirection( position, modelMatrix );\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", THREE.ShaderChunk.logdepthbuf_vertex, \"}\"].join(\"\\n\"), fragmentShader: [\"uniform samplerCube tCube;\\nuniform float tFlip;\\nvarying vec3 vWorldPosition;\", THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_fragment, \"void main() {\\n\\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\", THREE.ShaderChunk.logdepthbuf_fragment, \"}\"].join(\"\\n\") }, equirect: { uniforms: { tEquirect: { type: \"t\", value: null }, tFlip: { type: \"f\", value: -1 } }, vertexShader: [\"varying vec3 vWorldPosition;\", THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_vertex, \"void main() {\\n\\tvWorldPosition = transformDirection( position, modelMatrix );\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", THREE.ShaderChunk.logdepthbuf_vertex, \"}\"].join(\"\\n\"), fragmentShader: [\"uniform sampler2D tEquirect;\\nuniform float tFlip;\\nvarying vec3 vWorldPosition;\", THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_fragment, \"void main() {\\nvec3 direction = normalize( vWorldPosition );\\nvec2 sampleUV;\\nsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\\nsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\\ngl_FragColor = texture2D( tEquirect, sampleUV );\", THREE.ShaderChunk.logdepthbuf_fragment, \"}\"].join(\"\\n\") }, depthRGBA: { uniforms: {}, vertexShader: [THREE.ShaderChunk.common, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, \"void main() {\", THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, \"}\"].join(\"\\n\"), fragmentShader: [THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_fragment, \"vec4 pack_depth( const in float depth ) {\\n\\tconst vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\\n\\tconst vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\\n\\tvec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\\n\\tres -= res.xxyz * bit_mask;\\n\\treturn res;\\n}\\nvoid main() {\", THREE.ShaderChunk.logdepthbuf_fragment, \"\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tgl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );\\n\\t#else\\n\\t\\tgl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\\n\\t#endif\\n}\"].join(\"\\n\") } };\nTHREE.WebGLRenderer = function (a) {\n  function b(a) {\n    var b = a.geometry;a = a.material;var c = b.vertices.length;if (a.attributes) {\n      void 0 === b.__webglCustomAttributesList && (b.__webglCustomAttributesList = []);for (var d in a.attributes) {\n        var e = a.attributes[d];if (!e.__webglInitialized || e.createUniqueBuffers) {\n          e.__webglInitialized = !0;var f = 1;\"v2\" === e.type ? f = 2 : \"v3\" === e.type ? f = 3 : \"v4\" === e.type ? f = 4 : \"c\" === e.type && (f = 3);e.size = f;e.array = new Float32Array(c * f);e.buffer = m.createBuffer();e.buffer.belongsToAttribute = d;e.needsUpdate = !0;\n        }b.__webglCustomAttributesList.push(e);\n      }\n    }\n  }function c(a, b) {\n    return a.material instanceof THREE.MeshFaceMaterial ? a.material.materials[b.materialIndex] : a.material;\n  }function d(a, b, c, d) {\n    c = c.attributes;var e = b.attributes;b = b.attributesKeys;for (var f = 0, g = b.length; f < g; f++) {\n      var h = b[f],\n          k = e[h];if (0 <= k) {\n        var n = c[h];void 0 !== n ? (h = n.itemSize, m.bindBuffer(m.ARRAY_BUFFER, n.buffer), W.enableAttribute(k), m.vertexAttribPointer(k, h, m.FLOAT, !1, 0, d * h * 4)) : void 0 !== a.defaultAttributeValues && (2 === a.defaultAttributeValues[h].length ? m.vertexAttrib2fv(k, a.defaultAttributeValues[h]) : 3 === a.defaultAttributeValues[h].length && m.vertexAttrib3fv(k, a.defaultAttributeValues[h]));\n      }\n    }W.disableUnusedAttributes();\n  }function e(a, b) {\n    return a.object.renderOrder !== b.object.renderOrder ? a.object.renderOrder - b.object.renderOrder : a.material.id !== b.material.id ? a.material.id - b.material.id : a.z !== b.z ? a.z - b.z : a.id - b.id;\n  }function f(a, b) {\n    return a.object.renderOrder !== b.object.renderOrder ? a.object.renderOrder - b.object.renderOrder : a.z !== b.z ? b.z - a.z : a.id - b.id;\n  }function g(a, b) {\n    return b[0] - a[0];\n  }function h(a) {\n    if (!1 !== a.visible) {\n      if (!(a instanceof THREE.Scene || a instanceof THREE.Group)) {\n        void 0 === a.__webglInit && (a.__webglInit = !0, a._modelViewMatrix = new THREE.Matrix4(), a._normalMatrix = new THREE.Matrix3(), a.addEventListener(\"removed\", wb));var c = a.geometry;if (void 0 !== c && void 0 === c.__webglInit) if (c.__webglInit = !0, c.addEventListener(\"dispose\", jb), c instanceof THREE.BufferGeometry) B.info.memory.geometries++;else if (a instanceof THREE.Mesh) q(a, c);else if (a instanceof THREE.Line) {\n          if (void 0 === c.__webglVertexBuffer) {\n            c.__webglVertexBuffer = m.createBuffer();c.__webglColorBuffer = m.createBuffer();c.__webglLineDistanceBuffer = m.createBuffer();B.info.memory.geometries++;var d = c.vertices.length;c.__vertexArray = new Float32Array(3 * d);c.__colorArray = new Float32Array(3 * d);c.__lineDistanceArray = new Float32Array(1 * d);c.__webglLineCount = d;b(a);c.verticesNeedUpdate = !0;c.colorsNeedUpdate = !0;c.lineDistancesNeedUpdate = !0;\n          }\n        } else a instanceof THREE.PointCloud && void 0 === c.__webglVertexBuffer && (c.__webglVertexBuffer = m.createBuffer(), c.__webglColorBuffer = m.createBuffer(), B.info.memory.geometries++, d = c.vertices.length, c.__vertexArray = new Float32Array(3 * d), c.__colorArray = new Float32Array(3 * d), c.__webglParticleCount = d, b(a), c.verticesNeedUpdate = !0, c.colorsNeedUpdate = !0);if (void 0 === a.__webglActive) if (a.__webglActive = !0, a instanceof THREE.Mesh) {\n          if (c instanceof THREE.BufferGeometry) n(ba, c, a);else {\n            if (c instanceof THREE.Geometry) for (var c = Ua[c.id], d = 0, e = c.length; d < e; d++) {\n              n(ba, c[d], a);\n            }\n          }\n        } else a instanceof THREE.Line || a instanceof THREE.PointCloud ? n(ba, c, a) : (a instanceof THREE.ImmediateRenderObject || a.immediateRenderCallback) && qa.push({ id: null, object: a, opaque: null, transparent: null, z: 0 });if (a instanceof THREE.Light) ca.push(a);else if (a instanceof THREE.Sprite) Xa.push(a);else if (a instanceof THREE.LensFlare) Ya.push(a);else if ((c = ba[a.id]) && (!1 === a.frustumCulled || !0 === cb.intersectsObject(a))) for (d = 0, e = c.length; d < e; d++) {\n          var f = c[d],\n              g = f,\n              k = g.object,\n              l = g.buffer,\n              p = k.geometry,\n              k = k.material;k instanceof THREE.MeshFaceMaterial ? (k = k.materials[p instanceof THREE.BufferGeometry ? 0 : l.materialIndex], g.material = k, k.transparent ? Qa.push(g) : Ka.push(g)) : k && (g.material = k, k.transparent ? Qa.push(g) : Ka.push(g));f.render = !0;!0 === B.sortObjects && (wa.setFromMatrixPosition(a.matrixWorld), wa.applyProjection(db), f.z = wa.z);\n        }\n      }d = 0;for (e = a.children.length; d < e; d++) {\n        h(a.children[d]);\n      }\n    }\n  }function k(a, b, c, d, e) {\n    for (var f, g = 0, h = a.length; g < h; g++) {\n      f = a[g];var k = f.object,\n          m = f.buffer;w(k, b);if (e) f = e;else {\n        f = f.material;if (!f) continue;u(f);\n      }B.setMaterialFaces(f);m instanceof THREE.BufferGeometry ? B.renderBufferDirect(b, c, d, f, m, k) : B.renderBuffer(b, c, d, f, m, k);\n    }\n  }function l(a, b, c, d, e, f) {\n    for (var g, h = 0, k = a.length; h < k; h++) {\n      g = a[h];var m = g.object;if (m.visible) {\n        if (f) g = f;else {\n          g = g[b];if (!g) continue;u(g);\n        }B.renderImmediateObject(c, d, e, g, m);\n      }\n    }\n  }function p(a) {\n    var b = a.object.material;b.transparent ? (a.transparent = b, a.opaque = null) : (a.opaque = b, a.transparent = null);\n  }function q(a, b) {\n    var d = a.material,\n        e = !1;if (void 0 === Ua[b.id] || !0 === b.groupsNeedUpdate) {\n      delete ba[a.id];for (var f = Ua, g = b.id, d = d instanceof THREE.MeshFaceMaterial, h = da.get(\"OES_element_index_uint\") ? 4294967296 : 65535, k, e = {}, l = b.morphTargets.length, p = b.morphNormals.length, q, s = {}, t = [], r = 0, w = b.faces.length; r < w; r++) {\n        k = b.faces[r];var u = d ? k.materialIndex : 0;u in e || (e[u] = { hash: u, counter: 0 });k = e[u].hash + \"_\" + e[u].counter;k in s || (q = { id: Qb++, faces3: [], materialIndex: u, vertices: 0, numMorphTargets: l, numMorphNormals: p }, s[k] = q, t.push(q));s[k].vertices + 3 > h && (e[u].counter += 1, k = e[u].hash + \"_\" + e[u].counter, k in s || (q = { id: Qb++, faces3: [], materialIndex: u, vertices: 0, numMorphTargets: l,\n          numMorphNormals: p }, s[k] = q, t.push(q)));s[k].faces3.push(r);s[k].vertices += 3;\n      }f[g] = t;b.groupsNeedUpdate = !1;\n    }f = Ua[b.id];g = 0;for (d = f.length; g < d; g++) {\n      h = f[g];if (void 0 === h.__webglVertexBuffer) {\n        e = h;e.__webglVertexBuffer = m.createBuffer();e.__webglNormalBuffer = m.createBuffer();e.__webglTangentBuffer = m.createBuffer();e.__webglColorBuffer = m.createBuffer();e.__webglUVBuffer = m.createBuffer();e.__webglUV2Buffer = m.createBuffer();e.__webglSkinIndicesBuffer = m.createBuffer();e.__webglSkinWeightsBuffer = m.createBuffer();\n        e.__webglFaceBuffer = m.createBuffer();e.__webglLineBuffer = m.createBuffer();if (p = e.numMorphTargets) for (e.__webglMorphTargetsBuffers = [], l = 0; l < p; l++) {\n          e.__webglMorphTargetsBuffers.push(m.createBuffer());\n        }if (p = e.numMorphNormals) for (e.__webglMorphNormalsBuffers = [], l = 0; l < p; l++) {\n          e.__webglMorphNormalsBuffers.push(m.createBuffer());\n        }B.info.memory.geometries++;e = h;r = a;w = r.geometry;p = e.faces3;l = 3 * p.length;s = 1 * p.length;t = 3 * p.length;p = c(r, e);e.__vertexArray = new Float32Array(3 * l);e.__normalArray = new Float32Array(3 * l);\n        e.__colorArray = new Float32Array(3 * l);e.__uvArray = new Float32Array(2 * l);1 < w.faceVertexUvs.length && (e.__uv2Array = new Float32Array(2 * l));w.hasTangents && (e.__tangentArray = new Float32Array(4 * l));r.geometry.skinWeights.length && r.geometry.skinIndices.length && (e.__skinIndexArray = new Float32Array(4 * l), e.__skinWeightArray = new Float32Array(4 * l));r = null !== da.get(\"OES_element_index_uint\") && 21845 < s ? Uint32Array : Uint16Array;e.__typeArray = r;e.__faceArray = new r(3 * s);e.__lineArray = new r(2 * t);if (w = e.numMorphTargets) for (e.__morphTargetsArrays = [], r = 0; r < w; r++) {\n          e.__morphTargetsArrays.push(new Float32Array(3 * l));\n        }if (w = e.numMorphNormals) for (e.__morphNormalsArrays = [], r = 0; r < w; r++) {\n          e.__morphNormalsArrays.push(new Float32Array(3 * l));\n        }e.__webglFaceCount = 3 * s;e.__webglLineCount = 2 * t;if (p.attributes) for (s in void 0 === e.__webglCustomAttributesList && (e.__webglCustomAttributesList = []), s = void 0, p.attributes) {\n          var t = p.attributes[s],\n              r = {},\n              v;for (v in t) {\n            r[v] = t[v];\n          }if (!r.__webglInitialized || r.createUniqueBuffers) r.__webglInitialized = !0, w = 1, \"v2\" === r.type ? w = 2 : \"v3\" === r.type ? w = 3 : \"v4\" === r.type ? w = 4 : \"c\" === r.type && (w = 3), r.size = w, r.array = new Float32Array(l * w), r.buffer = m.createBuffer(), r.buffer.belongsToAttribute = s, t.needsUpdate = !0, r.__original = t;e.__webglCustomAttributesList.push(r);\n        }e.__inittedArrays = !0;b.verticesNeedUpdate = !0;b.morphTargetsNeedUpdate = !0;b.elementsNeedUpdate = !0;b.uvsNeedUpdate = !0;b.normalsNeedUpdate = !0;b.tangentsNeedUpdate = !0;e = b.colorsNeedUpdate = !0;\n      } else e = !1;(e || void 0 === a.__webglActive) && n(ba, h, a);\n    }a.__webglActive = !0;\n  }function n(a, b, c) {\n    var d = c.id;a[d] = a[d] || [];a[d].push({ id: d, buffer: b, object: c, material: null, z: 0 });\n  }function t(a) {\n    var b = a.geometry;if (b instanceof THREE.BufferGeometry) for (var d = b.attributes, e = b.attributesKeys, f = 0, g = e.length; f < g; f++) {\n      var h = e[f],\n          k = d[h],\n          n = \"index\" === h ? m.ELEMENT_ARRAY_BUFFER : m.ARRAY_BUFFER;void 0 === k.buffer ? (k.buffer = m.createBuffer(), m.bindBuffer(n, k.buffer), m.bufferData(n, k.array, k instanceof THREE.DynamicBufferAttribute ? m.DYNAMIC_DRAW : m.STATIC_DRAW), k.needsUpdate = !1) : !0 === k.needsUpdate && (m.bindBuffer(n, k.buffer), void 0 === k.updateRange || -1 === k.updateRange.count ? m.bufferSubData(n, 0, k.array) : 0 === k.updateRange.count ? console.error(\"THREE.WebGLRenderer.updateObject: using updateRange for THREE.DynamicBufferAttribute and marked as needsUpdate but count is 0, ensure you are using set methods or updating manually.\") : (m.bufferSubData(n, k.updateRange.offset * k.array.BYTES_PER_ELEMENT, k.array.subarray(k.updateRange.offset, k.updateRange.offset + k.updateRange.count)), k.updateRange.count = 0), k.needsUpdate = !1);\n    } else if (a instanceof THREE.Mesh) {\n      !0 === b.groupsNeedUpdate && q(a, b);for (var l = Ua[b.id], f = 0, p = l.length; f < p; f++) {\n        var t = l[f],\n            w = c(a, t),\n            u = w.attributes && r(w);if (b.verticesNeedUpdate || b.morphTargetsNeedUpdate || b.elementsNeedUpdate || b.uvsNeedUpdate || b.normalsNeedUpdate || b.colorsNeedUpdate || b.tangentsNeedUpdate || u) {\n          var v = t,\n              x = a,\n              D = m.DYNAMIC_DRAW,\n              A = !b.dynamic,\n              E = w;if (v.__inittedArrays) {\n            var G = !1 === E instanceof THREE.MeshPhongMaterial && E.shading === THREE.FlatShading,\n                y = void 0,\n                z = void 0,\n                F = void 0,\n                B = void 0,\n                I = void 0,\n                H = void 0,\n                M = void 0,\n                R = void 0,\n                P = void 0,\n                U = void 0,\n                O = void 0,\n                J = void 0,\n                L = void 0,\n                N = void 0,\n                Ka = void 0,\n                V = void 0,\n                W = void 0,\n                Qa = void 0,\n                Ya = void 0,\n                Xa = void 0,\n                da = void 0,\n                ba = void 0,\n                ja = void 0,\n                Pa = void 0,\n                ka = void 0,\n                Q = void 0,\n                ha = void 0,\n                ia = void 0,\n                ob = void 0,\n                Y = void 0,\n                ub = void 0,\n                pa = void 0,\n                ab = void 0,\n                oa = void 0,\n                ca = void 0,\n                qa = void 0,\n                Ca = void 0,\n                ta = void 0,\n                na = void 0,\n                wa = void 0,\n                La = 0,\n                Ma = 0,\n                kb = 0,\n                yb = 0,\n                zb = 0,\n                Ra = 0,\n                Aa = 0,\n                eb = 0,\n                Ha = 0,\n                la = 0,\n                ra = 0,\n                K = 0,\n                za = void 0,\n                Sa = v.__vertexArray,\n                Ab = v.__uvArray,\n                lb = v.__uv2Array,\n                Na = v.__normalArray,\n                sa = v.__tangentArray,\n                Da = v.__colorArray,\n                Ea = v.__skinIndexArray,\n                Fa = v.__skinWeightArray,\n                Gb = v.__morphTargetsArrays,\n                Bb = v.__morphNormalsArrays,\n                mb = v.__webglCustomAttributesList,\n                C = void 0,\n                Va = v.__faceArray,\n                Ta = v.__lineArray,\n                ea = x.geometry,\n                fb = ea.elementsNeedUpdate,\n                vb = ea.uvsNeedUpdate,\n                Mb = ea.normalsNeedUpdate,\n                Ob = ea.tangentsNeedUpdate,\n                ib = ea.colorsNeedUpdate,\n                sb = ea.morphTargetsNeedUpdate,\n                Cb = ea.vertices,\n                $ = v.faces3,\n                xa = ea.faces,\n                Hb = ea.faceVertexUvs[0],\n                Oa = ea.faceVertexUvs[1],\n                $a = ea.skinIndices,\n                Ga = ea.skinWeights,\n                nb = ea.morphTargets,\n                bb = ea.morphNormals;if (ea.verticesNeedUpdate) {\n              y = 0;for (z = $.length; y < z; y++) {\n                B = xa[$[y]], J = Cb[B.a], L = Cb[B.b], N = Cb[B.c], Sa[Ma] = J.x, Sa[Ma + 1] = J.y, Sa[Ma + 2] = J.z, Sa[Ma + 3] = L.x, Sa[Ma + 4] = L.y, Sa[Ma + 5] = L.z, Sa[Ma + 6] = N.x, Sa[Ma + 7] = N.y, Sa[Ma + 8] = N.z, Ma += 9;\n              }m.bindBuffer(m.ARRAY_BUFFER, v.__webglVertexBuffer);m.bufferData(m.ARRAY_BUFFER, Sa, D);\n            }if (sb) for (ca = 0, qa = nb.length; ca < qa; ca++) {\n              y = ra = 0;for (z = $.length; y < z; y++) {\n                na = $[y], B = xa[na], J = nb[ca].vertices[B.a], L = nb[ca].vertices[B.b], N = nb[ca].vertices[B.c], Ca = Gb[ca], Ca[ra] = J.x, Ca[ra + 1] = J.y, Ca[ra + 2] = J.z, Ca[ra + 3] = L.x, Ca[ra + 4] = L.y, Ca[ra + 5] = L.z, Ca[ra + 6] = N.x, Ca[ra + 7] = N.y, Ca[ra + 8] = N.z, E.morphNormals && (G ? Xa = Ya = Qa = bb[ca].faceNormals[na] : (wa = bb[ca].vertexNormals[na], Qa = wa.a, Ya = wa.b, Xa = wa.c), ta = Bb[ca], ta[ra] = Qa.x, ta[ra + 1] = Qa.y, ta[ra + 2] = Qa.z, ta[ra + 3] = Ya.x, ta[ra + 4] = Ya.y, ta[ra + 5] = Ya.z, ta[ra + 6] = Xa.x, ta[ra + 7] = Xa.y, ta[ra + 8] = Xa.z), ra += 9;\n              }m.bindBuffer(m.ARRAY_BUFFER, v.__webglMorphTargetsBuffers[ca]);m.bufferData(m.ARRAY_BUFFER, Gb[ca], D);E.morphNormals && (m.bindBuffer(m.ARRAY_BUFFER, v.__webglMorphNormalsBuffers[ca]), m.bufferData(m.ARRAY_BUFFER, Bb[ca], D));\n            }if (Ga.length) {\n              y = 0;\n              for (z = $.length; y < z; y++) {\n                B = xa[$[y]], Pa = Ga[B.a], ka = Ga[B.b], Q = Ga[B.c], Fa[la] = Pa.x, Fa[la + 1] = Pa.y, Fa[la + 2] = Pa.z, Fa[la + 3] = Pa.w, Fa[la + 4] = ka.x, Fa[la + 5] = ka.y, Fa[la + 6] = ka.z, Fa[la + 7] = ka.w, Fa[la + 8] = Q.x, Fa[la + 9] = Q.y, Fa[la + 10] = Q.z, Fa[la + 11] = Q.w, ha = $a[B.a], ia = $a[B.b], ob = $a[B.c], Ea[la] = ha.x, Ea[la + 1] = ha.y, Ea[la + 2] = ha.z, Ea[la + 3] = ha.w, Ea[la + 4] = ia.x, Ea[la + 5] = ia.y, Ea[la + 6] = ia.z, Ea[la + 7] = ia.w, Ea[la + 8] = ob.x, Ea[la + 9] = ob.y, Ea[la + 10] = ob.z, Ea[la + 11] = ob.w, la += 12;\n              }0 < la && (m.bindBuffer(m.ARRAY_BUFFER, v.__webglSkinIndicesBuffer), m.bufferData(m.ARRAY_BUFFER, Ea, D), m.bindBuffer(m.ARRAY_BUFFER, v.__webglSkinWeightsBuffer), m.bufferData(m.ARRAY_BUFFER, Fa, D));\n            }if (ib) {\n              y = 0;for (z = $.length; y < z; y++) {\n                B = xa[$[y]], M = B.vertexColors, R = B.color, 3 === M.length && E.vertexColors === THREE.VertexColors ? (da = M[0], ba = M[1], ja = M[2]) : ja = ba = da = R, Da[Ha] = da.r, Da[Ha + 1] = da.g, Da[Ha + 2] = da.b, Da[Ha + 3] = ba.r, Da[Ha + 4] = ba.g, Da[Ha + 5] = ba.b, Da[Ha + 6] = ja.r, Da[Ha + 7] = ja.g, Da[Ha + 8] = ja.b, Ha += 9;\n              }0 < Ha && (m.bindBuffer(m.ARRAY_BUFFER, v.__webglColorBuffer), m.bufferData(m.ARRAY_BUFFER, Da, D));\n            }if (Ob && ea.hasTangents) {\n              y = 0;for (z = $.length; y < z; y++) {\n                B = xa[$[y]], P = B.vertexTangents, Ka = P[0], V = P[1], W = P[2], sa[Aa] = Ka.x, sa[Aa + 1] = Ka.y, sa[Aa + 2] = Ka.z, sa[Aa + 3] = Ka.w, sa[Aa + 4] = V.x, sa[Aa + 5] = V.y, sa[Aa + 6] = V.z, sa[Aa + 7] = V.w, sa[Aa + 8] = W.x, sa[Aa + 9] = W.y, sa[Aa + 10] = W.z, sa[Aa + 11] = W.w, Aa += 12;\n              }m.bindBuffer(m.ARRAY_BUFFER, v.__webglTangentBuffer);m.bufferData(m.ARRAY_BUFFER, sa, D);\n            }if (Mb) {\n              y = 0;for (z = $.length; y < z; y++) {\n                if (B = xa[$[y]], I = B.vertexNormals, H = B.normal, 3 === I.length && !1 === G) for (Y = 0; 3 > Y; Y++) {\n                  pa = I[Y], Na[Ra] = pa.x, Na[Ra + 1] = pa.y, Na[Ra + 2] = pa.z, Ra += 3;\n                } else for (Y = 0; 3 > Y; Y++) {\n                  Na[Ra] = H.x, Na[Ra + 1] = H.y, Na[Ra + 2] = H.z, Ra += 3;\n                }\n              }m.bindBuffer(m.ARRAY_BUFFER, v.__webglNormalBuffer);m.bufferData(m.ARRAY_BUFFER, Na, D);\n            }if (vb && Hb) {\n              y = 0;for (z = $.length; y < z; y++) {\n                if (F = $[y], U = Hb[F], void 0 !== U) for (Y = 0; 3 > Y; Y++) {\n                  ab = U[Y], Ab[kb] = ab.x, Ab[kb + 1] = ab.y, kb += 2;\n                }\n              }0 < kb && (m.bindBuffer(m.ARRAY_BUFFER, v.__webglUVBuffer), m.bufferData(m.ARRAY_BUFFER, Ab, D));\n            }if (vb && Oa) {\n              y = 0;for (z = $.length; y < z; y++) {\n                if (F = $[y], O = Oa[F], void 0 !== O) for (Y = 0; 3 > Y; Y++) {\n                  oa = O[Y], lb[yb] = oa.x, lb[yb + 1] = oa.y, yb += 2;\n                }\n              }0 < yb && (m.bindBuffer(m.ARRAY_BUFFER, v.__webglUV2Buffer), m.bufferData(m.ARRAY_BUFFER, lb, D));\n            }if (fb) {\n              y = 0;for (z = $.length; y < z; y++) {\n                Va[zb] = La, Va[zb + 1] = La + 1, Va[zb + 2] = La + 2, zb += 3, Ta[eb] = La, Ta[eb + 1] = La + 1, Ta[eb + 2] = La, Ta[eb + 3] = La + 2, Ta[eb + 4] = La + 1, Ta[eb + 5] = La + 2, eb += 6, La += 3;\n              }m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, v.__webglFaceBuffer);m.bufferData(m.ELEMENT_ARRAY_BUFFER, Va, D);m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, v.__webglLineBuffer);m.bufferData(m.ELEMENT_ARRAY_BUFFER, Ta, D);\n            }if (mb) for (Y = 0, ub = mb.length; Y < ub; Y++) {\n              if (C = mb[Y], C.__original.needsUpdate) {\n                K = 0;if (1 === C.size) {\n                  if (void 0 === C.boundTo || \"vertices\" === C.boundTo) for (y = 0, z = $.length; y < z; y++) {\n                    B = xa[$[y]], C.array[K] = C.value[B.a], C.array[K + 1] = C.value[B.b], C.array[K + 2] = C.value[B.c], K += 3;\n                  } else {\n                    if (\"faces\" === C.boundTo) for (y = 0, z = $.length; y < z; y++) {\n                      za = C.value[$[y]], C.array[K] = za, C.array[K + 1] = za, C.array[K + 2] = za, K += 3;\n                    }\n                  }\n                } else if (2 === C.size) {\n                  if (void 0 === C.boundTo || \"vertices\" === C.boundTo) for (y = 0, z = $.length; y < z; y++) {\n                    B = xa[$[y]], J = C.value[B.a], L = C.value[B.b], N = C.value[B.c], C.array[K] = J.x, C.array[K + 1] = J.y, C.array[K + 2] = L.x, C.array[K + 3] = L.y, C.array[K + 4] = N.x, C.array[K + 5] = N.y, K += 6;\n                  } else {\n                    if (\"faces\" === C.boundTo) for (y = 0, z = $.length; y < z; y++) {\n                      N = L = J = za = C.value[$[y]], C.array[K] = J.x, C.array[K + 1] = J.y, C.array[K + 2] = L.x, C.array[K + 3] = L.y, C.array[K + 4] = N.x, C.array[K + 5] = N.y, K += 6;\n                    }\n                  }\n                } else if (3 === C.size) {\n                  var T;T = \"c\" === C.type ? [\"r\", \"g\", \"b\"] : [\"x\", \"y\", \"z\"];if (void 0 === C.boundTo || \"vertices\" === C.boundTo) for (y = 0, z = $.length; y < z; y++) {\n                    B = xa[$[y]], J = C.value[B.a], L = C.value[B.b], N = C.value[B.c], C.array[K] = J[T[0]], C.array[K + 1] = J[T[1]], C.array[K + 2] = J[T[2]], C.array[K + 3] = L[T[0]], C.array[K + 4] = L[T[1]], C.array[K + 5] = L[T[2]], C.array[K + 6] = N[T[0]], C.array[K + 7] = N[T[1]], C.array[K + 8] = N[T[2]], K += 9;\n                  } else if (\"faces\" === C.boundTo) for (y = 0, z = $.length; y < z; y++) {\n                    N = L = J = za = C.value[$[y]], C.array[K] = J[T[0]], C.array[K + 1] = J[T[1]], C.array[K + 2] = J[T[2]], C.array[K + 3] = L[T[0]], C.array[K + 4] = L[T[1]], C.array[K + 5] = L[T[2]], C.array[K + 6] = N[T[0]], C.array[K + 7] = N[T[1]], C.array[K + 8] = N[T[2]], K += 9;\n                  } else if (\"faceVertices\" === C.boundTo) for (y = 0, z = $.length; y < z; y++) {\n                    za = C.value[$[y]], J = za[0], L = za[1], N = za[2], C.array[K] = J[T[0]], C.array[K + 1] = J[T[1]], C.array[K + 2] = J[T[2]], C.array[K + 3] = L[T[0]], C.array[K + 4] = L[T[1]], C.array[K + 5] = L[T[2]], C.array[K + 6] = N[T[0]], C.array[K + 7] = N[T[1]], C.array[K + 8] = N[T[2]], K += 9;\n                  }\n                } else if (4 === C.size) if (void 0 === C.boundTo || \"vertices\" === C.boundTo) for (y = 0, z = $.length; y < z; y++) {\n                  B = xa[$[y]], J = C.value[B.a], L = C.value[B.b], N = C.value[B.c], C.array[K] = J.x, C.array[K + 1] = J.y, C.array[K + 2] = J.z, C.array[K + 3] = J.w, C.array[K + 4] = L.x, C.array[K + 5] = L.y, C.array[K + 6] = L.z, C.array[K + 7] = L.w, C.array[K + 8] = N.x, C.array[K + 9] = N.y, C.array[K + 10] = N.z, C.array[K + 11] = N.w, K += 12;\n                } else if (\"faces\" === C.boundTo) for (y = 0, z = $.length; y < z; y++) {\n                  N = L = J = za = C.value[$[y]], C.array[K] = J.x, C.array[K + 1] = J.y, C.array[K + 2] = J.z, C.array[K + 3] = J.w, C.array[K + 4] = L.x, C.array[K + 5] = L.y, C.array[K + 6] = L.z, C.array[K + 7] = L.w, C.array[K + 8] = N.x, C.array[K + 9] = N.y, C.array[K + 10] = N.z, C.array[K + 11] = N.w, K += 12;\n                } else if (\"faceVertices\" === C.boundTo) for (y = 0, z = $.length; y < z; y++) {\n                  za = C.value[$[y]], J = za[0], L = za[1], N = za[2], C.array[K] = J.x, C.array[K + 1] = J.y, C.array[K + 2] = J.z, C.array[K + 3] = J.w, C.array[K + 4] = L.x, C.array[K + 5] = L.y, C.array[K + 6] = L.z, C.array[K + 7] = L.w, C.array[K + 8] = N.x, C.array[K + 9] = N.y, C.array[K + 10] = N.z, C.array[K + 11] = N.w, K += 12;\n                }m.bindBuffer(m.ARRAY_BUFFER, C.buffer);m.bufferData(m.ARRAY_BUFFER, C.array, D);\n              }\n            }A && (delete v.__inittedArrays, delete v.__colorArray, delete v.__normalArray, delete v.__tangentArray, delete v.__uvArray, delete v.__uv2Array, delete v.__faceArray, delete v.__vertexArray, delete v.__lineArray, delete v.__skinIndexArray, delete v.__skinWeightArray);\n          }\n        }\n      }b.verticesNeedUpdate = !1;b.morphTargetsNeedUpdate = !1;b.elementsNeedUpdate = !1;b.uvsNeedUpdate = !1;b.normalsNeedUpdate = !1;b.colorsNeedUpdate = !1;b.tangentsNeedUpdate = !1;w.attributes && s(w);\n    } else if (a instanceof THREE.Line) {\n      w = c(a, b);u = w.attributes && r(w);if (b.verticesNeedUpdate || b.colorsNeedUpdate || b.lineDistancesNeedUpdate || u) {\n        var Db = m.DYNAMIC_DRAW,\n            S,\n            aa,\n            Z,\n            Ba,\n            X,\n            Eb,\n            Rb = b.vertices,\n            Ib = b.colors,\n            gb = b.lineDistances,\n            ya = Rb.length,\n            pb = Ib.length,\n            qb = gb.length,\n            Wa = b.__vertexArray,\n            tb = b.__colorArray,\n            hb = b.__lineDistanceArray,\n            $b = b.colorsNeedUpdate,\n            Fb = b.lineDistancesNeedUpdate,\n            Sb = b.__webglCustomAttributesList,\n            Jb,\n            cb,\n            ua,\n            Kb,\n            Ia,\n            fa;if (b.verticesNeedUpdate) {\n          for (S = 0; S < ya; S++) {\n            Ba = Rb[S], X = 3 * S, Wa[X] = Ba.x, Wa[X + 1] = Ba.y, Wa[X + 2] = Ba.z;\n          }m.bindBuffer(m.ARRAY_BUFFER, b.__webglVertexBuffer);m.bufferData(m.ARRAY_BUFFER, Wa, Db);\n        }if ($b) {\n          for (aa = 0; aa < pb; aa++) {\n            Eb = Ib[aa], X = 3 * aa, tb[X] = Eb.r, tb[X + 1] = Eb.g, tb[X + 2] = Eb.b;\n          }m.bindBuffer(m.ARRAY_BUFFER, b.__webglColorBuffer);m.bufferData(m.ARRAY_BUFFER, tb, Db);\n        }if (Fb) {\n          for (Z = 0; Z < qb; Z++) {\n            hb[Z] = gb[Z];\n          }m.bindBuffer(m.ARRAY_BUFFER, b.__webglLineDistanceBuffer);\n          m.bufferData(m.ARRAY_BUFFER, hb, Db);\n        }if (Sb) for (Jb = 0, cb = Sb.length; Jb < cb; Jb++) {\n          if (fa = Sb[Jb], fa.needsUpdate && (void 0 === fa.boundTo || \"vertices\" === fa.boundTo)) {\n            X = 0;Kb = fa.value.length;if (1 === fa.size) for (ua = 0; ua < Kb; ua++) {\n              fa.array[ua] = fa.value[ua];\n            } else if (2 === fa.size) for (ua = 0; ua < Kb; ua++) {\n              Ia = fa.value[ua], fa.array[X] = Ia.x, fa.array[X + 1] = Ia.y, X += 2;\n            } else if (3 === fa.size) {\n              if (\"c\" === fa.type) for (ua = 0; ua < Kb; ua++) {\n                Ia = fa.value[ua], fa.array[X] = Ia.r, fa.array[X + 1] = Ia.g, fa.array[X + 2] = Ia.b, X += 3;\n              } else for (ua = 0; ua < Kb; ua++) {\n                Ia = fa.value[ua], fa.array[X] = Ia.x, fa.array[X + 1] = Ia.y, fa.array[X + 2] = Ia.z, X += 3;\n              }\n            } else if (4 === fa.size) for (ua = 0; ua < Kb; ua++) {\n              Ia = fa.value[ua], fa.array[X] = Ia.x, fa.array[X + 1] = Ia.y, fa.array[X + 2] = Ia.z, fa.array[X + 3] = Ia.w, X += 4;\n            }m.bindBuffer(m.ARRAY_BUFFER, fa.buffer);m.bufferData(m.ARRAY_BUFFER, fa.array, Db);fa.needsUpdate = !1;\n          }\n        }\n      }b.verticesNeedUpdate = !1;b.colorsNeedUpdate = !1;b.lineDistancesNeedUpdate = !1;w.attributes && s(w);\n    } else if (a instanceof THREE.PointCloud) {\n      w = c(a, b);u = w.attributes && r(w);if (b.verticesNeedUpdate || b.colorsNeedUpdate || u) {\n        var db = m.DYNAMIC_DRAW,\n            Tb,\n            Ub,\n            ac,\n            ma,\n            bc,\n            Nb = b.vertices,\n            Vb = Nb.length,\n            Pb = b.colors,\n            rb = Pb.length,\n            cc = b.__vertexArray,\n            dc = b.__colorArray,\n            wb = b.colorsNeedUpdate,\n            gc = b.__webglCustomAttributesList,\n            ec,\n            jb,\n            va,\n            Lb,\n            Ja,\n            ga;if (b.verticesNeedUpdate) {\n          for (Tb = 0; Tb < Vb; Tb++) {\n            ac = Nb[Tb], ma = 3 * Tb, cc[ma] = ac.x, cc[ma + 1] = ac.y, cc[ma + 2] = ac.z;\n          }m.bindBuffer(m.ARRAY_BUFFER, b.__webglVertexBuffer);m.bufferData(m.ARRAY_BUFFER, cc, db);\n        }if (wb) {\n          for (Ub = 0; Ub < rb; Ub++) {\n            bc = Pb[Ub], ma = 3 * Ub, dc[ma] = bc.r, dc[ma + 1] = bc.g, dc[ma + 2] = bc.b;\n          }m.bindBuffer(m.ARRAY_BUFFER, b.__webglColorBuffer);m.bufferData(m.ARRAY_BUFFER, dc, db);\n        }if (gc) for (ec = 0, jb = gc.length; ec < jb; ec++) {\n          ga = gc[ec];if (ga.needsUpdate && (void 0 === ga.boundTo || \"vertices\" === ga.boundTo)) if (Lb = ga.value.length, ma = 0, 1 === ga.size) for (va = 0; va < Lb; va++) {\n            ga.array[va] = ga.value[va];\n          } else if (2 === ga.size) for (va = 0; va < Lb; va++) {\n            Ja = ga.value[va], ga.array[ma] = Ja.x, ga.array[ma + 1] = Ja.y, ma += 2;\n          } else if (3 === ga.size) {\n            if (\"c\" === ga.type) for (va = 0; va < Lb; va++) {\n              Ja = ga.value[va], ga.array[ma] = Ja.r, ga.array[ma + 1] = Ja.g, ga.array[ma + 2] = Ja.b, ma += 3;\n            } else for (va = 0; va < Lb; va++) {\n              Ja = ga.value[va], ga.array[ma] = Ja.x, ga.array[ma + 1] = Ja.y, ga.array[ma + 2] = Ja.z, ma += 3;\n            }\n          } else if (4 === ga.size) for (va = 0; va < Lb; va++) {\n            Ja = ga.value[va], ga.array[ma] = Ja.x, ga.array[ma + 1] = Ja.y, ga.array[ma + 2] = Ja.z, ga.array[ma + 3] = Ja.w, ma += 4;\n          }m.bindBuffer(m.ARRAY_BUFFER, ga.buffer);m.bufferData(m.ARRAY_BUFFER, ga.array, db);ga.needsUpdate = !1;\n        }\n      }b.verticesNeedUpdate = !1;b.colorsNeedUpdate = !1;w.attributes && s(w);\n    }\n  }function r(a) {\n    for (var b in a.attributes) {\n      if (a.attributes[b].needsUpdate) return !0;\n    }return !1;\n  }function s(a) {\n    for (var b in a.attributes) {\n      a.attributes[b].needsUpdate = !1;\n    }\n  }function u(a) {\n    !0 === a.transparent ? W.setBlending(a.blending, a.blendEquation, a.blendSrc, a.blendDst, a.blendEquationAlpha, a.blendSrcAlpha, a.blendDstAlpha) : W.setBlending(THREE.NoBlending);W.setDepthTest(a.depthTest);W.setDepthWrite(a.depthWrite);W.setColorWrite(a.colorWrite);W.setPolygonOffset(a.polygonOffset, a.polygonOffsetFactor, a.polygonOffsetUnits);\n  }function v(a, b, c, d, e) {\n    var f, g, h, k;Mb = 0;if (d.needsUpdate) {\n      d.program && hc(d);d.addEventListener(\"dispose\", ic);var n = pc[d.type];if (n) {\n        var l = THREE.ShaderLib[n];\n        d.__webglShader = { uniforms: THREE.UniformsUtils.clone(l.uniforms), vertexShader: l.vertexShader, fragmentShader: l.fragmentShader };\n      } else d.__webglShader = { uniforms: d.uniforms, vertexShader: d.vertexShader, fragmentShader: d.fragmentShader };for (var p = 0, q = 0, r = 0, s = 0, t = 0, w = b.length; t < w; t++) {\n        var v = b[t];v.onlyShadow || !1 === v.visible || (v instanceof THREE.DirectionalLight && p++, v instanceof THREE.PointLight && q++, v instanceof THREE.SpotLight && r++, v instanceof THREE.HemisphereLight && s++);\n      }f = p;g = q;h = r;k = s;for (var u, z = 0, G = 0, F = b.length; G < F; G++) {\n        var J = b[G];J.castShadow && (J instanceof THREE.SpotLight && z++, J instanceof THREE.DirectionalLight && !J.shadowCascade && z++);\n      }u = z;var H;if (Nb && e && e.skeleton && e.skeleton.useVertexTexture) H = 1024;else {\n        var N = m.getParameter(m.MAX_VERTEX_UNIFORM_VECTORS),\n            M = Math.floor((N - 20) / 4);void 0 !== e && e instanceof THREE.SkinnedMesh && (M = Math.min(e.skeleton.bones.length, M), M < e.skeleton.bones.length && THREE.warn(\"WebGLRenderer: too many bones - \" + e.skeleton.bones.length + \", this GPU supports just \" + M + \" (try OpenGL instead of ANGLE)\"));\n        H = M;\n      }var P = { precision: L, supportsVertexTextures: Vb, map: !!d.map, envMap: !!d.envMap, envMapMode: d.envMap && d.envMap.mapping, lightMap: !!d.lightMap, bumpMap: !!d.bumpMap, normalMap: !!d.normalMap, specularMap: !!d.specularMap, alphaMap: !!d.alphaMap, combine: d.combine, vertexColors: d.vertexColors, fog: c, useFog: d.fog, fogExp: c instanceof THREE.FogExp2, flatShading: d.shading === THREE.FlatShading, sizeAttenuation: d.sizeAttenuation, logarithmicDepthBuffer: ja, skinning: d.skinning, maxBones: H, useVertexTexture: Nb && e && e.skeleton && e.skeleton.useVertexTexture, morphTargets: d.morphTargets, morphNormals: d.morphNormals, maxMorphTargets: B.maxMorphTargets, maxMorphNormals: B.maxMorphNormals, maxDirLights: f, maxPointLights: g, maxSpotLights: h, maxHemiLights: k, maxShadows: u, shadowMapEnabled: B.shadowMapEnabled && e.receiveShadow && 0 < u, shadowMapType: B.shadowMapType, shadowMapDebug: B.shadowMapDebug, shadowMapCascade: B.shadowMapCascade, alphaTest: d.alphaTest, metal: d.metal, wrapAround: d.wrapAround, doubleSided: d.side === THREE.DoubleSide, flipSided: d.side === THREE.BackSide },\n          R = [];n ? R.push(n) : (R.push(d.fragmentShader), R.push(d.vertexShader));if (void 0 !== d.defines) for (var O in d.defines) {\n        R.push(O), R.push(d.defines[O]);\n      }for (O in P) {\n        R.push(O), R.push(P[O]);\n      }for (var Ka = R.join(), V, W = 0, Qa = Pa.length; W < Qa; W++) {\n        var Ya = Pa[W];if (Ya.code === Ka) {\n          V = Ya;V.usedTimes++;break;\n        }\n      }void 0 === V && (V = new THREE.WebGLProgram(B, Ka, d, P), Pa.push(V), B.info.memory.programs = Pa.length);d.program = V;var Xa = V.attributes;if (d.morphTargets) {\n        d.numSupportedMorphTargets = 0;for (var ca, da = \"morphTarget\", ba = 0; ba < B.maxMorphTargets; ba++) {\n          ca = da + ba, 0 <= Xa[ca] && d.numSupportedMorphTargets++;\n        }\n      }if (d.morphNormals) for (d.numSupportedMorphNormals = 0, da = \"morphNormal\", ba = 0; ba < B.maxMorphNormals; ba++) {\n        ca = da + ba, 0 <= Xa[ca] && d.numSupportedMorphNormals++;\n      }d.uniformsList = [];for (var ha in d.__webglShader.uniforms) {\n        var ta = d.program.uniforms[ha];ta && d.uniformsList.push([d.__webglShader.uniforms[ha], ta]);\n      }d.needsUpdate = !1;\n    }d.morphTargets && !e.__webglMorphTargetInfluences && (e.__webglMorphTargetInfluences = new Float32Array(B.maxMorphTargets));\n    var ab = !1,\n        oa = !1,\n        qa = !1,\n        Ua = d.program,\n        ka = Ua.uniforms,\n        Q = d.__webglShader.uniforms;Ua.id !== ob && (m.useProgram(Ua.program), ob = Ua.id, qa = oa = ab = !0);d.id !== ub && (-1 === ub && (qa = !0), ub = d.id, oa = !0);if (ab || a !== vb) m.uniformMatrix4fv(ka.projectionMatrix, !1, a.projectionMatrix.elements), ja && m.uniform1f(ka.logDepthBufFC, 2 / (Math.log(a.far + 1) / Math.LN2)), a !== vb && (vb = a), (d instanceof THREE.ShaderMaterial || d instanceof THREE.MeshPhongMaterial || d.envMap) && null !== ka.cameraPosition && (wa.setFromMatrixPosition(a.matrixWorld), m.uniform3f(ka.cameraPosition, wa.x, wa.y, wa.z)), (d instanceof THREE.MeshPhongMaterial || d instanceof THREE.MeshLambertMaterial || d instanceof THREE.MeshBasicMaterial || d instanceof THREE.ShaderMaterial || d.skinning) && null !== ka.viewMatrix && m.uniformMatrix4fv(ka.viewMatrix, !1, a.matrixWorldInverse.elements);if (d.skinning) if (e.bindMatrix && null !== ka.bindMatrix && m.uniformMatrix4fv(ka.bindMatrix, !1, e.bindMatrix.elements), e.bindMatrixInverse && null !== ka.bindMatrixInverse && m.uniformMatrix4fv(ka.bindMatrixInverse, !1, e.bindMatrixInverse.elements), Nb && e.skeleton && e.skeleton.useVertexTexture) {\n      if (null !== ka.boneTexture) {\n        var db = D();m.uniform1i(ka.boneTexture, db);B.setTexture(e.skeleton.boneTexture, db);\n      }null !== ka.boneTextureWidth && m.uniform1i(ka.boneTextureWidth, e.skeleton.boneTextureWidth);null !== ka.boneTextureHeight && m.uniform1i(ka.boneTextureHeight, e.skeleton.boneTextureHeight);\n    } else e.skeleton && e.skeleton.boneMatrices && null !== ka.boneGlobalMatrices && m.uniformMatrix4fv(ka.boneGlobalMatrices, !1, e.skeleton.boneMatrices);if (oa) {\n      c && d.fog && (Q.fogColor.value = c.color, c instanceof THREE.Fog ? (Q.fogNear.value = c.near, Q.fogFar.value = c.far) : c instanceof THREE.FogExp2 && (Q.fogDensity.value = c.density));if (d instanceof THREE.MeshPhongMaterial || d instanceof THREE.MeshLambertMaterial || d.lights) {\n        if (Ob) {\n          var qa = !0,\n              ia,\n              Za,\n              Y,\n              bb = 0,\n              cb = 0,\n              ib = 0,\n              xb,\n              pb,\n              qb,\n              Ca,\n              jb,\n              na = jc,\n              rb = na.directional.colors,\n              La = na.directional.positions,\n              Ma = na.point.colors,\n              kb = na.point.positions,\n              yb = na.point.distances,\n              zb = na.point.decays,\n              Ra = na.spot.colors,\n              Aa = na.spot.positions,\n              eb = na.spot.distances,\n              Ha = na.spot.directions,\n              la = na.spot.anglesCos,\n              ra = na.spot.exponents,\n              K = na.spot.decays,\n              za = na.hemi.skyColors,\n              Sa = na.hemi.groundColors,\n              Ab = na.hemi.positions,\n              lb = 0,\n              Na = 0,\n              sa = 0,\n              Da = 0,\n              Ea = 0,\n              Fa = 0,\n              Gb = 0,\n              Bb = 0,\n              mb = 0,\n              C = 0,\n              Va = 0,\n              Ta = 0;ia = 0;for (Za = b.length; ia < Za; ia++) {\n            Y = b[ia], Y.onlyShadow || (xb = Y.color, Ca = Y.intensity, jb = Y.distance, Y instanceof THREE.AmbientLight ? Y.visible && (bb += xb.r, cb += xb.g, ib += xb.b) : Y instanceof THREE.DirectionalLight ? (Ea += 1, Y.visible && (pa.setFromMatrixPosition(Y.matrixWorld), wa.setFromMatrixPosition(Y.target.matrixWorld), pa.sub(wa), pa.normalize(), mb = 3 * lb, La[mb] = pa.x, La[mb + 1] = pa.y, La[mb + 2] = pa.z, y(rb, mb, xb, Ca), lb += 1)) : Y instanceof THREE.PointLight ? (Fa += 1, Y.visible && (C = 3 * Na, y(Ma, C, xb, Ca), wa.setFromMatrixPosition(Y.matrixWorld), kb[C] = wa.x, kb[C + 1] = wa.y, kb[C + 2] = wa.z, yb[Na] = jb, zb[Na] = 0 === Y.distance ? 0 : Y.decay, Na += 1)) : Y instanceof THREE.SpotLight ? (Gb += 1, Y.visible && (Va = 3 * sa, y(Ra, Va, xb, Ca), pa.setFromMatrixPosition(Y.matrixWorld), Aa[Va] = pa.x, Aa[Va + 1] = pa.y, Aa[Va + 2] = pa.z, eb[sa] = jb, wa.setFromMatrixPosition(Y.target.matrixWorld), pa.sub(wa), pa.normalize(), Ha[Va] = pa.x, Ha[Va + 1] = pa.y, Ha[Va + 2] = pa.z, la[sa] = Math.cos(Y.angle), ra[sa] = Y.exponent, K[sa] = 0 === Y.distance ? 0 : Y.decay, sa += 1)) : Y instanceof THREE.HemisphereLight && (Bb += 1, Y.visible && (pa.setFromMatrixPosition(Y.matrixWorld), pa.normalize(), Ta = 3 * Da, Ab[Ta] = pa.x, Ab[Ta + 1] = pa.y, Ab[Ta + 2] = pa.z, pb = Y.color, qb = Y.groundColor, y(za, Ta, pb, Ca), y(Sa, Ta, qb, Ca), Da += 1)));\n          }ia = 3 * lb;for (Za = Math.max(rb.length, 3 * Ea); ia < Za; ia++) {\n            rb[ia] = 0;\n          }ia = 3 * Na;for (Za = Math.max(Ma.length, 3 * Fa); ia < Za; ia++) {\n            Ma[ia] = 0;\n          }ia = 3 * sa;for (Za = Math.max(Ra.length, 3 * Gb); ia < Za; ia++) {\n            Ra[ia] = 0;\n          }ia = 3 * Da;for (Za = Math.max(za.length, 3 * Bb); ia < Za; ia++) {\n            za[ia] = 0;\n          }ia = 3 * Da;for (Za = Math.max(Sa.length, 3 * Bb); ia < Za; ia++) {\n            Sa[ia] = 0;\n          }na.directional.length = lb;na.point.length = Na;na.spot.length = sa;na.hemi.length = Da;na.ambient[0] = bb;na.ambient[1] = cb;na.ambient[2] = ib;Ob = !1;\n        }if (qa) {\n          var ea = jc;Q.ambientLightColor.value = ea.ambient;Q.directionalLightColor.value = ea.directional.colors;Q.directionalLightDirection.value = ea.directional.positions;Q.pointLightColor.value = ea.point.colors;Q.pointLightPosition.value = ea.point.positions;Q.pointLightDistance.value = ea.point.distances;Q.pointLightDecay.value = ea.point.decays;Q.spotLightColor.value = ea.spot.colors;Q.spotLightPosition.value = ea.spot.positions;Q.spotLightDistance.value = ea.spot.distances;Q.spotLightDirection.value = ea.spot.directions;Q.spotLightAngleCos.value = ea.spot.anglesCos;Q.spotLightExponent.value = ea.spot.exponents;Q.spotLightDecay.value = ea.spot.decays;Q.hemisphereLightSkyColor.value = ea.hemi.skyColors;Q.hemisphereLightGroundColor.value = ea.hemi.groundColors;\n          Q.hemisphereLightDirection.value = ea.hemi.positions;x(Q, !0);\n        } else x(Q, !1);\n      }if (d instanceof THREE.MeshBasicMaterial || d instanceof THREE.MeshLambertMaterial || d instanceof THREE.MeshPhongMaterial) {\n        Q.opacity.value = d.opacity;Q.diffuse.value = d.color;Q.map.value = d.map;Q.lightMap.value = d.lightMap;Q.specularMap.value = d.specularMap;Q.alphaMap.value = d.alphaMap;d.bumpMap && (Q.bumpMap.value = d.bumpMap, Q.bumpScale.value = d.bumpScale);d.normalMap && (Q.normalMap.value = d.normalMap, Q.normalScale.value.copy(d.normalScale));\n        var fb;d.map ? fb = d.map : d.specularMap ? fb = d.specularMap : d.normalMap ? fb = d.normalMap : d.bumpMap ? fb = d.bumpMap : d.alphaMap && (fb = d.alphaMap);if (void 0 !== fb) {\n          var wb = fb.offset,\n              Qb = fb.repeat;Q.offsetRepeat.value.set(wb.x, wb.y, Qb.x, Qb.y);\n        }Q.envMap.value = d.envMap;Q.flipEnvMap.value = d.envMap instanceof THREE.WebGLRenderTargetCube ? 1 : -1;Q.reflectivity.value = d.reflectivity;Q.refractionRatio.value = d.refractionRatio;\n      }if (d instanceof THREE.LineBasicMaterial) Q.diffuse.value = d.color, Q.opacity.value = d.opacity;else if (d instanceof THREE.LineDashedMaterial) Q.diffuse.value = d.color, Q.opacity.value = d.opacity, Q.dashSize.value = d.dashSize, Q.totalSize.value = d.dashSize + d.gapSize, Q.scale.value = d.scale;else if (d instanceof THREE.PointCloudMaterial) {\n        if (Q.psColor.value = d.color, Q.opacity.value = d.opacity, Q.size.value = d.size, Q.scale.value = U.height / 2, Q.map.value = d.map, null !== d.map) {\n          var Wb = d.map.offset,\n              Xb = d.map.repeat;Q.offsetRepeat.value.set(Wb.x, Wb.y, Xb.x, Xb.y);\n        }\n      } else d instanceof THREE.MeshPhongMaterial ? (Q.shininess.value = d.shininess, Q.emissive.value = d.emissive, Q.specular.value = d.specular, d.wrapAround && Q.wrapRGB.value.copy(d.wrapRGB)) : d instanceof THREE.MeshLambertMaterial ? (Q.emissive.value = d.emissive, d.wrapAround && Q.wrapRGB.value.copy(d.wrapRGB)) : d instanceof THREE.MeshDepthMaterial ? (Q.mNear.value = a.near, Q.mFar.value = a.far, Q.opacity.value = d.opacity) : d instanceof THREE.MeshNormalMaterial && (Q.opacity.value = d.opacity);if (e.receiveShadow && !d._shadowPass && Q.shadowMatrix) for (var sb = 0, Cb = 0, $ = b.length; Cb < $; Cb++) {\n        var xa = b[Cb];xa.castShadow && (xa instanceof THREE.SpotLight || xa instanceof THREE.DirectionalLight && !xa.shadowCascade) && (Q.shadowMap.value[sb] = xa.shadowMap, Q.shadowMapSize.value[sb] = xa.shadowMapSize, Q.shadowMatrix.value[sb] = xa.shadowMatrix, Q.shadowDarkness.value[sb] = xa.shadowDarkness, Q.shadowBias.value[sb] = xa.shadowBias, sb++);\n      }for (var Hb = d.uniformsList, Oa, $a, Ga, nb = 0, fc = Hb.length; nb < fc; nb++) {\n        var T = Hb[nb][0];if (!1 !== T.needsUpdate) {\n          var Db = T.type,\n              S = T.value,\n              aa = Hb[nb][1];switch (Db) {case \"1i\":\n              m.uniform1i(aa, S);break;case \"1f\":\n              m.uniform1f(aa, S);break;\n            case \"2f\":\n              m.uniform2f(aa, S[0], S[1]);break;case \"3f\":\n              m.uniform3f(aa, S[0], S[1], S[2]);break;case \"4f\":\n              m.uniform4f(aa, S[0], S[1], S[2], S[3]);break;case \"1iv\":\n              m.uniform1iv(aa, S);break;case \"3iv\":\n              m.uniform3iv(aa, S);break;case \"1fv\":\n              m.uniform1fv(aa, S);break;case \"2fv\":\n              m.uniform2fv(aa, S);break;case \"3fv\":\n              m.uniform3fv(aa, S);break;case \"4fv\":\n              m.uniform4fv(aa, S);break;case \"Matrix3fv\":\n              m.uniformMatrix3fv(aa, !1, S);break;case \"Matrix4fv\":\n              m.uniformMatrix4fv(aa, !1, S);break;case \"i\":\n              m.uniform1i(aa, S);break;case \"f\":\n              m.uniform1f(aa, S);break;case \"v2\":\n              m.uniform2f(aa, S.x, S.y);break;case \"v3\":\n              m.uniform3f(aa, S.x, S.y, S.z);break;case \"v4\":\n              m.uniform4f(aa, S.x, S.y, S.z, S.w);break;case \"c\":\n              m.uniform3f(aa, S.r, S.g, S.b);break;case \"iv1\":\n              m.uniform1iv(aa, S);break;case \"iv\":\n              m.uniform3iv(aa, S);break;case \"fv1\":\n              m.uniform1fv(aa, S);break;case \"fv\":\n              m.uniform3fv(aa, S);break;case \"v2v\":\n              void 0 === T._array && (T._array = new Float32Array(2 * S.length));for (var Z = 0, Ba = S.length; Z < Ba; Z++) {\n                Ga = 2 * Z, T._array[Ga] = S[Z].x, T._array[Ga + 1] = S[Z].y;\n              }m.uniform2fv(aa, T._array);\n              break;case \"v3v\":\n              void 0 === T._array && (T._array = new Float32Array(3 * S.length));Z = 0;for (Ba = S.length; Z < Ba; Z++) {\n                Ga = 3 * Z, T._array[Ga] = S[Z].x, T._array[Ga + 1] = S[Z].y, T._array[Ga + 2] = S[Z].z;\n              }m.uniform3fv(aa, T._array);break;case \"v4v\":\n              void 0 === T._array && (T._array = new Float32Array(4 * S.length));Z = 0;for (Ba = S.length; Z < Ba; Z++) {\n                Ga = 4 * Z, T._array[Ga] = S[Z].x, T._array[Ga + 1] = S[Z].y, T._array[Ga + 2] = S[Z].z, T._array[Ga + 3] = S[Z].w;\n              }m.uniform4fv(aa, T._array);break;case \"m3\":\n              m.uniformMatrix3fv(aa, !1, S.elements);break;case \"m3v\":\n              void 0 === T._array && (T._array = new Float32Array(9 * S.length));Z = 0;for (Ba = S.length; Z < Ba; Z++) {\n                S[Z].flattenToArrayOffset(T._array, 9 * Z);\n              }m.uniformMatrix3fv(aa, !1, T._array);break;case \"m4\":\n              m.uniformMatrix4fv(aa, !1, S.elements);break;case \"m4v\":\n              void 0 === T._array && (T._array = new Float32Array(16 * S.length));Z = 0;for (Ba = S.length; Z < Ba; Z++) {\n                S[Z].flattenToArrayOffset(T._array, 16 * Z);\n              }m.uniformMatrix4fv(aa, !1, T._array);break;case \"t\":\n              Oa = S;$a = D();m.uniform1i(aa, $a);if (!Oa) continue;if (Oa instanceof THREE.CubeTexture || Oa.image instanceof Array && 6 === Oa.image.length) {\n                var X = Oa,\n                    Eb = $a;if (6 === X.image.length) if (X.needsUpdate) {\n                  X.image.__webglTextureCube || (X.addEventListener(\"dispose\", Pb), X.image.__webglTextureCube = m.createTexture(), B.info.memory.textures++);m.activeTexture(m.TEXTURE0 + Eb);m.bindTexture(m.TEXTURE_CUBE_MAP, X.image.__webglTextureCube);m.pixelStorei(m.UNPACK_FLIP_Y_WEBGL, X.flipY);for (var Rb = X instanceof THREE.CompressedTexture, Ib = X.image[0] instanceof THREE.DataTexture, gb = [], ya = 0; 6 > ya; ya++) {\n                    gb[ya] = !B.autoScaleCubemaps || Rb || Ib ? Ib ? X.image[ya].image : X.image[ya] : E(X.image[ya], qc);\n                  }var Yb = gb[0],\n                      Zb = THREE.Math.isPowerOfTwo(Yb.width) && THREE.Math.isPowerOfTwo(Yb.height),\n                      Wa = I(X.format),\n                      tb = I(X.type);A(m.TEXTURE_CUBE_MAP, X, Zb);for (ya = 0; 6 > ya; ya++) {\n                    if (Rb) for (var hb, $b = gb[ya].mipmaps, Fb = 0, Sb = $b.length; Fb < Sb; Fb++) {\n                      hb = $b[Fb], X.format !== THREE.RGBAFormat && X.format !== THREE.RGBFormat ? -1 < kc().indexOf(Wa) ? m.compressedTexImage2D(m.TEXTURE_CUBE_MAP_POSITIVE_X + ya, Fb, Wa, hb.width, hb.height, 0, hb.data) : THREE.warn(\"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()\") : m.texImage2D(m.TEXTURE_CUBE_MAP_POSITIVE_X + ya, Fb, Wa, hb.width, hb.height, 0, Wa, tb, hb.data);\n                    } else Ib ? m.texImage2D(m.TEXTURE_CUBE_MAP_POSITIVE_X + ya, 0, Wa, gb[ya].width, gb[ya].height, 0, Wa, tb, gb[ya].data) : m.texImage2D(m.TEXTURE_CUBE_MAP_POSITIVE_X + ya, 0, Wa, Wa, tb, gb[ya]);\n                  }X.generateMipmaps && Zb && m.generateMipmap(m.TEXTURE_CUBE_MAP);X.needsUpdate = !1;if (X.onUpdate) X.onUpdate();\n                } else m.activeTexture(m.TEXTURE0 + Eb), m.bindTexture(m.TEXTURE_CUBE_MAP, X.image.__webglTextureCube);\n              } else if (Oa instanceof THREE.WebGLRenderTargetCube) {\n                var Jb = Oa;m.activeTexture(m.TEXTURE0 + $a);m.bindTexture(m.TEXTURE_CUBE_MAP, Jb.__webglTexture);\n              } else B.setTexture(Oa, $a);break;case \"tv\":\n              void 0 === T._array && (T._array = []);Z = 0;for (Ba = T.value.length; Z < Ba; Z++) {\n                T._array[Z] = D();\n              }m.uniform1iv(aa, T._array);Z = 0;for (Ba = T.value.length; Z < Ba; Z++) {\n                Oa = T.value[Z], $a = T._array[Z], Oa && B.setTexture(Oa, $a);\n              }break;default:\n              THREE.warn(\"THREE.WebGLRenderer: Unknown uniform type: \" + Db);}\n        }\n      }\n    }m.uniformMatrix4fv(ka.modelViewMatrix, !1, e._modelViewMatrix.elements);ka.normalMatrix && m.uniformMatrix3fv(ka.normalMatrix, !1, e._normalMatrix.elements);null !== ka.modelMatrix && m.uniformMatrix4fv(ka.modelMatrix, !1, e.matrixWorld.elements);return Ua;\n  }function x(a, b) {\n    a.ambientLightColor.needsUpdate = b;a.directionalLightColor.needsUpdate = b;a.directionalLightDirection.needsUpdate = b;a.pointLightColor.needsUpdate = b;a.pointLightPosition.needsUpdate = b;a.pointLightDistance.needsUpdate = b;a.pointLightDecay.needsUpdate = b;a.spotLightColor.needsUpdate = b;a.spotLightPosition.needsUpdate = b;a.spotLightDistance.needsUpdate = b;a.spotLightDirection.needsUpdate = b;a.spotLightAngleCos.needsUpdate = b;a.spotLightExponent.needsUpdate = b;a.spotLightDecay.needsUpdate = b;a.hemisphereLightSkyColor.needsUpdate = b;a.hemisphereLightGroundColor.needsUpdate = b;a.hemisphereLightDirection.needsUpdate = b;\n  }function D() {\n    var a = Mb;a >= Wb && THREE.warn(\"WebGLRenderer: trying to use \" + a + \" texture units while this GPU supports only \" + Wb);Mb += 1;return a;\n  }function w(a, b) {\n    a._modelViewMatrix.multiplyMatrices(b.matrixWorldInverse, a.matrixWorld);a._normalMatrix.getNormalMatrix(a._modelViewMatrix);\n  }\n  function y(a, b, c, d) {\n    a[b] = c.r * d;a[b + 1] = c.g * d;a[b + 2] = c.b * d;\n  }function A(a, b, c) {\n    c ? (m.texParameteri(a, m.TEXTURE_WRAP_S, I(b.wrapS)), m.texParameteri(a, m.TEXTURE_WRAP_T, I(b.wrapT)), m.texParameteri(a, m.TEXTURE_MAG_FILTER, I(b.magFilter)), m.texParameteri(a, m.TEXTURE_MIN_FILTER, I(b.minFilter))) : (m.texParameteri(a, m.TEXTURE_WRAP_S, m.CLAMP_TO_EDGE), m.texParameteri(a, m.TEXTURE_WRAP_T, m.CLAMP_TO_EDGE), b.wrapS === THREE.ClampToEdgeWrapping && b.wrapT === THREE.ClampToEdgeWrapping || THREE.warn(\"THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping. ( \" + b.sourceFile + \" )\"), m.texParameteri(a, m.TEXTURE_MAG_FILTER, z(b.magFilter)), m.texParameteri(a, m.TEXTURE_MIN_FILTER, z(b.minFilter)), b.minFilter !== THREE.NearestFilter && b.minFilter !== THREE.LinearFilter && THREE.warn(\"THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter. ( \" + b.sourceFile + \" )\"));(c = da.get(\"EXT_texture_filter_anisotropic\")) && b.type !== THREE.FloatType && b.type !== THREE.HalfFloatType && (1 < b.anisotropy || b.__currentAnisotropy) && (m.texParameterf(a, c.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(b.anisotropy, B.getMaxAnisotropy())), b.__currentAnisotropy = b.anisotropy);\n  }function E(a, b) {\n    if (a.width > b || a.height > b) {\n      var c = b / Math.max(a.width, a.height),\n          d = document.createElement(\"canvas\");d.width = Math.floor(a.width * c);d.height = Math.floor(a.height * c);d.getContext(\"2d\").drawImage(a, 0, 0, a.width, a.height, 0, 0, d.width, d.height);THREE.warn(\"THREE.WebGLRenderer: image is too big (\" + a.width + \"x\" + a.height + \"). Resized to \" + d.width + \"x\" + d.height, a);return d;\n    }return a;\n  }\n  function G(a, b) {\n    m.bindRenderbuffer(m.RENDERBUFFER, a);b.depthBuffer && !b.stencilBuffer ? (m.renderbufferStorage(m.RENDERBUFFER, m.DEPTH_COMPONENT16, b.width, b.height), m.framebufferRenderbuffer(m.FRAMEBUFFER, m.DEPTH_ATTACHMENT, m.RENDERBUFFER, a)) : b.depthBuffer && b.stencilBuffer ? (m.renderbufferStorage(m.RENDERBUFFER, m.DEPTH_STENCIL, b.width, b.height), m.framebufferRenderbuffer(m.FRAMEBUFFER, m.DEPTH_STENCIL_ATTACHMENT, m.RENDERBUFFER, a)) : m.renderbufferStorage(m.RENDERBUFFER, m.RGBA4, b.width, b.height);\n  }function F(a) {\n    a instanceof THREE.WebGLRenderTargetCube ? (m.bindTexture(m.TEXTURE_CUBE_MAP, a.__webglTexture), m.generateMipmap(m.TEXTURE_CUBE_MAP), m.bindTexture(m.TEXTURE_CUBE_MAP, null)) : (m.bindTexture(m.TEXTURE_2D, a.__webglTexture), m.generateMipmap(m.TEXTURE_2D), m.bindTexture(m.TEXTURE_2D, null));\n  }function z(a) {\n    return a === THREE.NearestFilter || a === THREE.NearestMipMapNearestFilter || a === THREE.NearestMipMapLinearFilter ? m.NEAREST : m.LINEAR;\n  }function I(a) {\n    var b;if (a === THREE.RepeatWrapping) return m.REPEAT;if (a === THREE.ClampToEdgeWrapping) return m.CLAMP_TO_EDGE;\n    if (a === THREE.MirroredRepeatWrapping) return m.MIRRORED_REPEAT;if (a === THREE.NearestFilter) return m.NEAREST;if (a === THREE.NearestMipMapNearestFilter) return m.NEAREST_MIPMAP_NEAREST;if (a === THREE.NearestMipMapLinearFilter) return m.NEAREST_MIPMAP_LINEAR;if (a === THREE.LinearFilter) return m.LINEAR;if (a === THREE.LinearMipMapNearestFilter) return m.LINEAR_MIPMAP_NEAREST;if (a === THREE.LinearMipMapLinearFilter) return m.LINEAR_MIPMAP_LINEAR;if (a === THREE.UnsignedByteType) return m.UNSIGNED_BYTE;if (a === THREE.UnsignedShort4444Type) return m.UNSIGNED_SHORT_4_4_4_4;\n    if (a === THREE.UnsignedShort5551Type) return m.UNSIGNED_SHORT_5_5_5_1;if (a === THREE.UnsignedShort565Type) return m.UNSIGNED_SHORT_5_6_5;if (a === THREE.ByteType) return m.BYTE;if (a === THREE.ShortType) return m.SHORT;if (a === THREE.UnsignedShortType) return m.UNSIGNED_SHORT;if (a === THREE.IntType) return m.INT;if (a === THREE.UnsignedIntType) return m.UNSIGNED_INT;if (a === THREE.FloatType) return m.FLOAT;b = da.get(\"OES_texture_half_float\");if (null !== b && a === THREE.HalfFloatType) return b.HALF_FLOAT_OES;if (a === THREE.AlphaFormat) return m.ALPHA;\n    if (a === THREE.RGBFormat) return m.RGB;if (a === THREE.RGBAFormat) return m.RGBA;if (a === THREE.LuminanceFormat) return m.LUMINANCE;if (a === THREE.LuminanceAlphaFormat) return m.LUMINANCE_ALPHA;if (a === THREE.AddEquation) return m.FUNC_ADD;if (a === THREE.SubtractEquation) return m.FUNC_SUBTRACT;if (a === THREE.ReverseSubtractEquation) return m.FUNC_REVERSE_SUBTRACT;if (a === THREE.ZeroFactor) return m.ZERO;if (a === THREE.OneFactor) return m.ONE;if (a === THREE.SrcColorFactor) return m.SRC_COLOR;if (a === THREE.OneMinusSrcColorFactor) return m.ONE_MINUS_SRC_COLOR;\n    if (a === THREE.SrcAlphaFactor) return m.SRC_ALPHA;if (a === THREE.OneMinusSrcAlphaFactor) return m.ONE_MINUS_SRC_ALPHA;if (a === THREE.DstAlphaFactor) return m.DST_ALPHA;if (a === THREE.OneMinusDstAlphaFactor) return m.ONE_MINUS_DST_ALPHA;if (a === THREE.DstColorFactor) return m.DST_COLOR;if (a === THREE.OneMinusDstColorFactor) return m.ONE_MINUS_DST_COLOR;if (a === THREE.SrcAlphaSaturateFactor) return m.SRC_ALPHA_SATURATE;b = da.get(\"WEBGL_compressed_texture_s3tc\");if (null !== b) {\n      if (a === THREE.RGB_S3TC_DXT1_Format) return b.COMPRESSED_RGB_S3TC_DXT1_EXT;\n      if (a === THREE.RGBA_S3TC_DXT1_Format) return b.COMPRESSED_RGBA_S3TC_DXT1_EXT;if (a === THREE.RGBA_S3TC_DXT3_Format) return b.COMPRESSED_RGBA_S3TC_DXT3_EXT;if (a === THREE.RGBA_S3TC_DXT5_Format) return b.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n    }b = da.get(\"WEBGL_compressed_texture_pvrtc\");if (null !== b) {\n      if (a === THREE.RGB_PVRTC_4BPPV1_Format) return b.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if (a === THREE.RGB_PVRTC_2BPPV1_Format) return b.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if (a === THREE.RGBA_PVRTC_4BPPV1_Format) return b.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n      if (a === THREE.RGBA_PVRTC_2BPPV1_Format) return b.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n    }b = da.get(\"EXT_blend_minmax\");if (null !== b) {\n      if (a === THREE.MinEquation) return b.MIN_EXT;if (a === THREE.MaxEquation) return b.MAX_EXT;\n    }return 0;\n  }console.log(\"THREE.WebGLRenderer\", THREE.REVISION);a = a || {};var U = void 0 !== a.canvas ? a.canvas : document.createElement(\"canvas\"),\n      M = void 0 !== a.context ? a.context : null,\n      H = 1,\n      L = void 0 !== a.precision ? a.precision : \"highp\",\n      P = void 0 !== a.alpha ? a.alpha : !1,\n      N = void 0 !== a.depth ? a.depth : !0,\n      R = void 0 !== a.stencil ? a.stencil : !0,\n      V = void 0 !== a.antialias ? a.antialias : !1,\n      J = void 0 !== a.premultipliedAlpha ? a.premultipliedAlpha : !0,\n      oa = void 0 !== a.preserveDrawingBuffer ? a.preserveDrawingBuffer : !1,\n      ja = void 0 !== a.logarithmicDepthBuffer ? a.logarithmicDepthBuffer : !1,\n      ha = new THREE.Color(0),\n      O = 0,\n      ca = [],\n      ba = {},\n      qa = [],\n      Ka = [],\n      Qa = [],\n      Xa = [],\n      Ya = [];this.domElement = U;this.context = null;this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0;this.gammaFactor = 2;this.shadowMapEnabled = this.gammaOutput = this.gammaInput = !1;this.shadowMapType = THREE.PCFShadowMap;this.shadowMapCullFace = THREE.CullFaceFront;this.shadowMapCascade = this.shadowMapDebug = !1;this.maxMorphTargets = 8;this.maxMorphNormals = 4;this.autoScaleCubemaps = !0;this.info = { memory: { programs: 0, geometries: 0, textures: 0 }, render: { calls: 0, vertices: 0, faces: 0, points: 0 } };var B = this,\n      Pa = [],\n      ob = null,\n      ab = null,\n      ub = -1,\n      ta = \"\",\n      vb = null,\n      Mb = 0,\n      ib = 0,\n      bb = 0,\n      pb = U.width,\n      qb = U.height,\n      Xb = 0,\n      fc = 0,\n      cb = new THREE.Frustum(),\n      db = new THREE.Matrix4(),\n      wa = new THREE.Vector3(),\n      pa = new THREE.Vector3(),\n      Ob = !0,\n      jc = { ambient: [0, 0, 0], directional: { length: 0, colors: [], positions: [] }, point: { length: 0, colors: [], positions: [], distances: [], decays: [] }, spot: { length: 0, colors: [], positions: [], distances: [], directions: [], anglesCos: [], exponents: [], decays: [] }, hemi: { length: 0, skyColors: [], groundColors: [], positions: [] } },\n      m;try {\n    var Yb = { alpha: P, depth: N, stencil: R, antialias: V, premultipliedAlpha: J, preserveDrawingBuffer: oa };m = M || U.getContext(\"webgl\", Yb) || U.getContext(\"experimental-webgl\", Yb);if (null === m) {\n      if (null !== U.getContext(\"webgl\")) throw \"Error creating WebGL context with your selected attributes.\";\n      throw \"Error creating WebGL context.\";\n    }U.addEventListener(\"webglcontextlost\", function (a) {\n      a.preventDefault();Zb();lc();ba = {};\n    }, !1);\n  } catch (rc) {\n    THREE.error(\"THREE.WebGLRenderer: \" + rc);\n  }var W = new THREE.WebGLState(m, I);void 0 === m.getShaderPrecisionFormat && (m.getShaderPrecisionFormat = function () {\n    return { rangeMin: 1, rangeMax: 1, precision: 1 };\n  });var da = new THREE.WebGLExtensions(m);da.get(\"OES_texture_float\");da.get(\"OES_texture_float_linear\");da.get(\"OES_texture_half_float\");da.get(\"OES_texture_half_float_linear\");\n  da.get(\"OES_standard_derivatives\");ja && da.get(\"EXT_frag_depth\");var rb = function rb(a, b, c, d) {\n    !0 === J && (a *= d, b *= d, c *= d);m.clearColor(a, b, c, d);\n  },\n      lc = function lc() {\n    m.clearColor(0, 0, 0, 1);m.clearDepth(1);m.clearStencil(0);m.enable(m.DEPTH_TEST);m.depthFunc(m.LEQUAL);m.frontFace(m.CCW);m.cullFace(m.BACK);m.enable(m.CULL_FACE);m.enable(m.BLEND);m.blendEquation(m.FUNC_ADD);m.blendFunc(m.SRC_ALPHA, m.ONE_MINUS_SRC_ALPHA);m.viewport(ib, bb, pb, qb);rb(ha.r, ha.g, ha.b, O);\n  },\n      Zb = function Zb() {\n    vb = ob = null;ta = \"\";ub = -1;Ob = !0;W.reset();\n  };\n  lc();this.context = m;this.state = W;var Wb = m.getParameter(m.MAX_TEXTURE_IMAGE_UNITS),\n      sc = m.getParameter(m.MAX_VERTEX_TEXTURE_IMAGE_UNITS),\n      tc = m.getParameter(m.MAX_TEXTURE_SIZE),\n      qc = m.getParameter(m.MAX_CUBE_MAP_TEXTURE_SIZE),\n      Vb = 0 < sc,\n      Nb = Vb && da.get(\"OES_texture_float\"),\n      uc = m.getShaderPrecisionFormat(m.VERTEX_SHADER, m.HIGH_FLOAT),\n      vc = m.getShaderPrecisionFormat(m.VERTEX_SHADER, m.MEDIUM_FLOAT),\n      wc = m.getShaderPrecisionFormat(m.FRAGMENT_SHADER, m.HIGH_FLOAT),\n      xc = m.getShaderPrecisionFormat(m.FRAGMENT_SHADER, m.MEDIUM_FLOAT),\n      kc = function () {\n    var a;return function () {\n      if (void 0 !== a) return a;a = [];if (da.get(\"WEBGL_compressed_texture_pvrtc\") || da.get(\"WEBGL_compressed_texture_s3tc\")) for (var b = m.getParameter(m.COMPRESSED_TEXTURE_FORMATS), c = 0; c < b.length; c++) {\n        a.push(b[c]);\n      }return a;\n    };\n  }(),\n      yc = 0 < uc.precision && 0 < wc.precision,\n      mc = 0 < vc.precision && 0 < xc.precision;\"highp\" !== L || yc || (mc ? (L = \"mediump\", THREE.warn(\"THREE.WebGLRenderer: highp not supported, using mediump.\")) : (L = \"lowp\", THREE.warn(\"THREE.WebGLRenderer: highp and mediump not supported, using lowp.\")));\n  \"mediump\" !== L || mc || (L = \"lowp\", THREE.warn(\"THREE.WebGLRenderer: mediump not supported, using lowp.\"));var zc = new THREE.ShadowMapPlugin(this, ca, ba, qa),\n      Ac = new THREE.SpritePlugin(this, Xa),\n      Bc = new THREE.LensFlarePlugin(this, Ya);this.getContext = function () {\n    return m;\n  };this.forceContextLoss = function () {\n    da.get(\"WEBGL_lose_context\").loseContext();\n  };this.supportsVertexTextures = function () {\n    return Vb;\n  };this.supportsFloatTextures = function () {\n    return da.get(\"OES_texture_float\");\n  };this.supportsHalfFloatTextures = function () {\n    return da.get(\"OES_texture_half_float\");\n  };\n  this.supportsStandardDerivatives = function () {\n    return da.get(\"OES_standard_derivatives\");\n  };this.supportsCompressedTextureS3TC = function () {\n    return da.get(\"WEBGL_compressed_texture_s3tc\");\n  };this.supportsCompressedTexturePVRTC = function () {\n    return da.get(\"WEBGL_compressed_texture_pvrtc\");\n  };this.supportsBlendMinMax = function () {\n    return da.get(\"EXT_blend_minmax\");\n  };this.getMaxAnisotropy = function () {\n    var a;return function () {\n      if (void 0 !== a) return a;var b = da.get(\"EXT_texture_filter_anisotropic\");return a = null !== b ? m.getParameter(b.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;\n    };\n  }();this.getPrecision = function () {\n    return L;\n  };this.getPixelRatio = function () {\n    return H;\n  };this.setPixelRatio = function (a) {\n    H = a;\n  };this.setSize = function (a, b, c) {\n    U.width = a * H;U.height = b * H;!1 !== c && (U.style.width = a + \"px\", U.style.height = b + \"px\");this.setViewport(0, 0, a, b);\n  };this.setViewport = function (a, b, c, d) {\n    ib = a * H;bb = b * H;pb = c * H;qb = d * H;m.viewport(ib, bb, pb, qb);\n  };this.setScissor = function (a, b, c, d) {\n    m.scissor(a * H, b * H, c * H, d * H);\n  };this.enableScissorTest = function (a) {\n    a ? m.enable(m.SCISSOR_TEST) : m.disable(m.SCISSOR_TEST);\n  };this.getClearColor = function () {\n    return ha;\n  };this.setClearColor = function (a, b) {\n    ha.set(a);O = void 0 !== b ? b : 1;rb(ha.r, ha.g, ha.b, O);\n  };this.getClearAlpha = function () {\n    return O;\n  };this.setClearAlpha = function (a) {\n    O = a;rb(ha.r, ha.g, ha.b, O);\n  };this.clear = function (a, b, c) {\n    var d = 0;if (void 0 === a || a) d |= m.COLOR_BUFFER_BIT;if (void 0 === b || b) d |= m.DEPTH_BUFFER_BIT;if (void 0 === c || c) d |= m.STENCIL_BUFFER_BIT;m.clear(d);\n  };this.clearColor = function () {\n    m.clear(m.COLOR_BUFFER_BIT);\n  };this.clearDepth = function () {\n    m.clear(m.DEPTH_BUFFER_BIT);\n  };this.clearStencil = function () {\n    m.clear(m.STENCIL_BUFFER_BIT);\n  };\n  this.clearTarget = function (a, b, c, d) {\n    this.setRenderTarget(a);this.clear(b, c, d);\n  };this.resetGLState = Zb;var wb = function wb(a) {\n    a.target.traverse(function (a) {\n      a.removeEventListener(\"remove\", wb);if (a instanceof THREE.Mesh || a instanceof THREE.PointCloud || a instanceof THREE.Line) delete ba[a.id];else if (a instanceof THREE.ImmediateRenderObject || a.immediateRenderCallback) for (var b = qa, c = b.length - 1; 0 <= c; c--) {\n        b[c].object === a && b.splice(c, 1);\n      }delete a.__webglInit;delete a._modelViewMatrix;delete a._normalMatrix;delete a.__webglActive;\n    });\n  },\n      jb = function jb(a) {\n    a = a.target;a.removeEventListener(\"dispose\", jb);delete a.__webglInit;if (a instanceof THREE.BufferGeometry) {\n      for (var b in a.attributes) {\n        var c = a.attributes[b];void 0 !== c.buffer && (m.deleteBuffer(c.buffer), delete c.buffer);\n      }B.info.memory.geometries--;\n    } else if (b = Ua[a.id], void 0 !== b) {\n      for (var c = 0, d = b.length; c < d; c++) {\n        var e = b[c];if (void 0 !== e.numMorphTargets) {\n          for (var f = 0, g = e.numMorphTargets; f < g; f++) {\n            m.deleteBuffer(e.__webglMorphTargetsBuffers[f]);\n          }delete e.__webglMorphTargetsBuffers;\n        }if (void 0 !== e.numMorphNormals) {\n          f = 0;for (g = e.numMorphNormals; f < g; f++) {\n            m.deleteBuffer(e.__webglMorphNormalsBuffers[f]);\n          }delete e.__webglMorphNormalsBuffers;\n        }nc(e);\n      }delete Ua[a.id];\n    } else nc(a);ta = \"\";\n  },\n      Pb = function Pb(a) {\n    a = a.target;a.removeEventListener(\"dispose\", Pb);a.image && a.image.__webglTextureCube ? (m.deleteTexture(a.image.__webglTextureCube), delete a.image.__webglTextureCube) : void 0 !== a.__webglInit && (m.deleteTexture(a.__webglTexture), delete a.__webglTexture, delete a.__webglInit);B.info.memory.textures--;\n  },\n      oc = function oc(a) {\n    a = a.target;a.removeEventListener(\"dispose\", oc);if (a && void 0 !== a.__webglTexture) {\n      m.deleteTexture(a.__webglTexture);delete a.__webglTexture;if (a instanceof THREE.WebGLRenderTargetCube) for (var b = 0; 6 > b; b++) {\n        m.deleteFramebuffer(a.__webglFramebuffer[b]), m.deleteRenderbuffer(a.__webglRenderbuffer[b]);\n      } else m.deleteFramebuffer(a.__webglFramebuffer), m.deleteRenderbuffer(a.__webglRenderbuffer);delete a.__webglFramebuffer;delete a.__webglRenderbuffer;\n    }B.info.memory.textures--;\n  },\n      ic = function ic(a) {\n    a = a.target;a.removeEventListener(\"dispose\", ic);hc(a);\n  },\n      nc = function nc(a) {\n    for (var b = \"__webglVertexBuffer __webglNormalBuffer __webglTangentBuffer __webglColorBuffer __webglUVBuffer __webglUV2Buffer __webglSkinIndicesBuffer __webglSkinWeightsBuffer __webglFaceBuffer __webglLineBuffer __webglLineDistanceBuffer\".split(\" \"), c = 0, d = b.length; c < d; c++) {\n      var e = b[c];void 0 !== a[e] && (m.deleteBuffer(a[e]), delete a[e]);\n    }if (void 0 !== a.__webglCustomAttributesList) {\n      for (e in a.__webglCustomAttributesList) {\n        m.deleteBuffer(a.__webglCustomAttributesList[e].buffer);\n      }delete a.__webglCustomAttributesList;\n    }B.info.memory.geometries--;\n  },\n      hc = function hc(a) {\n    var b = a.program.program;if (void 0 !== b) {\n      a.program = void 0;var c,\n          d,\n          e = !1;a = 0;for (c = Pa.length; a < c; a++) {\n        if (d = Pa[a], d.program === b) {\n          d.usedTimes--;0 === d.usedTimes && (e = !0);break;\n        }\n      }if (!0 === e) {\n        e = [];a = 0;for (c = Pa.length; a < c; a++) {\n          d = Pa[a], d.program !== b && e.push(d);\n        }Pa = e;m.deleteProgram(b);B.info.memory.programs--;\n      }\n    }\n  };this.renderBufferImmediate = function (a, b, c) {\n    W.initAttributes();a.hasPositions && !a.__webglVertexBuffer && (a.__webglVertexBuffer = m.createBuffer());a.hasNormals && !a.__webglNormalBuffer && (a.__webglNormalBuffer = m.createBuffer());a.hasUvs && !a.__webglUvBuffer && (a.__webglUvBuffer = m.createBuffer());a.hasColors && !a.__webglColorBuffer && (a.__webglColorBuffer = m.createBuffer());a.hasPositions && (m.bindBuffer(m.ARRAY_BUFFER, a.__webglVertexBuffer), m.bufferData(m.ARRAY_BUFFER, a.positionArray, m.DYNAMIC_DRAW), W.enableAttribute(b.attributes.position), m.vertexAttribPointer(b.attributes.position, 3, m.FLOAT, !1, 0, 0));if (a.hasNormals) {\n      m.bindBuffer(m.ARRAY_BUFFER, a.__webglNormalBuffer);if (!1 === c instanceof THREE.MeshPhongMaterial && c.shading === THREE.FlatShading) {\n        var d,\n            e,\n            f,\n            g,\n            h,\n            k,\n            n,\n            l,\n            p,\n            q,\n            r,\n            s = 3 * a.count;for (r = 0; r < s; r += 9) {\n          q = a.normalArray, d = q[r], e = q[r + 1], f = q[r + 2], g = q[r + 3], k = q[r + 4], l = q[r + 5], h = q[r + 6], n = q[r + 7], p = q[r + 8], d = (d + g + h) / 3, e = (e + k + n) / 3, f = (f + l + p) / 3, q[r] = d, q[r + 1] = e, q[r + 2] = f, q[r + 3] = d, q[r + 4] = e, q[r + 5] = f, q[r + 6] = d, q[r + 7] = e, q[r + 8] = f;\n        }\n      }m.bufferData(m.ARRAY_BUFFER, a.normalArray, m.DYNAMIC_DRAW);W.enableAttribute(b.attributes.normal);m.vertexAttribPointer(b.attributes.normal, 3, m.FLOAT, !1, 0, 0);\n    }a.hasUvs && c.map && (m.bindBuffer(m.ARRAY_BUFFER, a.__webglUvBuffer), m.bufferData(m.ARRAY_BUFFER, a.uvArray, m.DYNAMIC_DRAW), W.enableAttribute(b.attributes.uv), m.vertexAttribPointer(b.attributes.uv, 2, m.FLOAT, !1, 0, 0));a.hasColors && c.vertexColors !== THREE.NoColors && (m.bindBuffer(m.ARRAY_BUFFER, a.__webglColorBuffer), m.bufferData(m.ARRAY_BUFFER, a.colorArray, m.DYNAMIC_DRAW), W.enableAttribute(b.attributes.color), m.vertexAttribPointer(b.attributes.color, 3, m.FLOAT, !1, 0, 0));W.disableUnusedAttributes();m.drawArrays(m.TRIANGLES, 0, a.count);a.count = 0;\n  };this.renderBufferDirect = function (a, b, c, e, f, g) {\n    if (!1 !== e.visible) if (t(g), a = v(a, b, c, e, g), b = !1, c = \"direct_\" + f.id + \"_\" + a.id + \"_\" + (e.wireframe ? 1 : 0), c !== ta && (ta = c, b = !0), b && W.initAttributes(), g instanceof THREE.Mesh) {\n      g = !0 === e.wireframe ? m.LINES : m.TRIANGLES;var h = f.attributes.index;if (h) {\n        var k, n;h.array instanceof Uint32Array && da.get(\"OES_element_index_uint\") ? (k = m.UNSIGNED_INT, n = 4) : (k = m.UNSIGNED_SHORT, n = 2);c = f.offsets;if (0 === c.length) b && (d(e, a, f, 0), m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, h.buffer)), m.drawElements(g, h.array.length, k, 0), B.info.render.calls++, B.info.render.vertices += h.array.length, B.info.render.faces += h.array.length / 3;else {\n          b = !0;for (var l = 0, p = c.length; l < p; l++) {\n            var q = c[l].index;b && (d(e, a, f, q), m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, h.buffer));m.drawElements(g, c[l].count, k, c[l].start * n);B.info.render.calls++;B.info.render.vertices += c[l].count;B.info.render.faces += c[l].count / 3;\n          }\n        }\n      } else b && d(e, a, f, 0), e = f.attributes.position, m.drawArrays(g, 0, e.array.length / e.itemSize), B.info.render.calls++, B.info.render.vertices += e.array.length / e.itemSize, B.info.render.faces += e.array.length / (3 * e.itemSize);\n    } else if (g instanceof THREE.PointCloud) {\n      if (g = m.POINTS, h = f.attributes.index) {\n        if (h.array instanceof Uint32Array && da.get(\"OES_element_index_uint\") ? (k = m.UNSIGNED_INT, n = 4) : (k = m.UNSIGNED_SHORT, n = 2), c = f.offsets, 0 === c.length) b && (d(e, a, f, 0), m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, h.buffer)), m.drawElements(g, h.array.length, k, 0), B.info.render.calls++, B.info.render.points += h.array.length;else for (1 < c.length && (b = !0), l = 0, p = c.length; l < p; l++) {\n          q = c[l].index, b && (d(e, a, f, q), m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, h.buffer)), m.drawElements(g, c[l].count, k, c[l].start * n), B.info.render.calls++, B.info.render.points += c[l].count;\n        }\n      } else if (b && d(e, a, f, 0), e = f.attributes.position, c = f.offsets, 0 === c.length) m.drawArrays(g, 0, e.array.length / 3), B.info.render.calls++, B.info.render.points += e.array.length / 3;else for (l = 0, p = c.length; l < p; l++) {\n        m.drawArrays(g, c[l].index, c[l].count), B.info.render.calls++, B.info.render.points += c[l].count;\n      }\n    } else if (g instanceof THREE.Line) if (g = g.mode === THREE.LineStrip ? m.LINE_STRIP : m.LINES, W.setLineWidth(e.linewidth * H), h = f.attributes.index) {\n      if (h.array instanceof Uint32Array ? (k = m.UNSIGNED_INT, n = 4) : (k = m.UNSIGNED_SHORT, n = 2), c = f.offsets, 0 === c.length) b && (d(e, a, f, 0), m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, h.buffer)), m.drawElements(g, h.array.length, k, 0), B.info.render.calls++, B.info.render.vertices += h.array.length;else for (1 < c.length && (b = !0), l = 0, p = c.length; l < p; l++) {\n        q = c[l].index, b && (d(e, a, f, q), m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, h.buffer)), m.drawElements(g, c[l].count, k, c[l].start * n), B.info.render.calls++, B.info.render.vertices += c[l].count;\n      }\n    } else if (b && d(e, a, f, 0), e = f.attributes.position, c = f.offsets, 0 === c.length) m.drawArrays(g, 0, e.array.length / 3), B.info.render.calls++, B.info.render.vertices += e.array.length / 3;else for (l = 0, p = c.length; l < p; l++) {\n      m.drawArrays(g, c[l].index, c[l].count), B.info.render.calls++, B.info.render.vertices += c[l].count;\n    }\n  };this.renderBuffer = function (a, b, c, d, e, f) {\n    if (!1 !== d.visible) {\n      t(f);c = v(a, b, c, d, f);b = c.attributes;a = !1;c = e.id + \"_\" + c.id + \"_\" + (d.wireframe ? 1 : 0);c !== ta && (ta = c, a = !0);a && W.initAttributes();if (!d.morphTargets && 0 <= b.position) a && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglVertexBuffer), W.enableAttribute(b.position), m.vertexAttribPointer(b.position, 3, m.FLOAT, !1, 0, 0));else if (f.morphTargetBase) {\n        c = d.program.attributes;-1 !== f.morphTargetBase && 0 <= c.position ? (m.bindBuffer(m.ARRAY_BUFFER, e.__webglMorphTargetsBuffers[f.morphTargetBase]), W.enableAttribute(c.position), m.vertexAttribPointer(c.position, 3, m.FLOAT, !1, 0, 0)) : 0 <= c.position && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglVertexBuffer), W.enableAttribute(c.position), m.vertexAttribPointer(c.position, 3, m.FLOAT, !1, 0, 0));if (f.morphTargetForcedOrder.length) for (var h = 0, k = f.morphTargetForcedOrder, n = f.morphTargetInfluences, l; h < d.numSupportedMorphTargets && h < k.length;) {\n          l = c[\"morphTarget\" + h], 0 <= l && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglMorphTargetsBuffers[k[h]]), W.enableAttribute(l), m.vertexAttribPointer(l, 3, m.FLOAT, !1, 0, 0)), l = c[\"morphNormal\" + h], 0 <= l && d.morphNormals && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglMorphNormalsBuffers[k[h]]), W.enableAttribute(l), m.vertexAttribPointer(l, 3, m.FLOAT, !1, 0, 0)), f.__webglMorphTargetInfluences[h] = n[k[h]], h++;\n        } else {\n          k = [];n = f.morphTargetInfluences;h = f.geometry.morphTargets;n.length > h.length && (console.warn(\"THREE.WebGLRenderer: Influences array is bigger than morphTargets array.\"), n.length = h.length);h = 0;for (l = n.length; h < l; h++) {\n            k.push([n[h], h]);\n          }k.length > d.numSupportedMorphTargets ? (k.sort(g), k.length = d.numSupportedMorphTargets) : k.length > d.numSupportedMorphNormals ? k.sort(g) : 0 === k.length && k.push([0, 0]);for (var h = 0, p = d.numSupportedMorphTargets; h < p; h++) {\n            if (k[h]) {\n              var q = k[h][1];l = c[\"morphTarget\" + h];0 <= l && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglMorphTargetsBuffers[q]), W.enableAttribute(l), m.vertexAttribPointer(l, 3, m.FLOAT, !1, 0, 0));l = c[\"morphNormal\" + h];0 <= l && d.morphNormals && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglMorphNormalsBuffers[q]), W.enableAttribute(l), m.vertexAttribPointer(l, 3, m.FLOAT, !1, 0, 0));f.__webglMorphTargetInfluences[h] = n[q];\n            } else f.__webglMorphTargetInfluences[h] = 0;\n          }\n        }null !== d.program.uniforms.morphTargetInfluences && m.uniform1fv(d.program.uniforms.morphTargetInfluences, f.__webglMorphTargetInfluences);\n      }if (a) {\n        if (e.__webglCustomAttributesList) for (c = 0, n = e.__webglCustomAttributesList.length; c < n; c++) {\n          k = e.__webglCustomAttributesList[c], 0 <= b[k.buffer.belongsToAttribute] && (m.bindBuffer(m.ARRAY_BUFFER, k.buffer), W.enableAttribute(b[k.buffer.belongsToAttribute]), m.vertexAttribPointer(b[k.buffer.belongsToAttribute], k.size, m.FLOAT, !1, 0, 0));\n        }0 <= b.color && (0 < f.geometry.colors.length || 0 < f.geometry.faces.length ? (m.bindBuffer(m.ARRAY_BUFFER, e.__webglColorBuffer), W.enableAttribute(b.color), m.vertexAttribPointer(b.color, 3, m.FLOAT, !1, 0, 0)) : void 0 !== d.defaultAttributeValues && m.vertexAttrib3fv(b.color, d.defaultAttributeValues.color));0 <= b.normal && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglNormalBuffer), W.enableAttribute(b.normal), m.vertexAttribPointer(b.normal, 3, m.FLOAT, !1, 0, 0));0 <= b.tangent && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglTangentBuffer), W.enableAttribute(b.tangent), m.vertexAttribPointer(b.tangent, 4, m.FLOAT, !1, 0, 0));0 <= b.uv && (f.geometry.faceVertexUvs[0] ? (m.bindBuffer(m.ARRAY_BUFFER, e.__webglUVBuffer), W.enableAttribute(b.uv), m.vertexAttribPointer(b.uv, 2, m.FLOAT, !1, 0, 0)) : void 0 !== d.defaultAttributeValues && m.vertexAttrib2fv(b.uv, d.defaultAttributeValues.uv));0 <= b.uv2 && (f.geometry.faceVertexUvs[1] ? (m.bindBuffer(m.ARRAY_BUFFER, e.__webglUV2Buffer), W.enableAttribute(b.uv2), m.vertexAttribPointer(b.uv2, 2, m.FLOAT, !1, 0, 0)) : void 0 !== d.defaultAttributeValues && m.vertexAttrib2fv(b.uv2, d.defaultAttributeValues.uv2));d.skinning && 0 <= b.skinIndex && 0 <= b.skinWeight && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglSkinIndicesBuffer), W.enableAttribute(b.skinIndex), m.vertexAttribPointer(b.skinIndex, 4, m.FLOAT, !1, 0, 0), m.bindBuffer(m.ARRAY_BUFFER, e.__webglSkinWeightsBuffer), W.enableAttribute(b.skinWeight), m.vertexAttribPointer(b.skinWeight, 4, m.FLOAT, !1, 0, 0));0 <= b.lineDistance && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglLineDistanceBuffer), W.enableAttribute(b.lineDistance), m.vertexAttribPointer(b.lineDistance, 1, m.FLOAT, !1, 0, 0));\n      }W.disableUnusedAttributes();f instanceof THREE.Mesh ? (f = e.__typeArray === Uint32Array ? m.UNSIGNED_INT : m.UNSIGNED_SHORT, d.wireframe ? (W.setLineWidth(d.wireframeLinewidth * H), a && m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, e.__webglLineBuffer), m.drawElements(m.LINES, e.__webglLineCount, f, 0)) : (a && m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, e.__webglFaceBuffer), m.drawElements(m.TRIANGLES, e.__webglFaceCount, f, 0)), B.info.render.calls++, B.info.render.vertices += e.__webglFaceCount, B.info.render.faces += e.__webglFaceCount / 3) : f instanceof THREE.Line ? (f = f.mode === THREE.LineStrip ? m.LINE_STRIP : m.LINES, W.setLineWidth(d.linewidth * H), m.drawArrays(f, 0, e.__webglLineCount), B.info.render.calls++) : f instanceof THREE.PointCloud && (m.drawArrays(m.POINTS, 0, e.__webglParticleCount), B.info.render.calls++, B.info.render.points += e.__webglParticleCount);\n    }\n  };this.render = function (a, b, c, d) {\n    if (!1 === b instanceof THREE.Camera) THREE.error(\"THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.\");else {\n      var g = a.fog;ta = \"\";ub = -1;vb = null;Ob = !0;!0 === a.autoUpdate && a.updateMatrixWorld();void 0 === b.parent && b.updateMatrixWorld();a.traverse(function (a) {\n        a instanceof THREE.SkinnedMesh && a.skeleton.update();\n      });b.matrixWorldInverse.getInverse(b.matrixWorld);db.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse);cb.setFromMatrix(db);ca.length = 0;Ka.length = 0;Qa.length = 0;Xa.length = 0;Ya.length = 0;h(a);!0 === B.sortObjects && (Ka.sort(e), Qa.sort(f));zc.render(a, b);B.info.render.calls = 0;B.info.render.vertices = 0;B.info.render.faces = 0;B.info.render.points = 0;this.setRenderTarget(c);(this.autoClear || d) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil);d = 0;for (var n = qa.length; d < n; d++) {\n        var m = qa[d],\n            q = m.object;q.visible && (w(q, b), p(m));\n      }a.overrideMaterial ? (d = a.overrideMaterial, u(d), k(Ka, b, ca, g, d), k(Qa, b, ca, g, d), l(qa, \"\", b, ca, g, d)) : (W.setBlending(THREE.NoBlending), k(Ka, b, ca, g, null), l(qa, \"opaque\", b, ca, g, null), k(Qa, b, ca, g, null), l(qa, \"transparent\", b, ca, g, null));Ac.render(a, b);Bc.render(a, b, Xb, fc);c && c.generateMipmaps && c.minFilter !== THREE.NearestFilter && c.minFilter !== THREE.LinearFilter && F(c);W.setDepthTest(!0);W.setDepthWrite(!0);W.setColorWrite(!0);\n    }\n  };this.renderImmediateObject = function (a, b, c, d, e) {\n    var f = v(a, b, c, d, e);ta = \"\";B.setMaterialFaces(d);e.immediateRenderCallback ? e.immediateRenderCallback(f, m, cb) : e.render(function (a) {\n      B.renderBufferImmediate(a, f, d);\n    });\n  };var Ua = {},\n      Qb = 0,\n      pc = { MeshDepthMaterial: \"depth\", MeshNormalMaterial: \"normal\", MeshBasicMaterial: \"basic\", MeshLambertMaterial: \"lambert\", MeshPhongMaterial: \"phong\", LineBasicMaterial: \"basic\", LineDashedMaterial: \"dashed\", PointCloudMaterial: \"particle_basic\" };this.setFaceCulling = function (a, b) {\n    a === THREE.CullFaceNone ? m.disable(m.CULL_FACE) : (b === THREE.FrontFaceDirectionCW ? m.frontFace(m.CW) : m.frontFace(m.CCW), a === THREE.CullFaceBack ? m.cullFace(m.BACK) : a === THREE.CullFaceFront ? m.cullFace(m.FRONT) : m.cullFace(m.FRONT_AND_BACK), m.enable(m.CULL_FACE));\n  };this.setMaterialFaces = function (a) {\n    W.setDoubleSided(a.side === THREE.DoubleSide);W.setFlipSided(a.side === THREE.BackSide);\n  };this.uploadTexture = function (a) {\n    void 0 === a.__webglInit && (a.__webglInit = !0, a.addEventListener(\"dispose\", Pb), a.__webglTexture = m.createTexture(), B.info.memory.textures++);m.bindTexture(m.TEXTURE_2D, a.__webglTexture);m.pixelStorei(m.UNPACK_FLIP_Y_WEBGL, a.flipY);m.pixelStorei(m.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultiplyAlpha);m.pixelStorei(m.UNPACK_ALIGNMENT, a.unpackAlignment);a.image = E(a.image, tc);var b = a.image,\n        c = THREE.Math.isPowerOfTwo(b.width) && THREE.Math.isPowerOfTwo(b.height),\n        d = I(a.format),\n        e = I(a.type);A(m.TEXTURE_2D, a, c);var f = a.mipmaps;if (a instanceof THREE.DataTexture) {\n      if (0 < f.length && c) {\n        for (var g = 0, h = f.length; g < h; g++) {\n          b = f[g], m.texImage2D(m.TEXTURE_2D, g, d, b.width, b.height, 0, d, e, b.data);\n        }a.generateMipmaps = !1;\n      } else m.texImage2D(m.TEXTURE_2D, 0, d, b.width, b.height, 0, d, e, b.data);\n    } else if (a instanceof THREE.CompressedTexture) for (g = 0, h = f.length; g < h; g++) {\n      b = f[g], a.format !== THREE.RGBAFormat && a.format !== THREE.RGBFormat ? -1 < kc().indexOf(d) ? m.compressedTexImage2D(m.TEXTURE_2D, g, d, b.width, b.height, 0, b.data) : THREE.warn(\"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()\") : m.texImage2D(m.TEXTURE_2D, g, d, b.width, b.height, 0, d, e, b.data);\n    } else if (0 < f.length && c) {\n      g = 0;for (h = f.length; g < h; g++) {\n        b = f[g], m.texImage2D(m.TEXTURE_2D, g, d, d, e, b);\n      }a.generateMipmaps = !1;\n    } else m.texImage2D(m.TEXTURE_2D, 0, d, d, e, a.image);\n    a.generateMipmaps && c && m.generateMipmap(m.TEXTURE_2D);a.needsUpdate = !1;if (a.onUpdate) a.onUpdate();\n  };this.setTexture = function (a, b) {\n    m.activeTexture(m.TEXTURE0 + b);a.needsUpdate ? B.uploadTexture(a) : m.bindTexture(m.TEXTURE_2D, a.__webglTexture);\n  };this.setRenderTarget = function (a) {\n    var b = a instanceof THREE.WebGLRenderTargetCube;if (a && void 0 === a.__webglFramebuffer) {\n      void 0 === a.depthBuffer && (a.depthBuffer = !0);void 0 === a.stencilBuffer && (a.stencilBuffer = !0);a.addEventListener(\"dispose\", oc);a.__webglTexture = m.createTexture();\n      B.info.memory.textures++;var c = THREE.Math.isPowerOfTwo(a.width) && THREE.Math.isPowerOfTwo(a.height),\n          d = I(a.format),\n          e = I(a.type);if (b) {\n        a.__webglFramebuffer = [];a.__webglRenderbuffer = [];m.bindTexture(m.TEXTURE_CUBE_MAP, a.__webglTexture);A(m.TEXTURE_CUBE_MAP, a, c);for (var f = 0; 6 > f; f++) {\n          a.__webglFramebuffer[f] = m.createFramebuffer();a.__webglRenderbuffer[f] = m.createRenderbuffer();m.texImage2D(m.TEXTURE_CUBE_MAP_POSITIVE_X + f, 0, d, a.width, a.height, 0, d, e, null);var g = a,\n              h = m.TEXTURE_CUBE_MAP_POSITIVE_X + f;m.bindFramebuffer(m.FRAMEBUFFER, a.__webglFramebuffer[f]);m.framebufferTexture2D(m.FRAMEBUFFER, m.COLOR_ATTACHMENT0, h, g.__webglTexture, 0);G(a.__webglRenderbuffer[f], a);\n        }c && m.generateMipmap(m.TEXTURE_CUBE_MAP);\n      } else a.__webglFramebuffer = m.createFramebuffer(), a.__webglRenderbuffer = a.shareDepthFrom ? a.shareDepthFrom.__webglRenderbuffer : m.createRenderbuffer(), m.bindTexture(m.TEXTURE_2D, a.__webglTexture), A(m.TEXTURE_2D, a, c), m.texImage2D(m.TEXTURE_2D, 0, d, a.width, a.height, 0, d, e, null), d = m.TEXTURE_2D, m.bindFramebuffer(m.FRAMEBUFFER, a.__webglFramebuffer), m.framebufferTexture2D(m.FRAMEBUFFER, m.COLOR_ATTACHMENT0, d, a.__webglTexture, 0), a.shareDepthFrom ? a.depthBuffer && !a.stencilBuffer ? m.framebufferRenderbuffer(m.FRAMEBUFFER, m.DEPTH_ATTACHMENT, m.RENDERBUFFER, a.__webglRenderbuffer) : a.depthBuffer && a.stencilBuffer && m.framebufferRenderbuffer(m.FRAMEBUFFER, m.DEPTH_STENCIL_ATTACHMENT, m.RENDERBUFFER, a.__webglRenderbuffer) : G(a.__webglRenderbuffer, a), c && m.generateMipmap(m.TEXTURE_2D);b ? m.bindTexture(m.TEXTURE_CUBE_MAP, null) : m.bindTexture(m.TEXTURE_2D, null);m.bindRenderbuffer(m.RENDERBUFFER, null);m.bindFramebuffer(m.FRAMEBUFFER, null);\n    }a ? (b = b ? a.__webglFramebuffer[a.activeCubeFace] : a.__webglFramebuffer, c = a.width, a = a.height, e = d = 0) : (b = null, c = pb, a = qb, d = ib, e = bb);b !== ab && (m.bindFramebuffer(m.FRAMEBUFFER, b), m.viewport(d, e, c, a), ab = b);Xb = c;fc = a;\n  };this.readRenderTargetPixels = function (a, b, c, d, e, f) {\n    if (!(a instanceof THREE.WebGLRenderTarget)) console.error(\"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.\");else if (a.__webglFramebuffer) if (a.format !== THREE.RGBAFormat) console.error(\"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA format. readPixels can read only RGBA format.\");else {\n      var g = !1;a.__webglFramebuffer !== ab && (m.bindFramebuffer(m.FRAMEBUFFER, a.__webglFramebuffer), g = !0);m.checkFramebufferStatus(m.FRAMEBUFFER) === m.FRAMEBUFFER_COMPLETE ? m.readPixels(b, c, d, e, m.RGBA, m.UNSIGNED_BYTE, f) : console.error(\"THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.\");g && m.bindFramebuffer(m.FRAMEBUFFER, ab);\n    }\n  };this.initMaterial = function () {\n    THREE.warn(\"THREE.WebGLRenderer: .initMaterial() has been removed.\");\n  };this.addPrePlugin = function () {\n    THREE.warn(\"THREE.WebGLRenderer: .addPrePlugin() has been removed.\");\n  };\n  this.addPostPlugin = function () {\n    THREE.warn(\"THREE.WebGLRenderer: .addPostPlugin() has been removed.\");\n  };this.updateShadowMap = function () {\n    THREE.warn(\"THREE.WebGLRenderer: .updateShadowMap() has been removed.\");\n  };\n};\nTHREE.WebGLRenderTarget = function (a, b, c) {\n  this.width = a;this.height = b;c = c || {};this.wrapS = void 0 !== c.wrapS ? c.wrapS : THREE.ClampToEdgeWrapping;this.wrapT = void 0 !== c.wrapT ? c.wrapT : THREE.ClampToEdgeWrapping;this.magFilter = void 0 !== c.magFilter ? c.magFilter : THREE.LinearFilter;this.minFilter = void 0 !== c.minFilter ? c.minFilter : THREE.LinearMipMapLinearFilter;this.anisotropy = void 0 !== c.anisotropy ? c.anisotropy : 1;this.offset = new THREE.Vector2(0, 0);this.repeat = new THREE.Vector2(1, 1);this.format = void 0 !== c.format ? c.format : THREE.RGBAFormat;this.type = void 0 !== c.type ? c.type : THREE.UnsignedByteType;this.depthBuffer = void 0 !== c.depthBuffer ? c.depthBuffer : !0;this.stencilBuffer = void 0 !== c.stencilBuffer ? c.stencilBuffer : !0;this.generateMipmaps = !0;this.shareDepthFrom = void 0 !== c.shareDepthFrom ? c.shareDepthFrom : null;\n};\nTHREE.WebGLRenderTarget.prototype = { constructor: THREE.WebGLRenderTarget, setSize: function setSize(a, b) {\n    this.width = a;this.height = b;\n  }, clone: function clone() {\n    var a = new THREE.WebGLRenderTarget(this.width, this.height);a.wrapS = this.wrapS;a.wrapT = this.wrapT;a.magFilter = this.magFilter;a.minFilter = this.minFilter;a.anisotropy = this.anisotropy;a.offset.copy(this.offset);a.repeat.copy(this.repeat);a.format = this.format;a.type = this.type;a.depthBuffer = this.depthBuffer;a.stencilBuffer = this.stencilBuffer;a.generateMipmaps = this.generateMipmaps;\n    a.shareDepthFrom = this.shareDepthFrom;return a;\n  }, dispose: function dispose() {\n    this.dispatchEvent({ type: \"dispose\" });\n  } };THREE.EventDispatcher.prototype.apply(THREE.WebGLRenderTarget.prototype);THREE.WebGLRenderTargetCube = function (a, b, c) {\n  THREE.WebGLRenderTarget.call(this, a, b, c);this.activeCubeFace = 0;\n};THREE.WebGLRenderTargetCube.prototype = Object.create(THREE.WebGLRenderTarget.prototype);THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;\nTHREE.WebGLExtensions = function (a) {\n  var b = {};this.get = function (c) {\n    if (void 0 !== b[c]) return b[c];var d;switch (c) {case \"EXT_texture_filter_anisotropic\":\n        d = a.getExtension(\"EXT_texture_filter_anisotropic\") || a.getExtension(\"MOZ_EXT_texture_filter_anisotropic\") || a.getExtension(\"WEBKIT_EXT_texture_filter_anisotropic\");break;case \"WEBGL_compressed_texture_s3tc\":\n        d = a.getExtension(\"WEBGL_compressed_texture_s3tc\") || a.getExtension(\"MOZ_WEBGL_compressed_texture_s3tc\") || a.getExtension(\"WEBKIT_WEBGL_compressed_texture_s3tc\");\n        break;case \"WEBGL_compressed_texture_pvrtc\":\n        d = a.getExtension(\"WEBGL_compressed_texture_pvrtc\") || a.getExtension(\"WEBKIT_WEBGL_compressed_texture_pvrtc\");break;default:\n        d = a.getExtension(c);}null === d && THREE.warn(\"THREE.WebGLRenderer: \" + c + \" extension not supported.\");return b[c] = d;\n  };\n};\nTHREE.WebGLProgram = function () {\n  var a = 0;return function (b, c, d, e) {\n    var f = b.context,\n        g = d.defines,\n        h = d.__webglShader.uniforms,\n        k = d.attributes,\n        l = d.__webglShader.vertexShader,\n        p = d.__webglShader.fragmentShader,\n        q = d.index0AttributeName;void 0 === q && !0 === e.morphTargets && (q = \"position\");var n = \"SHADOWMAP_TYPE_BASIC\";e.shadowMapType === THREE.PCFShadowMap ? n = \"SHADOWMAP_TYPE_PCF\" : e.shadowMapType === THREE.PCFSoftShadowMap && (n = \"SHADOWMAP_TYPE_PCF_SOFT\");var t = \"ENVMAP_TYPE_CUBE\",\n        r = \"ENVMAP_MODE_REFLECTION\",\n        s = \"ENVMAP_BLENDING_MULTIPLY\";\n    if (e.envMap) {\n      switch (d.envMap.mapping) {case THREE.CubeReflectionMapping:case THREE.CubeRefractionMapping:\n          t = \"ENVMAP_TYPE_CUBE\";break;case THREE.EquirectangularReflectionMapping:case THREE.EquirectangularRefractionMapping:\n          t = \"ENVMAP_TYPE_EQUIREC\";break;case THREE.SphericalReflectionMapping:\n          t = \"ENVMAP_TYPE_SPHERE\";}switch (d.envMap.mapping) {case THREE.CubeRefractionMapping:case THREE.EquirectangularRefractionMapping:\n          r = \"ENVMAP_MODE_REFRACTION\";}switch (d.combine) {case THREE.MultiplyOperation:\n          s = \"ENVMAP_BLENDING_MULTIPLY\";\n          break;case THREE.MixOperation:\n          s = \"ENVMAP_BLENDING_MIX\";break;case THREE.AddOperation:\n          s = \"ENVMAP_BLENDING_ADD\";}\n    }var u = 0 < b.gammaFactor ? b.gammaFactor : 1,\n        v,\n        x;v = [];for (var D in g) {\n      x = g[D], !1 !== x && (x = \"#define \" + D + \" \" + x, v.push(x));\n    }v = v.join(\"\\n\");g = f.createProgram();d instanceof THREE.RawShaderMaterial ? b = d = \"\" : (d = [\"precision \" + e.precision + \" float;\", \"precision \" + e.precision + \" int;\", v, e.supportsVertexTextures ? \"#define VERTEX_TEXTURES\" : \"\", b.gammaInput ? \"#define GAMMA_INPUT\" : \"\", b.gammaOutput ? \"#define GAMMA_OUTPUT\" : \"\", \"#define GAMMA_FACTOR \" + u, \"#define MAX_DIR_LIGHTS \" + e.maxDirLights, \"#define MAX_POINT_LIGHTS \" + e.maxPointLights, \"#define MAX_SPOT_LIGHTS \" + e.maxSpotLights, \"#define MAX_HEMI_LIGHTS \" + e.maxHemiLights, \"#define MAX_SHADOWS \" + e.maxShadows, \"#define MAX_BONES \" + e.maxBones, e.map ? \"#define USE_MAP\" : \"\", e.envMap ? \"#define USE_ENVMAP\" : \"\", e.envMap ? \"#define \" + r : \"\", e.lightMap ? \"#define USE_LIGHTMAP\" : \"\", e.bumpMap ? \"#define USE_BUMPMAP\" : \"\", e.normalMap ? \"#define USE_NORMALMAP\" : \"\", e.specularMap ? \"#define USE_SPECULARMAP\" : \"\", e.alphaMap ? \"#define USE_ALPHAMAP\" : \"\", e.vertexColors ? \"#define USE_COLOR\" : \"\", e.flatShading ? \"#define FLAT_SHADED\" : \"\", e.skinning ? \"#define USE_SKINNING\" : \"\", e.useVertexTexture ? \"#define BONE_TEXTURE\" : \"\", e.morphTargets ? \"#define USE_MORPHTARGETS\" : \"\", e.morphNormals ? \"#define USE_MORPHNORMALS\" : \"\", e.wrapAround ? \"#define WRAP_AROUND\" : \"\", e.doubleSided ? \"#define DOUBLE_SIDED\" : \"\", e.flipSided ? \"#define FLIP_SIDED\" : \"\", e.shadowMapEnabled ? \"#define USE_SHADOWMAP\" : \"\", e.shadowMapEnabled ? \"#define \" + n : \"\", e.shadowMapDebug ? \"#define SHADOWMAP_DEBUG\" : \"\", e.shadowMapCascade ? \"#define SHADOWMAP_CASCADE\" : \"\", e.sizeAttenuation ? \"#define USE_SIZEATTENUATION\" : \"\", e.logarithmicDepthBuffer ? \"#define USE_LOGDEPTHBUF\" : \"\", \"uniform mat4 modelMatrix;\\nuniform mat4 modelViewMatrix;\\nuniform mat4 projectionMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat3 normalMatrix;\\nuniform vec3 cameraPosition;\\nattribute vec3 position;\\nattribute vec3 normal;\\nattribute vec2 uv;\\nattribute vec2 uv2;\\n#ifdef USE_COLOR\\n\\tattribute vec3 color;\\n#endif\\n#ifdef USE_MORPHTARGETS\\n\\tattribute vec3 morphTarget0;\\n\\tattribute vec3 morphTarget1;\\n\\tattribute vec3 morphTarget2;\\n\\tattribute vec3 morphTarget3;\\n\\t#ifdef USE_MORPHNORMALS\\n\\t\\tattribute vec3 morphNormal0;\\n\\t\\tattribute vec3 morphNormal1;\\n\\t\\tattribute vec3 morphNormal2;\\n\\t\\tattribute vec3 morphNormal3;\\n\\t#else\\n\\t\\tattribute vec3 morphTarget4;\\n\\t\\tattribute vec3 morphTarget5;\\n\\t\\tattribute vec3 morphTarget6;\\n\\t\\tattribute vec3 morphTarget7;\\n\\t#endif\\n#endif\\n#ifdef USE_SKINNING\\n\\tattribute vec4 skinIndex;\\n\\tattribute vec4 skinWeight;\\n#endif\\n\"].join(\"\\n\"), b = [\"precision \" + e.precision + \" float;\", \"precision \" + e.precision + \" int;\", e.bumpMap || e.normalMap || e.flatShading ? \"#extension GL_OES_standard_derivatives : enable\" : \"\", v, \"#define MAX_DIR_LIGHTS \" + e.maxDirLights, \"#define MAX_POINT_LIGHTS \" + e.maxPointLights, \"#define MAX_SPOT_LIGHTS \" + e.maxSpotLights, \"#define MAX_HEMI_LIGHTS \" + e.maxHemiLights, \"#define MAX_SHADOWS \" + e.maxShadows, e.alphaTest ? \"#define ALPHATEST \" + e.alphaTest : \"\", b.gammaInput ? \"#define GAMMA_INPUT\" : \"\", b.gammaOutput ? \"#define GAMMA_OUTPUT\" : \"\", \"#define GAMMA_FACTOR \" + u, e.useFog && e.fog ? \"#define USE_FOG\" : \"\", e.useFog && e.fogExp ? \"#define FOG_EXP2\" : \"\", e.map ? \"#define USE_MAP\" : \"\", e.envMap ? \"#define USE_ENVMAP\" : \"\", e.envMap ? \"#define \" + t : \"\", e.envMap ? \"#define \" + r : \"\", e.envMap ? \"#define \" + s : \"\", e.lightMap ? \"#define USE_LIGHTMAP\" : \"\", e.bumpMap ? \"#define USE_BUMPMAP\" : \"\", e.normalMap ? \"#define USE_NORMALMAP\" : \"\", e.specularMap ? \"#define USE_SPECULARMAP\" : \"\", e.alphaMap ? \"#define USE_ALPHAMAP\" : \"\", e.vertexColors ? \"#define USE_COLOR\" : \"\", e.flatShading ? \"#define FLAT_SHADED\" : \"\", e.metal ? \"#define METAL\" : \"\", e.wrapAround ? \"#define WRAP_AROUND\" : \"\", e.doubleSided ? \"#define DOUBLE_SIDED\" : \"\", e.flipSided ? \"#define FLIP_SIDED\" : \"\", e.shadowMapEnabled ? \"#define USE_SHADOWMAP\" : \"\", e.shadowMapEnabled ? \"#define \" + n : \"\", e.shadowMapDebug ? \"#define SHADOWMAP_DEBUG\" : \"\", e.shadowMapCascade ? \"#define SHADOWMAP_CASCADE\" : \"\", e.logarithmicDepthBuffer ? \"#define USE_LOGDEPTHBUF\" : \"\", \"uniform mat4 viewMatrix;\\nuniform vec3 cameraPosition;\\n\"].join(\"\\n\"));l = new THREE.WebGLShader(f, f.VERTEX_SHADER, d + l);p = new THREE.WebGLShader(f, f.FRAGMENT_SHADER, b + p);f.attachShader(g, l);f.attachShader(g, p);void 0 !== q && f.bindAttribLocation(g, 0, q);f.linkProgram(g);q = f.getProgramInfoLog(g);!1 === f.getProgramParameter(g, f.LINK_STATUS) && THREE.error(\"THREE.WebGLProgram: shader error: \" + f.getError(), \"gl.VALIDATE_STATUS\", f.getProgramParameter(g, f.VALIDATE_STATUS), \"gl.getPRogramInfoLog\", q);\"\" !== q && THREE.warn(\"THREE.WebGLProgram: gl.getProgramInfoLog()\" + q);f.deleteShader(l);f.deleteShader(p);q = \"viewMatrix modelViewMatrix projectionMatrix normalMatrix modelMatrix cameraPosition morphTargetInfluences bindMatrix bindMatrixInverse\".split(\" \");\n    e.useVertexTexture ? (q.push(\"boneTexture\"), q.push(\"boneTextureWidth\"), q.push(\"boneTextureHeight\")) : q.push(\"boneGlobalMatrices\");e.logarithmicDepthBuffer && q.push(\"logDepthBufFC\");for (var w in h) {\n      q.push(w);\n    }h = q;w = {};q = 0;for (b = h.length; q < b; q++) {\n      n = h[q], w[n] = f.getUniformLocation(g, n);\n    }this.uniforms = w;q = \"position normal uv uv2 tangent color skinIndex skinWeight lineDistance\".split(\" \");for (h = 0; h < e.maxMorphTargets; h++) {\n      q.push(\"morphTarget\" + h);\n    }for (h = 0; h < e.maxMorphNormals; h++) {\n      q.push(\"morphNormal\" + h);\n    }for (var y in k) {\n      q.push(y);\n    }e = q;k = {};y = 0;for (h = e.length; y < h; y++) {\n      w = e[y], k[w] = f.getAttribLocation(g, w);\n    }this.attributes = k;this.attributesKeys = Object.keys(this.attributes);this.id = a++;this.code = c;this.usedTimes = 1;this.program = g;this.vertexShader = l;this.fragmentShader = p;return this;\n  };\n}();\nTHREE.WebGLShader = function () {\n  var a = function a(_a) {\n    _a = _a.split(\"\\n\");for (var c = 0; c < _a.length; c++) {\n      _a[c] = c + 1 + \": \" + _a[c];\n    }return _a.join(\"\\n\");\n  };return function (b, c, d) {\n    c = b.createShader(c);b.shaderSource(c, d);b.compileShader(c);!1 === b.getShaderParameter(c, b.COMPILE_STATUS) && THREE.error(\"THREE.WebGLShader: Shader couldn't compile.\");\"\" !== b.getShaderInfoLog(c) && THREE.warn(\"THREE.WebGLShader: gl.getShaderInfoLog()\", b.getShaderInfoLog(c), a(d));return c;\n  };\n}();\nTHREE.WebGLState = function (a, b) {\n  var c = new Uint8Array(16),\n      d = new Uint8Array(16),\n      e = null,\n      f = null,\n      g = null,\n      h = null,\n      k = null,\n      l = null,\n      p = null,\n      q = null,\n      n = null,\n      t = null,\n      r = null,\n      s = null,\n      u = null,\n      v = null,\n      x = null,\n      D = null;this.initAttributes = function () {\n    for (var a = 0, b = c.length; a < b; a++) {\n      c[a] = 0;\n    }\n  };this.enableAttribute = function (b) {\n    c[b] = 1;0 === d[b] && (a.enableVertexAttribArray(b), d[b] = 1);\n  };this.disableUnusedAttributes = function () {\n    for (var b = 0, e = d.length; b < e; b++) {\n      d[b] !== c[b] && (a.disableVertexAttribArray(b), d[b] = 0);\n    }\n  };this.setBlending = function (c, d, n, q, r, s, t) {\n    c !== e && (c === THREE.NoBlending ? a.disable(a.BLEND) : c === THREE.AdditiveBlending ? (a.enable(a.BLEND), a.blendEquation(a.FUNC_ADD), a.blendFunc(a.SRC_ALPHA, a.ONE)) : c === THREE.SubtractiveBlending ? (a.enable(a.BLEND), a.blendEquation(a.FUNC_ADD), a.blendFunc(a.ZERO, a.ONE_MINUS_SRC_COLOR)) : c === THREE.MultiplyBlending ? (a.enable(a.BLEND), a.blendEquation(a.FUNC_ADD), a.blendFunc(a.ZERO, a.SRC_COLOR)) : c === THREE.CustomBlending ? a.enable(a.BLEND) : (a.enable(a.BLEND), a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.SRC_ALPHA, a.ONE_MINUS_SRC_ALPHA, a.ONE, a.ONE_MINUS_SRC_ALPHA)), e = c);if (c === THREE.CustomBlending) {\n      r = r || d;s = s || n;t = t || q;if (d !== f || r !== k) a.blendEquationSeparate(b(d), b(r)), f = d, k = r;if (n !== g || q !== h || s !== l || t !== p) a.blendFuncSeparate(b(n), b(q), b(s), b(t)), g = n, h = q, l = s, p = t;\n    } else p = l = k = h = g = f = null;\n  };this.setDepthTest = function (b) {\n    q !== b && (b ? a.enable(a.DEPTH_TEST) : a.disable(a.DEPTH_TEST), q = b);\n  };this.setDepthWrite = function (b) {\n    n !== b && (a.depthMask(b), n = b);\n  };this.setColorWrite = function (b) {\n    t !== b && (a.colorMask(b, b, b, b), t = b);\n  };this.setDoubleSided = function (b) {\n    r !== b && (b ? a.disable(a.CULL_FACE) : a.enable(a.CULL_FACE), r = b);\n  };this.setFlipSided = function (b) {\n    s !== b && (b ? a.frontFace(a.CW) : a.frontFace(a.CCW), s = b);\n  };this.setLineWidth = function (b) {\n    b !== u && (a.lineWidth(b), u = b);\n  };this.setPolygonOffset = function (b, c, d) {\n    v !== b && (b ? a.enable(a.POLYGON_OFFSET_FILL) : a.disable(a.POLYGON_OFFSET_FILL), v = b);!b || x === c && D === d || (a.polygonOffset(c, d), x = c, D = d);\n  };this.reset = function () {\n    for (var a = 0; a < d.length; a++) {\n      d[a] = 0;\n    }s = r = t = n = q = e = null;\n  };\n};\nTHREE.LensFlarePlugin = function (a, b) {\n  var c,\n      d,\n      e,\n      f,\n      g,\n      h,\n      k,\n      l,\n      p,\n      q,\n      n = a.context,\n      t,\n      r,\n      s,\n      u,\n      v,\n      x;this.render = function (D, w, y, A) {\n    if (0 !== b.length) {\n      D = new THREE.Vector3();var E = A / y,\n          G = .5 * y,\n          F = .5 * A,\n          z = 16 / A,\n          I = new THREE.Vector2(z * E, z),\n          U = new THREE.Vector3(1, 1, 0),\n          M = new THREE.Vector2(1, 1);if (void 0 === s) {\n        var z = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1]),\n            H = new Uint16Array([0, 1, 2, 0, 2, 3]);t = n.createBuffer();r = n.createBuffer();n.bindBuffer(n.ARRAY_BUFFER, t);n.bufferData(n.ARRAY_BUFFER, z, n.STATIC_DRAW);n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, r);n.bufferData(n.ELEMENT_ARRAY_BUFFER, H, n.STATIC_DRAW);v = n.createTexture();x = n.createTexture();n.bindTexture(n.TEXTURE_2D, v);n.texImage2D(n.TEXTURE_2D, 0, n.RGB, 16, 16, 0, n.RGB, n.UNSIGNED_BYTE, null);n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE);n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE);n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, n.NEAREST);n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, n.NEAREST);n.bindTexture(n.TEXTURE_2D, x);n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, 16, 16, 0, n.RGBA, n.UNSIGNED_BYTE, null);n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE);n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE);n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, n.NEAREST);n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, n.NEAREST);var z = (u = 0 < n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS)) ? { vertexShader: \"uniform lowp int renderType;\\nuniform vec3 screenPosition;\\nuniform vec2 scale;\\nuniform float rotation;\\nuniform sampler2D occlusionMap;\\nattribute vec2 position;\\nattribute vec2 uv;\\nvarying vec2 vUV;\\nvarying float vVisibility;\\nvoid main() {\\nvUV = uv;\\nvec2 pos = position;\\nif( renderType == 2 ) {\\nvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\\nvVisibility =        visibility.r / 9.0;\\nvVisibility *= 1.0 - visibility.g / 9.0;\\nvVisibility *=       visibility.b / 9.0;\\nvVisibility *= 1.0 - visibility.a / 9.0;\\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\\n}\\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\\n}\",\n          fragmentShader: \"uniform lowp int renderType;\\nuniform sampler2D map;\\nuniform float opacity;\\nuniform vec3 color;\\nvarying vec2 vUV;\\nvarying float vVisibility;\\nvoid main() {\\nif( renderType == 0 ) {\\ngl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\\n} else if( renderType == 1 ) {\\ngl_FragColor = texture2D( map, vUV );\\n} else {\\nvec4 texture = texture2D( map, vUV );\\ntexture.a *= opacity * vVisibility;\\ngl_FragColor = texture;\\ngl_FragColor.rgb *= color;\\n}\\n}\" } : { vertexShader: \"uniform lowp int renderType;\\nuniform vec3 screenPosition;\\nuniform vec2 scale;\\nuniform float rotation;\\nattribute vec2 position;\\nattribute vec2 uv;\\nvarying vec2 vUV;\\nvoid main() {\\nvUV = uv;\\nvec2 pos = position;\\nif( renderType == 2 ) {\\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\\n}\\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\\n}\",\n          fragmentShader: \"precision mediump float;\\nuniform lowp int renderType;\\nuniform sampler2D map;\\nuniform sampler2D occlusionMap;\\nuniform float opacity;\\nuniform vec3 color;\\nvarying vec2 vUV;\\nvoid main() {\\nif( renderType == 0 ) {\\ngl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );\\n} else if( renderType == 1 ) {\\ngl_FragColor = texture2D( map, vUV );\\n} else {\\nfloat visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;\\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;\\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;\\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;\\nvisibility = ( 1.0 - visibility / 4.0 );\\nvec4 texture = texture2D( map, vUV );\\ntexture.a *= opacity * visibility;\\ngl_FragColor = texture;\\ngl_FragColor.rgb *= color;\\n}\\n}\" },\n            H = n.createProgram(),\n            L = n.createShader(n.FRAGMENT_SHADER),\n            P = n.createShader(n.VERTEX_SHADER),\n            N = \"precision \" + a.getPrecision() + \" float;\\n\";n.shaderSource(L, N + z.fragmentShader);n.shaderSource(P, N + z.vertexShader);n.compileShader(L);n.compileShader(P);n.attachShader(H, L);n.attachShader(H, P);n.linkProgram(H);s = H;p = n.getAttribLocation(s, \"position\");q = n.getAttribLocation(s, \"uv\");c = n.getUniformLocation(s, \"renderType\");d = n.getUniformLocation(s, \"map\");e = n.getUniformLocation(s, \"occlusionMap\");f = n.getUniformLocation(s, \"opacity\");g = n.getUniformLocation(s, \"color\");h = n.getUniformLocation(s, \"scale\");k = n.getUniformLocation(s, \"rotation\");l = n.getUniformLocation(s, \"screenPosition\");\n      }n.useProgram(s);n.enableVertexAttribArray(p);n.enableVertexAttribArray(q);n.uniform1i(e, 0);n.uniform1i(d, 1);n.bindBuffer(n.ARRAY_BUFFER, t);n.vertexAttribPointer(p, 2, n.FLOAT, !1, 16, 0);n.vertexAttribPointer(q, 2, n.FLOAT, !1, 16, 8);n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, r);n.disable(n.CULL_FACE);n.depthMask(!1);H = 0;for (L = b.length; H < L; H++) {\n        if (z = 16 / A, I.set(z * E, z), P = b[H], D.set(P.matrixWorld.elements[12], P.matrixWorld.elements[13], P.matrixWorld.elements[14]), D.applyMatrix4(w.matrixWorldInverse), D.applyProjection(w.projectionMatrix), U.copy(D), M.x = U.x * G + G, M.y = U.y * F + F, u || 0 < M.x && M.x < y && 0 < M.y && M.y < A) {\n          n.activeTexture(n.TEXTURE1);n.bindTexture(n.TEXTURE_2D, v);n.copyTexImage2D(n.TEXTURE_2D, 0, n.RGB, M.x - 8, M.y - 8, 16, 16, 0);n.uniform1i(c, 0);n.uniform2f(h, I.x, I.y);n.uniform3f(l, U.x, U.y, U.z);n.disable(n.BLEND);n.enable(n.DEPTH_TEST);n.drawElements(n.TRIANGLES, 6, n.UNSIGNED_SHORT, 0);n.activeTexture(n.TEXTURE0);n.bindTexture(n.TEXTURE_2D, x);n.copyTexImage2D(n.TEXTURE_2D, 0, n.RGBA, M.x - 8, M.y - 8, 16, 16, 0);n.uniform1i(c, 1);n.disable(n.DEPTH_TEST);n.activeTexture(n.TEXTURE1);n.bindTexture(n.TEXTURE_2D, v);n.drawElements(n.TRIANGLES, 6, n.UNSIGNED_SHORT, 0);P.positionScreen.copy(U);P.customUpdateCallback ? P.customUpdateCallback(P) : P.updateLensFlares();n.uniform1i(c, 2);n.enable(n.BLEND);for (var N = 0, R = P.lensFlares.length; N < R; N++) {\n            var V = P.lensFlares[N];.001 < V.opacity && .001 < V.scale && (U.x = V.x, U.y = V.y, U.z = V.z, z = V.size * V.scale / A, I.x = z * E, I.y = z, n.uniform3f(l, U.x, U.y, U.z), n.uniform2f(h, I.x, I.y), n.uniform1f(k, V.rotation), n.uniform1f(f, V.opacity), n.uniform3f(g, V.color.r, V.color.g, V.color.b), a.state.setBlending(V.blending, V.blendEquation, V.blendSrc, V.blendDst), a.setTexture(V.texture, 1), n.drawElements(n.TRIANGLES, 6, n.UNSIGNED_SHORT, 0));\n          }\n        }\n      }n.enable(n.CULL_FACE);n.enable(n.DEPTH_TEST);n.depthMask(!0);a.resetGLState();\n    }\n  };\n};\nTHREE.ShadowMapPlugin = function (a, b, c, d) {\n  function e(a, b, d) {\n    if (b.visible) {\n      var f = c[b.id];if (f && b.castShadow && (!1 === b.frustumCulled || !0 === p.intersectsObject(b))) for (var g = 0, h = f.length; g < h; g++) {\n        var k = f[g];b._modelViewMatrix.multiplyMatrices(d.matrixWorldInverse, b.matrixWorld);s.push(k);\n      }g = 0;for (h = b.children.length; g < h; g++) {\n        e(a, b.children[g], d);\n      }\n    }\n  }var f = a.context,\n      g,\n      h,\n      k,\n      l,\n      p = new THREE.Frustum(),\n      q = new THREE.Matrix4(),\n      n = new THREE.Vector3(),\n      t = new THREE.Vector3(),\n      r = new THREE.Vector3(),\n      s = [],\n      u = THREE.ShaderLib.depthRGBA,\n      v = THREE.UniformsUtils.clone(u.uniforms);\n  g = new THREE.ShaderMaterial({ uniforms: v, vertexShader: u.vertexShader, fragmentShader: u.fragmentShader });h = new THREE.ShaderMaterial({ uniforms: v, vertexShader: u.vertexShader, fragmentShader: u.fragmentShader, morphTargets: !0 });k = new THREE.ShaderMaterial({ uniforms: v, vertexShader: u.vertexShader, fragmentShader: u.fragmentShader, skinning: !0 });l = new THREE.ShaderMaterial({ uniforms: v, vertexShader: u.vertexShader, fragmentShader: u.fragmentShader, morphTargets: !0, skinning: !0 });g._shadowPass = !0;h._shadowPass = !0;k._shadowPass = !0;l._shadowPass = !0;this.render = function (c, v) {\n    if (!1 !== a.shadowMapEnabled) {\n      var u,\n          y,\n          A,\n          E,\n          G,\n          F,\n          z,\n          I,\n          U = [];E = 0;f.clearColor(1, 1, 1, 1);f.disable(f.BLEND);f.enable(f.CULL_FACE);f.frontFace(f.CCW);a.shadowMapCullFace === THREE.CullFaceFront ? f.cullFace(f.FRONT) : f.cullFace(f.BACK);a.state.setDepthTest(!0);u = 0;for (y = b.length; u < y; u++) {\n        if (A = b[u], A.castShadow) if (A instanceof THREE.DirectionalLight && A.shadowCascade) for (G = 0; G < A.shadowCascadeCount; G++) {\n          var M;if (A.shadowCascadeArray[G]) M = A.shadowCascadeArray[G];else {\n            z = A;\n            var H = G;M = new THREE.DirectionalLight();M.isVirtual = !0;M.onlyShadow = !0;M.castShadow = !0;M.shadowCameraNear = z.shadowCameraNear;M.shadowCameraFar = z.shadowCameraFar;M.shadowCameraLeft = z.shadowCameraLeft;M.shadowCameraRight = z.shadowCameraRight;M.shadowCameraBottom = z.shadowCameraBottom;M.shadowCameraTop = z.shadowCameraTop;M.shadowCameraVisible = z.shadowCameraVisible;M.shadowDarkness = z.shadowDarkness;M.shadowBias = z.shadowCascadeBias[H];M.shadowMapWidth = z.shadowCascadeWidth[H];M.shadowMapHeight = z.shadowCascadeHeight[H];\n            M.pointsWorld = [];M.pointsFrustum = [];I = M.pointsWorld;F = M.pointsFrustum;for (var L = 0; 8 > L; L++) {\n              I[L] = new THREE.Vector3(), F[L] = new THREE.Vector3();\n            }I = z.shadowCascadeNearZ[H];z = z.shadowCascadeFarZ[H];F[0].set(-1, -1, I);F[1].set(1, -1, I);F[2].set(-1, 1, I);F[3].set(1, 1, I);F[4].set(-1, -1, z);F[5].set(1, -1, z);F[6].set(-1, 1, z);F[7].set(1, 1, z);M.originalCamera = v;F = new THREE.Gyroscope();F.position.copy(A.shadowCascadeOffset);F.add(M);F.add(M.target);v.add(F);A.shadowCascadeArray[G] = M;\n          }H = A;I = G;z = H.shadowCascadeArray[I];z.position.copy(H.position);\n          z.target.position.copy(H.target.position);z.lookAt(z.target);z.shadowCameraVisible = H.shadowCameraVisible;z.shadowDarkness = H.shadowDarkness;z.shadowBias = H.shadowCascadeBias[I];F = H.shadowCascadeNearZ[I];H = H.shadowCascadeFarZ[I];z = z.pointsFrustum;z[0].z = F;z[1].z = F;z[2].z = F;z[3].z = F;z[4].z = H;z[5].z = H;z[6].z = H;z[7].z = H;U[E] = M;E++;\n        } else U[E] = A, E++;\n      }u = 0;for (y = U.length; u < y; u++) {\n        A = U[u];A.shadowMap || (G = THREE.LinearFilter, a.shadowMapType === THREE.PCFSoftShadowMap && (G = THREE.NearestFilter), A.shadowMap = new THREE.WebGLRenderTarget(A.shadowMapWidth, A.shadowMapHeight, { minFilter: G, magFilter: G, format: THREE.RGBAFormat }), A.shadowMapSize = new THREE.Vector2(A.shadowMapWidth, A.shadowMapHeight), A.shadowMatrix = new THREE.Matrix4());if (!A.shadowCamera) {\n          if (A instanceof THREE.SpotLight) A.shadowCamera = new THREE.PerspectiveCamera(A.shadowCameraFov, A.shadowMapWidth / A.shadowMapHeight, A.shadowCameraNear, A.shadowCameraFar);else if (A instanceof THREE.DirectionalLight) A.shadowCamera = new THREE.OrthographicCamera(A.shadowCameraLeft, A.shadowCameraRight, A.shadowCameraTop, A.shadowCameraBottom, A.shadowCameraNear, A.shadowCameraFar);else {\n            THREE.error(\"THREE.ShadowMapPlugin: Unsupported light type for shadow\", A);continue;\n          }c.add(A.shadowCamera);!0 === c.autoUpdate && c.updateMatrixWorld();\n        }A.shadowCameraVisible && !A.cameraHelper && (A.cameraHelper = new THREE.CameraHelper(A.shadowCamera), c.add(A.cameraHelper));if (A.isVirtual && M.originalCamera == v) {\n          G = v;E = A.shadowCamera;F = A.pointsFrustum;z = A.pointsWorld;n.set(Infinity, Infinity, Infinity);t.set(-Infinity, -Infinity, -Infinity);for (H = 0; 8 > H; H++) {\n            I = z[H], I.copy(F[H]), I.unproject(G), I.applyMatrix4(E.matrixWorldInverse), I.x < n.x && (n.x = I.x), I.x > t.x && (t.x = I.x), I.y < n.y && (n.y = I.y), I.y > t.y && (t.y = I.y), I.z < n.z && (n.z = I.z), I.z > t.z && (t.z = I.z);\n          }E.left = n.x;E.right = t.x;E.top = t.y;E.bottom = n.y;E.updateProjectionMatrix();\n        }E = A.shadowMap;F = A.shadowMatrix;G = A.shadowCamera;G.position.setFromMatrixPosition(A.matrixWorld);r.setFromMatrixPosition(A.target.matrixWorld);G.lookAt(r);G.updateMatrixWorld();G.matrixWorldInverse.getInverse(G.matrixWorld);A.cameraHelper && (A.cameraHelper.visible = A.shadowCameraVisible);A.shadowCameraVisible && A.cameraHelper.update();F.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1);F.multiply(G.projectionMatrix);F.multiply(G.matrixWorldInverse);q.multiplyMatrices(G.projectionMatrix, G.matrixWorldInverse);p.setFromMatrix(q);a.setRenderTarget(E);a.clear();s.length = 0;e(c, c, G);A = 0;for (E = s.length; A < E; A++) {\n          z = s[A], F = z.object, z = z.buffer, H = F.material instanceof THREE.MeshFaceMaterial ? F.material.materials[0] : F.material, I = void 0 !== F.geometry.morphTargets && 0 < F.geometry.morphTargets.length && H.morphTargets, L = F instanceof THREE.SkinnedMesh && H.skinning, I = F.customDepthMaterial ? F.customDepthMaterial : L ? I ? l : k : I ? h : g, a.setMaterialFaces(H), z instanceof THREE.BufferGeometry ? a.renderBufferDirect(G, b, null, I, z, F) : a.renderBuffer(G, b, null, I, z, F);\n        }A = 0;for (E = d.length; A < E; A++) {\n          z = d[A], F = z.object, F.visible && F.castShadow && (F._modelViewMatrix.multiplyMatrices(G.matrixWorldInverse, F.matrixWorld), a.renderImmediateObject(G, b, null, g, F));\n        }\n      }u = a.getClearColor();y = a.getClearAlpha();f.clearColor(u.r, u.g, u.b, y);f.enable(f.BLEND);a.shadowMapCullFace === THREE.CullFaceFront && f.cullFace(f.BACK);a.resetGLState();\n    }\n  };\n};\nTHREE.SpritePlugin = function (a, b) {\n  var c, d, e, f, g, h, k, l, p, q, n, t, r, s, u, v, x;function D(a, b) {\n    return a.z !== b.z ? b.z - a.z : b.id - a.id;\n  }var w = a.context,\n      y,\n      A,\n      E,\n      G,\n      F = new THREE.Vector3(),\n      z = new THREE.Quaternion(),\n      I = new THREE.Vector3();this.render = function (U, M) {\n    if (0 !== b.length) {\n      if (void 0 === E) {\n        var H = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1]),\n            L = new Uint16Array([0, 1, 2, 0, 2, 3]);y = w.createBuffer();A = w.createBuffer();w.bindBuffer(w.ARRAY_BUFFER, y);w.bufferData(w.ARRAY_BUFFER, H, w.STATIC_DRAW);w.bindBuffer(w.ELEMENT_ARRAY_BUFFER, A);w.bufferData(w.ELEMENT_ARRAY_BUFFER, L, w.STATIC_DRAW);var H = w.createProgram(),\n            L = w.createShader(w.VERTEX_SHADER),\n            P = w.createShader(w.FRAGMENT_SHADER);w.shaderSource(L, [\"precision \" + a.getPrecision() + \" float;\", \"uniform mat4 modelViewMatrix;\\nuniform mat4 projectionMatrix;\\nuniform float rotation;\\nuniform vec2 scale;\\nuniform vec2 uvOffset;\\nuniform vec2 uvScale;\\nattribute vec2 position;\\nattribute vec2 uv;\\nvarying vec2 vUV;\\nvoid main() {\\nvUV = uvOffset + uv * uvScale;\\nvec2 alignedPosition = position * scale;\\nvec2 rotatedPosition;\\nrotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\\nrotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\\nvec4 finalPosition;\\nfinalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\\nfinalPosition.xy += rotatedPosition;\\nfinalPosition = projectionMatrix * finalPosition;\\ngl_Position = finalPosition;\\n}\"].join(\"\\n\"));\n        w.shaderSource(P, [\"precision \" + a.getPrecision() + \" float;\", \"uniform vec3 color;\\nuniform sampler2D map;\\nuniform float opacity;\\nuniform int fogType;\\nuniform vec3 fogColor;\\nuniform float fogDensity;\\nuniform float fogNear;\\nuniform float fogFar;\\nuniform float alphaTest;\\nvarying vec2 vUV;\\nvoid main() {\\nvec4 texture = texture2D( map, vUV );\\nif ( texture.a < alphaTest ) discard;\\ngl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\\nif ( fogType > 0 ) {\\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\nfloat fogFactor = 0.0;\\nif ( fogType == 1 ) {\\nfogFactor = smoothstep( fogNear, fogFar, depth );\\n} else {\\nconst float LOG2 = 1.442695;\\nfloat fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\\n}\\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\\n}\\n}\"].join(\"\\n\"));\n        w.compileShader(L);w.compileShader(P);w.attachShader(H, L);w.attachShader(H, P);w.linkProgram(H);E = H;v = w.getAttribLocation(E, \"position\");x = w.getAttribLocation(E, \"uv\");c = w.getUniformLocation(E, \"uvOffset\");d = w.getUniformLocation(E, \"uvScale\");e = w.getUniformLocation(E, \"rotation\");f = w.getUniformLocation(E, \"scale\");g = w.getUniformLocation(E, \"color\");h = w.getUniformLocation(E, \"map\");k = w.getUniformLocation(E, \"opacity\");l = w.getUniformLocation(E, \"modelViewMatrix\");p = w.getUniformLocation(E, \"projectionMatrix\");q = w.getUniformLocation(E, \"fogType\");n = w.getUniformLocation(E, \"fogDensity\");t = w.getUniformLocation(E, \"fogNear\");r = w.getUniformLocation(E, \"fogFar\");s = w.getUniformLocation(E, \"fogColor\");u = w.getUniformLocation(E, \"alphaTest\");H = document.createElement(\"canvas\");H.width = 8;H.height = 8;L = H.getContext(\"2d\");L.fillStyle = \"white\";L.fillRect(0, 0, 8, 8);G = new THREE.Texture(H);G.needsUpdate = !0;\n      }w.useProgram(E);w.enableVertexAttribArray(v);w.enableVertexAttribArray(x);w.disable(w.CULL_FACE);w.enable(w.BLEND);w.bindBuffer(w.ARRAY_BUFFER, y);w.vertexAttribPointer(v, 2, w.FLOAT, !1, 16, 0);w.vertexAttribPointer(x, 2, w.FLOAT, !1, 16, 8);w.bindBuffer(w.ELEMENT_ARRAY_BUFFER, A);w.uniformMatrix4fv(p, !1, M.projectionMatrix.elements);w.activeTexture(w.TEXTURE0);w.uniform1i(h, 0);L = H = 0;(P = U.fog) ? (w.uniform3f(s, P.color.r, P.color.g, P.color.b), P instanceof THREE.Fog ? (w.uniform1f(t, P.near), w.uniform1f(r, P.far), w.uniform1i(q, 1), L = H = 1) : P instanceof THREE.FogExp2 && (w.uniform1f(n, P.density), w.uniform1i(q, 2), L = H = 2)) : (w.uniform1i(q, 0), L = H = 0);for (var P = 0, N = b.length; P < N; P++) {\n        var R = b[P];R._modelViewMatrix.multiplyMatrices(M.matrixWorldInverse, R.matrixWorld);R.z = -R._modelViewMatrix.elements[14];\n      }b.sort(D);for (var V = [], P = 0, N = b.length; P < N; P++) {\n        var R = b[P],\n            J = R.material;w.uniform1f(u, J.alphaTest);w.uniformMatrix4fv(l, !1, R._modelViewMatrix.elements);R.matrixWorld.decompose(F, z, I);V[0] = I.x;V[1] = I.y;R = 0;U.fog && J.fog && (R = L);H !== R && (w.uniform1i(q, R), H = R);null !== J.map ? (w.uniform2f(c, J.map.offset.x, J.map.offset.y), w.uniform2f(d, J.map.repeat.x, J.map.repeat.y)) : (w.uniform2f(c, 0, 0), w.uniform2f(d, 1, 1));w.uniform1f(k, J.opacity);w.uniform3f(g, J.color.r, J.color.g, J.color.b);w.uniform1f(e, J.rotation);w.uniform2fv(f, V);a.state.setBlending(J.blending, J.blendEquation, J.blendSrc, J.blendDst);a.state.setDepthTest(J.depthTest);a.state.setDepthWrite(J.depthWrite);J.map && J.map.image && J.map.image.width ? a.setTexture(J.map, 0) : a.setTexture(G, 0);w.drawElements(w.TRIANGLES, 6, w.UNSIGNED_SHORT, 0);\n      }w.enable(w.CULL_FACE);a.resetGLState();\n    }\n  };\n};\nTHREE.GeometryUtils = { merge: function merge(a, b, c) {\n    THREE.warn(\"THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.\");var d;b instanceof THREE.Mesh && (b.matrixAutoUpdate && b.updateMatrix(), d = b.matrix, b = b.geometry);a.merge(b, d, c);\n  }, center: function center(a) {\n    THREE.warn(\"THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.\");return a.center();\n  } };\nTHREE.ImageUtils = { crossOrigin: void 0, loadTexture: function loadTexture(a, b, c, d) {\n    var e = new THREE.ImageLoader();e.crossOrigin = this.crossOrigin;var f = new THREE.Texture(void 0, b);e.load(a, function (a) {\n      f.image = a;f.needsUpdate = !0;c && c(f);\n    }, void 0, function (a) {\n      d && d(a);\n    });f.sourceFile = a;return f;\n  }, loadTextureCube: function loadTextureCube(a, b, c, d) {\n    var e = new THREE.ImageLoader();e.crossOrigin = this.crossOrigin;var f = new THREE.CubeTexture([], b);f.flipY = !1;var g = 0;b = function b(_b2) {\n      e.load(a[_b2], function (a) {\n        f.images[_b2] = a;g += 1;6 === g && (f.needsUpdate = !0, c && c(f));\n      }, void 0, d);\n    };for (var h = 0, k = a.length; h < k; ++h) {\n      b(h);\n    }return f;\n  }, loadCompressedTexture: function loadCompressedTexture() {\n    THREE.error(\"THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.\");\n  }, loadCompressedTextureCube: function loadCompressedTextureCube() {\n    THREE.error(\"THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.\");\n  }, getNormalMap: function getNormalMap(a, b) {\n    var c = function c(a) {\n      var b = Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);return [a[0] / b, a[1] / b, a[2] / b];\n    };b |= 1;var d = a.width,\n        e = a.height,\n        f = document.createElement(\"canvas\");\n    f.width = d;f.height = e;var g = f.getContext(\"2d\");g.drawImage(a, 0, 0);for (var h = g.getImageData(0, 0, d, e).data, k = g.createImageData(d, e), l = k.data, p = 0; p < d; p++) {\n      for (var q = 0; q < e; q++) {\n        var n = 0 > q - 1 ? 0 : q - 1,\n            t = q + 1 > e - 1 ? e - 1 : q + 1,\n            r = 0 > p - 1 ? 0 : p - 1,\n            s = p + 1 > d - 1 ? d - 1 : p + 1,\n            u = [],\n            v = [0, 0, h[4 * (q * d + p)] / 255 * b];u.push([-1, 0, h[4 * (q * d + r)] / 255 * b]);u.push([-1, -1, h[4 * (n * d + r)] / 255 * b]);u.push([0, -1, h[4 * (n * d + p)] / 255 * b]);u.push([1, -1, h[4 * (n * d + s)] / 255 * b]);u.push([1, 0, h[4 * (q * d + s)] / 255 * b]);u.push([1, 1, h[4 * (t * d + s)] / 255 * b]);u.push([0, 1, h[4 * (t * d + p)] / 255 * b]);u.push([-1, 1, h[4 * (t * d + r)] / 255 * b]);n = [];r = u.length;for (t = 0; t < r; t++) {\n          var s = u[t],\n              x = u[(t + 1) % r],\n              s = [s[0] - v[0], s[1] - v[1], s[2] - v[2]],\n              x = [x[0] - v[0], x[1] - v[1], x[2] - v[2]];n.push(c([s[1] * x[2] - s[2] * x[1], s[2] * x[0] - s[0] * x[2], s[0] * x[1] - s[1] * x[0]]));\n        }u = [0, 0, 0];for (t = 0; t < n.length; t++) {\n          u[0] += n[t][0], u[1] += n[t][1], u[2] += n[t][2];\n        }u[0] /= n.length;u[1] /= n.length;u[2] /= n.length;v = 4 * (q * d + p);l[v] = (u[0] + 1) / 2 * 255 | 0;l[v + 1] = (u[1] + 1) / 2 * 255 | 0;l[v + 2] = 255 * u[2] | 0;l[v + 3] = 255;\n      }\n    }g.putImageData(k, 0, 0);return f;\n  }, generateDataTexture: function generateDataTexture(a, b, c) {\n    var d = a * b,\n        e = new Uint8Array(3 * d),\n        f = Math.floor(255 * c.r),\n        g = Math.floor(255 * c.g);c = Math.floor(255 * c.b);for (var h = 0; h < d; h++) {\n      e[3 * h] = f, e[3 * h + 1] = g, e[3 * h + 2] = c;\n    }a = new THREE.DataTexture(e, a, b, THREE.RGBFormat);a.needsUpdate = !0;return a;\n  } };\nTHREE.SceneUtils = { createMultiMaterialObject: function createMultiMaterialObject(a, b) {\n    for (var c = new THREE.Object3D(), d = 0, e = b.length; d < e; d++) {\n      c.add(new THREE.Mesh(a, b[d]));\n    }return c;\n  }, detach: function detach(a, b, c) {\n    a.applyMatrix(b.matrixWorld);b.remove(a);c.add(a);\n  }, attach: function attach(a, b, c) {\n    var d = new THREE.Matrix4();d.getInverse(c.matrixWorld);a.applyMatrix(d);b.remove(a);c.add(a);\n  } };\nTHREE.FontUtils = { faces: {}, face: \"helvetiker\", weight: \"normal\", style: \"normal\", size: 150, divisions: 10, getFace: function getFace() {\n    try {\n      return this.faces[this.face][this.weight][this.style];\n    } catch (a) {\n      throw \"The font \" + this.face + \" with \" + this.weight + \" weight and \" + this.style + \" style is missing.\";\n    }\n  }, loadFace: function loadFace(a) {\n    var b = a.familyName.toLowerCase();this.faces[b] = this.faces[b] || {};this.faces[b][a.cssFontWeight] = this.faces[b][a.cssFontWeight] || {};this.faces[b][a.cssFontWeight][a.cssFontStyle] = a;return this.faces[b][a.cssFontWeight][a.cssFontStyle] = a;\n  }, drawText: function drawText(a) {\n    var b = this.getFace(),\n        c = this.size / b.resolution,\n        d = 0,\n        e = String(a).split(\"\"),\n        f = e.length,\n        g = [];for (a = 0; a < f; a++) {\n      var h = new THREE.Path(),\n          h = this.extractGlyphPoints(e[a], b, c, d, h),\n          d = d + h.offset;g.push(h.path);\n    }return { paths: g, offset: d / 2 };\n  }, extractGlyphPoints: function extractGlyphPoints(a, b, c, d, e) {\n    var f = [],\n        g,\n        h,\n        k,\n        l,\n        p,\n        q,\n        n,\n        t,\n        r,\n        s,\n        u,\n        v = b.glyphs[a] || b.glyphs[\"?\"];if (v) {\n      if (v.o) for (b = v._cachedOutline || (v._cachedOutline = v.o.split(\" \")), l = b.length, a = 0; a < l;) {\n        switch (k = b[a++], k) {case \"m\":\n            k = b[a++] * c + d;p = b[a++] * c;e.moveTo(k, p);\n            break;case \"l\":\n            k = b[a++] * c + d;p = b[a++] * c;e.lineTo(k, p);break;case \"q\":\n            k = b[a++] * c + d;p = b[a++] * c;t = b[a++] * c + d;r = b[a++] * c;e.quadraticCurveTo(t, r, k, p);if (g = f[f.length - 1]) for (q = g.x, n = g.y, g = 1, h = this.divisions; g <= h; g++) {\n              var x = g / h;THREE.Shape.Utils.b2(x, q, t, k);THREE.Shape.Utils.b2(x, n, r, p);\n            }break;case \"b\":\n            if (k = b[a++] * c + d, p = b[a++] * c, t = b[a++] * c + d, r = b[a++] * c, s = b[a++] * c + d, u = b[a++] * c, e.bezierCurveTo(t, r, s, u, k, p), g = f[f.length - 1]) for (q = g.x, n = g.y, g = 1, h = this.divisions; g <= h; g++) {\n              x = g / h, THREE.Shape.Utils.b3(x, q, t, s, k), THREE.Shape.Utils.b3(x, n, r, u, p);\n            }}\n      }return { offset: v.ha * c, path: e };\n    }\n  } };\nTHREE.FontUtils.generateShapes = function (a, b) {\n  b = b || {};var c = void 0 !== b.curveSegments ? b.curveSegments : 4,\n      d = void 0 !== b.font ? b.font : \"helvetiker\",\n      e = void 0 !== b.weight ? b.weight : \"normal\",\n      f = void 0 !== b.style ? b.style : \"normal\";THREE.FontUtils.size = void 0 !== b.size ? b.size : 100;THREE.FontUtils.divisions = c;THREE.FontUtils.face = d;THREE.FontUtils.weight = e;THREE.FontUtils.style = f;c = THREE.FontUtils.drawText(a).paths;d = [];e = 0;for (f = c.length; e < f; e++) {\n    Array.prototype.push.apply(d, c[e].toShapes());\n  }return d;\n};\n(function (a) {\n  var b = function b(a) {\n    for (var b = a.length, e = 0, f = b - 1, g = 0; g < b; f = g++) {\n      e += a[f].x * a[g].y - a[g].x * a[f].y;\n    }return .5 * e;\n  };a.Triangulate = function (a, d) {\n    var e = a.length;if (3 > e) return null;var f = [],\n        g = [],\n        h = [],\n        k,\n        l,\n        p;if (0 < b(a)) for (l = 0; l < e; l++) {\n      g[l] = l;\n    } else for (l = 0; l < e; l++) {\n      g[l] = e - 1 - l;\n    }var q = 2 * e;for (l = e - 1; 2 < e;) {\n      if (0 >= q--) {\n        THREE.warn(\"THREE.FontUtils: Warning, unable to triangulate polygon! in Triangulate.process()\");break;\n      }k = l;e <= k && (k = 0);l = k + 1;e <= l && (l = 0);p = l + 1;e <= p && (p = 0);var n;a: {\n        var t = n = void 0,\n            r = void 0,\n            s = void 0,\n            u = void 0,\n            v = void 0,\n            x = void 0,\n            D = void 0,\n            w = void 0,\n            t = a[g[k]].x,\n            r = a[g[k]].y,\n            s = a[g[l]].x,\n            u = a[g[l]].y,\n            v = a[g[p]].x,\n            x = a[g[p]].y;if (1E-10 > (s - t) * (x - r) - (u - r) * (v - t)) n = !1;else {\n          var y = void 0,\n              A = void 0,\n              E = void 0,\n              G = void 0,\n              F = void 0,\n              z = void 0,\n              I = void 0,\n              U = void 0,\n              M = void 0,\n              H = void 0,\n              M = U = I = w = D = void 0,\n              y = v - s,\n              A = x - u,\n              E = t - v,\n              G = r - x,\n              F = s - t,\n              z = u - r;for (n = 0; n < e; n++) {\n            if (D = a[g[n]].x, w = a[g[n]].y, !(D === t && w === r || D === s && w === u || D === v && w === x) && (I = D - t, U = w - r, M = D - s, H = w - u, D -= v, w -= x, M = y * H - A * M, I = F * U - z * I, U = E * w - G * D, -1E-10 <= M && -1E-10 <= U && -1E-10 <= I)) {\n              n = !1;break a;\n            }\n          }n = !0;\n        }\n      }if (n) {\n        f.push([a[g[k]], a[g[l]], a[g[p]]]);h.push([g[k], g[l], g[p]]);k = l;for (p = l + 1; p < e; k++, p++) {\n          g[k] = g[p];\n        }e--;q = 2 * e;\n      }\n    }return d ? h : f;\n  };a.Triangulate.area = b;return a;\n})(THREE.FontUtils);self._typeface_js = { faces: THREE.FontUtils.faces, loadFace: THREE.FontUtils.loadFace };THREE.typeface_js = self._typeface_js;\nTHREE.Audio = function (a) {\n  THREE.Object3D.call(this);this.type = \"Audio\";this.context = a.context;this.source = this.context.createBufferSource();this.source.onended = this.onEnded.bind(this);this.gain = this.context.createGain();this.gain.connect(this.context.destination);this.panner = this.context.createPanner();this.panner.connect(this.gain);this.autoplay = !1;this.startTime = 0;this.isPlaying = !1;\n};THREE.Audio.prototype = Object.create(THREE.Object3D.prototype);THREE.Audio.prototype.constructor = THREE.Audio;\nTHREE.Audio.prototype.load = function (a) {\n  var b = this,\n      c = new XMLHttpRequest();c.open(\"GET\", a, !0);c.responseType = \"arraybuffer\";c.onload = function (a) {\n    b.context.decodeAudioData(this.response, function (a) {\n      b.source.buffer = a;b.autoplay && b.play();\n    });\n  };c.send();return this;\n};\nTHREE.Audio.prototype.play = function () {\n  if (!0 === this.isPlaying) THREE.warn(\"THREE.Audio: Audio is already playing.\");else {\n    var a = this.context.createBufferSource();a.buffer = this.source.buffer;a.loop = this.source.loop;a.onended = this.source.onended;a.connect(this.panner);a.start(0, this.startTime);this.isPlaying = !0;this.source = a;\n  }\n};THREE.Audio.prototype.pause = function () {\n  this.source.stop();this.startTime = this.context.currentTime;\n};THREE.Audio.prototype.stop = function () {\n  this.source.stop();this.startTime = 0;\n};\nTHREE.Audio.prototype.onEnded = function () {\n  this.isPlaying = !1;\n};THREE.Audio.prototype.setLoop = function (a) {\n  this.source.loop = a;\n};THREE.Audio.prototype.setRefDistance = function (a) {\n  this.panner.refDistance = a;\n};THREE.Audio.prototype.setRolloffFactor = function (a) {\n  this.panner.rolloffFactor = a;\n};THREE.Audio.prototype.setVolume = function (a) {\n  this.gain.gain.value = a;\n};\nTHREE.Audio.prototype.updateMatrixWorld = function () {\n  var a = new THREE.Vector3();return function (b) {\n    THREE.Object3D.prototype.updateMatrixWorld.call(this, b);a.setFromMatrixPosition(this.matrixWorld);this.panner.setPosition(a.x, a.y, a.z);\n  };\n}();THREE.AudioListener = function () {\n  THREE.Object3D.call(this);this.type = \"AudioListener\";this.context = new (window.AudioContext || window.webkitAudioContext)();\n};THREE.AudioListener.prototype = Object.create(THREE.Object3D.prototype);THREE.AudioListener.prototype.constructor = THREE.AudioListener;\nTHREE.AudioListener.prototype.updateMatrixWorld = function () {\n  var a = new THREE.Vector3(),\n      b = new THREE.Quaternion(),\n      c = new THREE.Vector3(),\n      d = new THREE.Vector3(),\n      e = new THREE.Vector3(),\n      f = new THREE.Vector3();return function (g) {\n    THREE.Object3D.prototype.updateMatrixWorld.call(this, g);g = this.context.listener;var h = this.up;this.matrixWorld.decompose(a, b, c);d.set(0, 0, -1).applyQuaternion(b);e.subVectors(a, f);g.setPosition(a.x, a.y, a.z);g.setOrientation(d.x, d.y, d.z, h.x, h.y, h.z);g.setVelocity(e.x, e.y, e.z);f.copy(a);\n  };\n}();\nTHREE.Curve = function () {};THREE.Curve.prototype.getPoint = function (a) {\n  THREE.warn(\"THREE.Curve: Warning, getPoint() not implemented!\");return null;\n};THREE.Curve.prototype.getPointAt = function (a) {\n  a = this.getUtoTmapping(a);return this.getPoint(a);\n};THREE.Curve.prototype.getPoints = function (a) {\n  a || (a = 5);var b,\n      c = [];for (b = 0; b <= a; b++) {\n    c.push(this.getPoint(b / a));\n  }return c;\n};THREE.Curve.prototype.getSpacedPoints = function (a) {\n  a || (a = 5);var b,\n      c = [];for (b = 0; b <= a; b++) {\n    c.push(this.getPointAt(b / a));\n  }return c;\n};\nTHREE.Curve.prototype.getLength = function () {\n  var a = this.getLengths();return a[a.length - 1];\n};THREE.Curve.prototype.getLengths = function (a) {\n  a || (a = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200);if (this.cacheArcLengths && this.cacheArcLengths.length == a + 1 && !this.needsUpdate) return this.cacheArcLengths;this.needsUpdate = !1;var b = [],\n      c,\n      d = this.getPoint(0),\n      e,\n      f = 0;b.push(0);for (e = 1; e <= a; e++) {\n    c = this.getPoint(e / a), f += c.distanceTo(d), b.push(f), d = c;\n  }return this.cacheArcLengths = b;\n};\nTHREE.Curve.prototype.updateArcLengths = function () {\n  this.needsUpdate = !0;this.getLengths();\n};THREE.Curve.prototype.getUtoTmapping = function (a, b) {\n  var c = this.getLengths(),\n      d = 0,\n      e = c.length,\n      f;f = b ? b : a * c[e - 1];for (var g = 0, h = e - 1, k; g <= h;) {\n    if (d = Math.floor(g + (h - g) / 2), k = c[d] - f, 0 > k) g = d + 1;else if (0 < k) h = d - 1;else {\n      h = d;break;\n    }\n  }d = h;if (c[d] == f) return d / (e - 1);g = c[d];return c = (d + (f - g) / (c[d + 1] - g)) / (e - 1);\n};THREE.Curve.prototype.getTangent = function (a) {\n  var b = a - 1E-4;a += 1E-4;0 > b && (b = 0);1 < a && (a = 1);b = this.getPoint(b);return this.getPoint(a).clone().sub(b).normalize();\n};\nTHREE.Curve.prototype.getTangentAt = function (a) {\n  a = this.getUtoTmapping(a);return this.getTangent(a);\n};\nTHREE.Curve.Utils = { tangentQuadraticBezier: function tangentQuadraticBezier(a, b, c, d) {\n    return 2 * (1 - a) * (c - b) + 2 * a * (d - c);\n  }, tangentCubicBezier: function tangentCubicBezier(a, b, c, d, e) {\n    return -3 * b * (1 - a) * (1 - a) + 3 * c * (1 - a) * (1 - a) - 6 * a * c * (1 - a) + 6 * a * d * (1 - a) - 3 * a * a * d + 3 * a * a * e;\n  }, tangentSpline: function tangentSpline(a, b, c, d, e) {\n    return 6 * a * a - 6 * a + (3 * a * a - 4 * a + 1) + (-6 * a * a + 6 * a) + (3 * a * a - 2 * a);\n  }, interpolate: function interpolate(a, b, c, d, e) {\n    a = .5 * (c - a);d = .5 * (d - b);var f = e * e;return (2 * b - 2 * c + a + d) * e * f + (-3 * b + 3 * c - 2 * a - d) * f + a * e + b;\n  } };\nTHREE.Curve.create = function (a, b) {\n  a.prototype = Object.create(THREE.Curve.prototype);a.prototype.constructor = a;a.prototype.getPoint = b;return a;\n};THREE.CurvePath = function () {\n  this.curves = [];this.bends = [];this.autoClose = !1;\n};THREE.CurvePath.prototype = Object.create(THREE.Curve.prototype);THREE.CurvePath.prototype.constructor = THREE.CurvePath;THREE.CurvePath.prototype.add = function (a) {\n  this.curves.push(a);\n};THREE.CurvePath.prototype.checkConnection = function () {};\nTHREE.CurvePath.prototype.closePath = function () {\n  var a = this.curves[0].getPoint(0),\n      b = this.curves[this.curves.length - 1].getPoint(1);a.equals(b) || this.curves.push(new THREE.LineCurve(b, a));\n};THREE.CurvePath.prototype.getPoint = function (a) {\n  var b = a * this.getLength(),\n      c = this.getCurveLengths();for (a = 0; a < c.length;) {\n    if (c[a] >= b) return b = c[a] - b, a = this.curves[a], b = 1 - b / a.getLength(), a.getPointAt(b);a++;\n  }return null;\n};THREE.CurvePath.prototype.getLength = function () {\n  var a = this.getCurveLengths();return a[a.length - 1];\n};\nTHREE.CurvePath.prototype.getCurveLengths = function () {\n  if (this.cacheLengths && this.cacheLengths.length == this.curves.length) return this.cacheLengths;var a = [],\n      b = 0,\n      c,\n      d = this.curves.length;for (c = 0; c < d; c++) {\n    b += this.curves[c].getLength(), a.push(b);\n  }return this.cacheLengths = a;\n};\nTHREE.CurvePath.prototype.getBoundingBox = function () {\n  var a = this.getPoints(),\n      b,\n      c,\n      d,\n      e,\n      f,\n      g;b = c = Number.NEGATIVE_INFINITY;e = f = Number.POSITIVE_INFINITY;var h,\n      k,\n      l,\n      p,\n      q = a[0] instanceof THREE.Vector3;p = q ? new THREE.Vector3() : new THREE.Vector2();k = 0;for (l = a.length; k < l; k++) {\n    h = a[k], h.x > b ? b = h.x : h.x < e && (e = h.x), h.y > c ? c = h.y : h.y < f && (f = h.y), q && (h.z > d ? d = h.z : h.z < g && (g = h.z)), p.add(h);\n  }a = { minX: e, minY: f, maxX: b, maxY: c };q && (a.maxZ = d, a.minZ = g);return a;\n};\nTHREE.CurvePath.prototype.createPointsGeometry = function (a) {\n  a = this.getPoints(a, !0);return this.createGeometry(a);\n};THREE.CurvePath.prototype.createSpacedPointsGeometry = function (a) {\n  a = this.getSpacedPoints(a, !0);return this.createGeometry(a);\n};THREE.CurvePath.prototype.createGeometry = function (a) {\n  for (var b = new THREE.Geometry(), c = 0; c < a.length; c++) {\n    b.vertices.push(new THREE.Vector3(a[c].x, a[c].y, a[c].z || 0));\n  }return b;\n};THREE.CurvePath.prototype.addWrapPath = function (a) {\n  this.bends.push(a);\n};\nTHREE.CurvePath.prototype.getTransformedPoints = function (a, b) {\n  var c = this.getPoints(a),\n      d,\n      e;b || (b = this.bends);d = 0;for (e = b.length; d < e; d++) {\n    c = this.getWrapPoints(c, b[d]);\n  }return c;\n};THREE.CurvePath.prototype.getTransformedSpacedPoints = function (a, b) {\n  var c = this.getSpacedPoints(a),\n      d,\n      e;b || (b = this.bends);d = 0;for (e = b.length; d < e; d++) {\n    c = this.getWrapPoints(c, b[d]);\n  }return c;\n};\nTHREE.CurvePath.prototype.getWrapPoints = function (a, b) {\n  var c = this.getBoundingBox(),\n      d,\n      e,\n      f,\n      g,\n      h,\n      k;d = 0;for (e = a.length; d < e; d++) {\n    f = a[d], g = f.x, h = f.y, k = g / c.maxX, k = b.getUtoTmapping(k, g), g = b.getPoint(k), k = b.getTangent(k), k.set(-k.y, k.x).multiplyScalar(h), f.x = g.x + k.x, f.y = g.y + k.y;\n  }return a;\n};THREE.Gyroscope = function () {\n  THREE.Object3D.call(this);\n};THREE.Gyroscope.prototype = Object.create(THREE.Object3D.prototype);THREE.Gyroscope.prototype.constructor = THREE.Gyroscope;\nTHREE.Gyroscope.prototype.updateMatrixWorld = function () {\n  var a = new THREE.Vector3(),\n      b = new THREE.Quaternion(),\n      c = new THREE.Vector3(),\n      d = new THREE.Vector3(),\n      e = new THREE.Quaternion(),\n      f = new THREE.Vector3();return function (g) {\n    this.matrixAutoUpdate && this.updateMatrix();if (this.matrixWorldNeedsUpdate || g) this.parent ? (this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorld.decompose(d, e, f), this.matrix.decompose(a, b, c), this.matrixWorld.compose(d, b, f)) : this.matrixWorld.copy(this.matrix), this.matrixWorldNeedsUpdate = !1, g = !0;for (var h = 0, k = this.children.length; h < k; h++) {\n      this.children[h].updateMatrixWorld(g);\n    }\n  };\n}();THREE.Path = function (a) {\n  THREE.CurvePath.call(this);this.actions = [];a && this.fromPoints(a);\n};THREE.Path.prototype = Object.create(THREE.CurvePath.prototype);THREE.Path.prototype.constructor = THREE.Path;THREE.PathActions = { MOVE_TO: \"moveTo\", LINE_TO: \"lineTo\", QUADRATIC_CURVE_TO: \"quadraticCurveTo\", BEZIER_CURVE_TO: \"bezierCurveTo\", CSPLINE_THRU: \"splineThru\", ARC: \"arc\", ELLIPSE: \"ellipse\" };\nTHREE.Path.prototype.fromPoints = function (a) {\n  this.moveTo(a[0].x, a[0].y);for (var b = 1, c = a.length; b < c; b++) {\n    this.lineTo(a[b].x, a[b].y);\n  }\n};THREE.Path.prototype.moveTo = function (a, b) {\n  var c = Array.prototype.slice.call(arguments);this.actions.push({ action: THREE.PathActions.MOVE_TO, args: c });\n};\nTHREE.Path.prototype.lineTo = function (a, b) {\n  var c = Array.prototype.slice.call(arguments),\n      d = this.actions[this.actions.length - 1].args,\n      d = new THREE.LineCurve(new THREE.Vector2(d[d.length - 2], d[d.length - 1]), new THREE.Vector2(a, b));this.curves.push(d);this.actions.push({ action: THREE.PathActions.LINE_TO, args: c });\n};\nTHREE.Path.prototype.quadraticCurveTo = function (a, b, c, d) {\n  var e = Array.prototype.slice.call(arguments),\n      f = this.actions[this.actions.length - 1].args,\n      f = new THREE.QuadraticBezierCurve(new THREE.Vector2(f[f.length - 2], f[f.length - 1]), new THREE.Vector2(a, b), new THREE.Vector2(c, d));this.curves.push(f);this.actions.push({ action: THREE.PathActions.QUADRATIC_CURVE_TO, args: e });\n};\nTHREE.Path.prototype.bezierCurveTo = function (a, b, c, d, e, f) {\n  var g = Array.prototype.slice.call(arguments),\n      h = this.actions[this.actions.length - 1].args,\n      h = new THREE.CubicBezierCurve(new THREE.Vector2(h[h.length - 2], h[h.length - 1]), new THREE.Vector2(a, b), new THREE.Vector2(c, d), new THREE.Vector2(e, f));this.curves.push(h);this.actions.push({ action: THREE.PathActions.BEZIER_CURVE_TO, args: g });\n};\nTHREE.Path.prototype.splineThru = function (a) {\n  var b = Array.prototype.slice.call(arguments),\n      c = this.actions[this.actions.length - 1].args,\n      c = [new THREE.Vector2(c[c.length - 2], c[c.length - 1])];Array.prototype.push.apply(c, a);c = new THREE.SplineCurve(c);this.curves.push(c);this.actions.push({ action: THREE.PathActions.CSPLINE_THRU, args: b });\n};THREE.Path.prototype.arc = function (a, b, c, d, e, f) {\n  var g = this.actions[this.actions.length - 1].args;this.absarc(a + g[g.length - 2], b + g[g.length - 1], c, d, e, f);\n};\nTHREE.Path.prototype.absarc = function (a, b, c, d, e, f) {\n  this.absellipse(a, b, c, c, d, e, f);\n};THREE.Path.prototype.ellipse = function (a, b, c, d, e, f, g) {\n  var h = this.actions[this.actions.length - 1].args;this.absellipse(a + h[h.length - 2], b + h[h.length - 1], c, d, e, f, g);\n};THREE.Path.prototype.absellipse = function (a, b, c, d, e, f, g) {\n  var h = Array.prototype.slice.call(arguments),\n      k = new THREE.EllipseCurve(a, b, c, d, e, f, g);this.curves.push(k);k = k.getPoint(1);h.push(k.x);h.push(k.y);this.actions.push({ action: THREE.PathActions.ELLIPSE, args: h });\n};\nTHREE.Path.prototype.getSpacedPoints = function (a, b) {\n  a || (a = 40);for (var c = [], d = 0; d < a; d++) {\n    c.push(this.getPoint(d / a));\n  }return c;\n};\nTHREE.Path.prototype.getPoints = function (a, b) {\n  if (this.useSpacedPoints) return console.log(\"tata\"), this.getSpacedPoints(a, b);a = a || 12;var c = [],\n      d,\n      e,\n      f,\n      g,\n      h,\n      k,\n      l,\n      p,\n      q,\n      n,\n      t,\n      r,\n      s;d = 0;for (e = this.actions.length; d < e; d++) {\n    switch (f = this.actions[d], g = f.action, f = f.args, g) {case THREE.PathActions.MOVE_TO:\n        c.push(new THREE.Vector2(f[0], f[1]));break;case THREE.PathActions.LINE_TO:\n        c.push(new THREE.Vector2(f[0], f[1]));break;case THREE.PathActions.QUADRATIC_CURVE_TO:\n        h = f[2];k = f[3];q = f[0];n = f[1];0 < c.length ? (g = c[c.length - 1], t = g.x, r = g.y) : (g = this.actions[d - 1].args, t = g[g.length - 2], r = g[g.length - 1]);for (f = 1; f <= a; f++) {\n          s = f / a, g = THREE.Shape.Utils.b2(s, t, q, h), s = THREE.Shape.Utils.b2(s, r, n, k), c.push(new THREE.Vector2(g, s));\n        }break;case THREE.PathActions.BEZIER_CURVE_TO:\n        h = f[4];k = f[5];q = f[0];n = f[1];l = f[2];p = f[3];0 < c.length ? (g = c[c.length - 1], t = g.x, r = g.y) : (g = this.actions[d - 1].args, t = g[g.length - 2], r = g[g.length - 1]);for (f = 1; f <= a; f++) {\n          s = f / a, g = THREE.Shape.Utils.b3(s, t, q, l, h), s = THREE.Shape.Utils.b3(s, r, n, p, k), c.push(new THREE.Vector2(g, s));\n        }break;case THREE.PathActions.CSPLINE_THRU:\n        g = this.actions[d - 1].args;s = [new THREE.Vector2(g[g.length - 2], g[g.length - 1])];g = a * f[0].length;s = s.concat(f[0]);s = new THREE.SplineCurve(s);for (f = 1; f <= g; f++) {\n          c.push(s.getPointAt(f / g));\n        }break;case THREE.PathActions.ARC:\n        h = f[0];k = f[1];n = f[2];l = f[3];g = f[4];q = !!f[5];t = g - l;r = 2 * a;for (f = 1; f <= r; f++) {\n          s = f / r, q || (s = 1 - s), s = l + s * t, g = h + n * Math.cos(s), s = k + n * Math.sin(s), c.push(new THREE.Vector2(g, s));\n        }break;case THREE.PathActions.ELLIPSE:\n        for (h = f[0], k = f[1], n = f[2], p = f[3], l = f[4], g = f[5], q = !!f[6], t = g - l, r = 2 * a, f = 1; f <= r; f++) {\n          s = f / r, q || (s = 1 - s), s = l + s * t, g = h + n * Math.cos(s), s = k + p * Math.sin(s), c.push(new THREE.Vector2(g, s));\n        }}\n  }d = c[c.length - 1];1E-10 > Math.abs(d.x - c[0].x) && 1E-10 > Math.abs(d.y - c[0].y) && c.splice(c.length - 1, 1);b && c.push(c[0]);return c;\n};\nTHREE.Path.prototype.toShapes = function (a, b) {\n  function c(a) {\n    for (var b = [], c = 0, d = a.length; c < d; c++) {\n      var e = a[c],\n          f = new THREE.Shape();f.actions = e.actions;f.curves = e.curves;b.push(f);\n    }return b;\n  }function d(a, b) {\n    for (var c = b.length, d = !1, e = c - 1, f = 0; f < c; e = f++) {\n      var g = b[e],\n          h = b[f],\n          k = h.x - g.x,\n          n = h.y - g.y;if (1E-10 < Math.abs(n)) {\n        if (0 > n && (g = b[f], k = -k, h = b[e], n = -n), !(a.y < g.y || a.y > h.y)) if (a.y == g.y) {\n          if (a.x == g.x) return !0;\n        } else {\n          e = n * (a.x - g.x) - k * (a.y - g.y);if (0 == e) return !0;0 > e || (d = !d);\n        }\n      } else if (a.y == g.y && (h.x <= a.x && a.x <= g.x || g.x <= a.x && a.x <= h.x)) return !0;\n    }return d;\n  }var e = function (a) {\n    var b,\n        c,\n        d,\n        e,\n        f = [],\n        g = new THREE.Path();b = 0;for (c = a.length; b < c; b++) {\n      d = a[b], e = d.args, d = d.action, d == THREE.PathActions.MOVE_TO && 0 != g.actions.length && (f.push(g), g = new THREE.Path()), g[d].apply(g, e);\n    }0 != g.actions.length && f.push(g);return f;\n  }(this.actions);if (0 == e.length) return [];if (!0 === b) return c(e);var f,\n      g,\n      h,\n      k = [];if (1 == e.length) return g = e[0], h = new THREE.Shape(), h.actions = g.actions, h.curves = g.curves, k.push(h), k;var l = !THREE.Shape.Utils.isClockWise(e[0].getPoints()),\n      l = a ? !l : l;\n  h = [];var p = [],\n      q = [],\n      n = 0,\n      t;p[n] = void 0;q[n] = [];var r, s;r = 0;for (s = e.length; r < s; r++) {\n    g = e[r], t = g.getPoints(), f = THREE.Shape.Utils.isClockWise(t), (f = a ? !f : f) ? (!l && p[n] && n++, p[n] = { s: new THREE.Shape(), p: t }, p[n].s.actions = g.actions, p[n].s.curves = g.curves, l && n++, q[n] = []) : q[n].push({ h: g, p: t[0] });\n  }if (!p[0]) return c(e);if (1 < p.length) {\n    r = !1;s = [];g = 0;for (e = p.length; g < e; g++) {\n      h[g] = [];\n    }g = 0;for (e = p.length; g < e; g++) {\n      for (f = q[g], l = 0; l < f.length; l++) {\n        n = f[l];t = !0;for (var u = 0; u < p.length; u++) {\n          d(n.p, p[u].p) && (g != u && s.push({ froms: g, tos: u,\n            hole: l }), t ? (t = !1, h[u].push(n)) : r = !0);\n        }t && h[g].push(n);\n      }\n    }0 < s.length && (r || (q = h));\n  }r = 0;for (s = p.length; r < s; r++) {\n    for (h = p[r].s, k.push(h), g = q[r], e = 0, f = g.length; e < f; e++) {\n      h.holes.push(g[e].h);\n    }\n  }return k;\n};THREE.Shape = function () {\n  THREE.Path.apply(this, arguments);this.holes = [];\n};THREE.Shape.prototype = Object.create(THREE.Path.prototype);THREE.Shape.prototype.constructor = THREE.Shape;THREE.Shape.prototype.extrude = function (a) {\n  return new THREE.ExtrudeGeometry(this, a);\n};\nTHREE.Shape.prototype.makeGeometry = function (a) {\n  return new THREE.ShapeGeometry(this, a);\n};THREE.Shape.prototype.getPointsHoles = function (a) {\n  var b,\n      c = this.holes.length,\n      d = [];for (b = 0; b < c; b++) {\n    d[b] = this.holes[b].getTransformedPoints(a, this.bends);\n  }return d;\n};THREE.Shape.prototype.getSpacedPointsHoles = function (a) {\n  var b,\n      c = this.holes.length,\n      d = [];for (b = 0; b < c; b++) {\n    d[b] = this.holes[b].getTransformedSpacedPoints(a, this.bends);\n  }return d;\n};\nTHREE.Shape.prototype.extractAllPoints = function (a) {\n  return { shape: this.getTransformedPoints(a), holes: this.getPointsHoles(a) };\n};THREE.Shape.prototype.extractPoints = function (a) {\n  return this.useSpacedPoints ? this.extractAllSpacedPoints(a) : this.extractAllPoints(a);\n};THREE.Shape.prototype.extractAllSpacedPoints = function (a) {\n  return { shape: this.getTransformedSpacedPoints(a), holes: this.getSpacedPointsHoles(a) };\n};\nTHREE.Shape.Utils = { triangulateShape: function triangulateShape(a, b) {\n    function c(a, b, c) {\n      return a.x != b.x ? a.x < b.x ? a.x <= c.x && c.x <= b.x : b.x <= c.x && c.x <= a.x : a.y < b.y ? a.y <= c.y && c.y <= b.y : b.y <= c.y && c.y <= a.y;\n    }function d(a, b, d, e, f) {\n      var g = b.x - a.x,\n          h = b.y - a.y,\n          k = e.x - d.x,\n          l = e.y - d.y,\n          p = a.x - d.x,\n          q = a.y - d.y,\n          E = h * k - g * l,\n          G = h * p - g * q;if (1E-10 < Math.abs(E)) {\n        if (0 < E) {\n          if (0 > G || G > E) return [];k = l * p - k * q;if (0 > k || k > E) return [];\n        } else {\n          if (0 < G || G < E) return [];k = l * p - k * q;if (0 < k || k < E) return [];\n        }if (0 == k) return !f || 0 != G && G != E ? [a] : [];if (k == E) return !f || 0 != G && G != E ? [b] : [];if (0 == G) return [d];\n        if (G == E) return [e];f = k / E;return [{ x: a.x + f * g, y: a.y + f * h }];\n      }if (0 != G || l * p != k * q) return [];h = 0 == g && 0 == h;k = 0 == k && 0 == l;if (h && k) return a.x != d.x || a.y != d.y ? [] : [a];if (h) return c(d, e, a) ? [a] : [];if (k) return c(a, b, d) ? [d] : [];0 != g ? (a.x < b.x ? (g = a, k = a.x, h = b, a = b.x) : (g = b, k = b.x, h = a, a = a.x), d.x < e.x ? (b = d, E = d.x, l = e, d = e.x) : (b = e, E = e.x, l = d, d = d.x)) : (a.y < b.y ? (g = a, k = a.y, h = b, a = b.y) : (g = b, k = b.y, h = a, a = a.y), d.y < e.y ? (b = d, E = d.y, l = e, d = e.y) : (b = e, E = e.y, l = d, d = d.y));return k <= E ? a < E ? [] : a == E ? f ? [] : [b] : a <= d ? [b, h] : [b, l] : k > d ? [] : k == d ? f ? [] : [g] : a <= d ? [g, h] : [g, l];\n    }function e(a, b, c, d) {\n      var e = b.x - a.x,\n          f = b.y - a.y;b = c.x - a.x;c = c.y - a.y;var g = d.x - a.x;d = d.y - a.y;a = e * c - f * b;e = e * d - f * g;return 1E-10 < Math.abs(a) ? (b = g * c - d * b, 0 < a ? 0 <= e && 0 <= b : 0 <= e || 0 <= b) : 0 < e;\n    }var f,\n        g,\n        h,\n        k,\n        l,\n        p = {};h = a.concat();f = 0;for (g = b.length; f < g; f++) {\n      Array.prototype.push.apply(h, b[f]);\n    }f = 0;for (g = h.length; f < g; f++) {\n      l = h[f].x + \":\" + h[f].y, void 0 !== p[l] && THREE.warn(\"THREE.Shape: Duplicate point\", l), p[l] = f;\n    }f = function (a, b) {\n      function c(a, b) {\n        var d = h.length - 1,\n            f = a - 1;0 > f && (f = d);var g = a + 1;g > d && (g = 0);d = e(h[a], h[f], h[g], k[b]);\n        if (!d) return !1;d = k.length - 1;f = b - 1;0 > f && (f = d);g = b + 1;g > d && (g = 0);return (d = e(k[b], k[f], k[g], h[a])) ? !0 : !1;\n      }function f(a, b) {\n        var c, e;for (c = 0; c < h.length; c++) {\n          if (e = c + 1, e %= h.length, e = d(a, b, h[c], h[e], !0), 0 < e.length) return !0;\n        }return !1;\n      }function g(a, c) {\n        var e, f, h, k;for (e = 0; e < l.length; e++) {\n          for (f = b[l[e]], h = 0; h < f.length; h++) {\n            if (k = h + 1, k %= f.length, k = d(a, c, f[h], f[k], !0), 0 < k.length) return !0;\n          }\n        }return !1;\n      }var h = a.concat(),\n          k,\n          l = [],\n          p,\n          q,\n          A,\n          E,\n          G,\n          F = [],\n          z,\n          I,\n          U,\n          M = 0;for (p = b.length; M < p; M++) {\n        l.push(M);\n      }z = 0;for (var H = 2 * l.length; 0 < l.length;) {\n        H--;if (0 > H) {\n          console.log(\"Infinite Loop! Holes left:\" + l.length + \", Probably Hole outside Shape!\");break;\n        }for (q = z; q < h.length; q++) {\n          A = h[q];p = -1;for (M = 0; M < l.length; M++) {\n            if (E = l[M], G = A.x + \":\" + A.y + \":\" + E, void 0 === F[G]) {\n              k = b[E];for (I = 0; I < k.length; I++) {\n                if (E = k[I], c(q, I) && !f(A, E) && !g(A, E)) {\n                  p = I;l.splice(M, 1);z = h.slice(0, q + 1);E = h.slice(q);I = k.slice(p);U = k.slice(0, p + 1);h = z.concat(I).concat(U).concat(E);z = q;break;\n                }\n              }if (0 <= p) break;F[G] = !0;\n            }\n          }if (0 <= p) break;\n        }\n      }return h;\n    }(a, b);var q = THREE.FontUtils.Triangulate(f, !1);f = 0;for (g = q.length; f < g; f++) {\n      for (k = q[f], h = 0; 3 > h; h++) {\n        l = k[h].x + \":\" + k[h].y, l = p[l], void 0 !== l && (k[h] = l);\n      }\n    }return q.concat();\n  }, isClockWise: function isClockWise(a) {\n    return 0 > THREE.FontUtils.Triangulate.area(a);\n  }, b2p0: function b2p0(a, b) {\n    var c = 1 - a;return c * c * b;\n  }, b2p1: function b2p1(a, b) {\n    return 2 * (1 - a) * a * b;\n  }, b2p2: function b2p2(a, b) {\n    return a * a * b;\n  }, b2: function b2(a, b, c, d) {\n    return this.b2p0(a, b) + this.b2p1(a, c) + this.b2p2(a, d);\n  }, b3p0: function b3p0(a, b) {\n    var c = 1 - a;return c * c * c * b;\n  }, b3p1: function b3p1(a, b) {\n    var c = 1 - a;return 3 * c * c * a * b;\n  }, b3p2: function b3p2(a, b) {\n    return 3 * (1 - a) * a * a * b;\n  }, b3p3: function b3p3(a, b) {\n    return a * a * a * b;\n  }, b3: function b3(a, b, c, d, e) {\n    return this.b3p0(a, b) + this.b3p1(a, c) + this.b3p2(a, d) + this.b3p3(a, e);\n  } };THREE.LineCurve = function (a, b) {\n  this.v1 = a;this.v2 = b;\n};THREE.LineCurve.prototype = Object.create(THREE.Curve.prototype);THREE.LineCurve.prototype.constructor = THREE.LineCurve;THREE.LineCurve.prototype.getPoint = function (a) {\n  var b = this.v2.clone().sub(this.v1);b.multiplyScalar(a).add(this.v1);return b;\n};THREE.LineCurve.prototype.getPointAt = function (a) {\n  return this.getPoint(a);\n};\nTHREE.LineCurve.prototype.getTangent = function (a) {\n  return this.v2.clone().sub(this.v1).normalize();\n};THREE.QuadraticBezierCurve = function (a, b, c) {\n  this.v0 = a;this.v1 = b;this.v2 = c;\n};THREE.QuadraticBezierCurve.prototype = Object.create(THREE.Curve.prototype);THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;\nTHREE.QuadraticBezierCurve.prototype.getPoint = function (a) {\n  var b = new THREE.Vector2();b.x = THREE.Shape.Utils.b2(a, this.v0.x, this.v1.x, this.v2.x);b.y = THREE.Shape.Utils.b2(a, this.v0.y, this.v1.y, this.v2.y);return b;\n};THREE.QuadraticBezierCurve.prototype.getTangent = function (a) {\n  var b = new THREE.Vector2();b.x = THREE.Curve.Utils.tangentQuadraticBezier(a, this.v0.x, this.v1.x, this.v2.x);b.y = THREE.Curve.Utils.tangentQuadraticBezier(a, this.v0.y, this.v1.y, this.v2.y);return b.normalize();\n};\nTHREE.CubicBezierCurve = function (a, b, c, d) {\n  this.v0 = a;this.v1 = b;this.v2 = c;this.v3 = d;\n};THREE.CubicBezierCurve.prototype = Object.create(THREE.Curve.prototype);THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;THREE.CubicBezierCurve.prototype.getPoint = function (a) {\n  var b;b = THREE.Shape.Utils.b3(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x);a = THREE.Shape.Utils.b3(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y);return new THREE.Vector2(b, a);\n};\nTHREE.CubicBezierCurve.prototype.getTangent = function (a) {\n  var b;b = THREE.Curve.Utils.tangentCubicBezier(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x);a = THREE.Curve.Utils.tangentCubicBezier(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y);b = new THREE.Vector2(b, a);b.normalize();return b;\n};THREE.SplineCurve = function (a) {\n  this.points = void 0 == a ? [] : a;\n};THREE.SplineCurve.prototype = Object.create(THREE.Curve.prototype);THREE.SplineCurve.prototype.constructor = THREE.SplineCurve;\nTHREE.SplineCurve.prototype.getPoint = function (a) {\n  var b = this.points;a *= b.length - 1;var c = Math.floor(a);a -= c;var d = b[0 == c ? c : c - 1],\n      e = b[c],\n      f = b[c > b.length - 2 ? b.length - 1 : c + 1],\n      b = b[c > b.length - 3 ? b.length - 1 : c + 2],\n      c = new THREE.Vector2();c.x = THREE.Curve.Utils.interpolate(d.x, e.x, f.x, b.x, a);c.y = THREE.Curve.Utils.interpolate(d.y, e.y, f.y, b.y, a);return c;\n};THREE.EllipseCurve = function (a, b, c, d, e, f, g) {\n  this.aX = a;this.aY = b;this.xRadius = c;this.yRadius = d;this.aStartAngle = e;this.aEndAngle = f;this.aClockwise = g;\n};\nTHREE.EllipseCurve.prototype = Object.create(THREE.Curve.prototype);THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;THREE.EllipseCurve.prototype.getPoint = function (a) {\n  var b = this.aEndAngle - this.aStartAngle;0 > b && (b += 2 * Math.PI);b > 2 * Math.PI && (b -= 2 * Math.PI);a = !0 === this.aClockwise ? this.aEndAngle + (1 - a) * (2 * Math.PI - b) : this.aStartAngle + a * b;b = new THREE.Vector2();b.x = this.aX + this.xRadius * Math.cos(a);b.y = this.aY + this.yRadius * Math.sin(a);return b;\n};\nTHREE.ArcCurve = function (a, b, c, d, e, f) {\n  THREE.EllipseCurve.call(this, a, b, c, c, d, e, f);\n};THREE.ArcCurve.prototype = Object.create(THREE.EllipseCurve.prototype);THREE.ArcCurve.prototype.constructor = THREE.ArcCurve;THREE.LineCurve3 = THREE.Curve.create(function (a, b) {\n  this.v1 = a;this.v2 = b;\n}, function (a) {\n  var b = new THREE.Vector3();b.subVectors(this.v2, this.v1);b.multiplyScalar(a);b.add(this.v1);return b;\n});\nTHREE.QuadraticBezierCurve3 = THREE.Curve.create(function (a, b, c) {\n  this.v0 = a;this.v1 = b;this.v2 = c;\n}, function (a) {\n  var b = new THREE.Vector3();b.x = THREE.Shape.Utils.b2(a, this.v0.x, this.v1.x, this.v2.x);b.y = THREE.Shape.Utils.b2(a, this.v0.y, this.v1.y, this.v2.y);b.z = THREE.Shape.Utils.b2(a, this.v0.z, this.v1.z, this.v2.z);return b;\n});\nTHREE.CubicBezierCurve3 = THREE.Curve.create(function (a, b, c, d) {\n  this.v0 = a;this.v1 = b;this.v2 = c;this.v3 = d;\n}, function (a) {\n  var b = new THREE.Vector3();b.x = THREE.Shape.Utils.b3(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x);b.y = THREE.Shape.Utils.b3(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y);b.z = THREE.Shape.Utils.b3(a, this.v0.z, this.v1.z, this.v2.z, this.v3.z);return b;\n});\nTHREE.SplineCurve3 = THREE.Curve.create(function (a) {\n  this.points = void 0 == a ? [] : a;\n}, function (a) {\n  var b = this.points;a *= b.length - 1;var c = Math.floor(a);a -= c;var d = b[0 == c ? c : c - 1],\n      e = b[c],\n      f = b[c > b.length - 2 ? b.length - 1 : c + 1],\n      b = b[c > b.length - 3 ? b.length - 1 : c + 2],\n      c = new THREE.Vector3();c.x = THREE.Curve.Utils.interpolate(d.x, e.x, f.x, b.x, a);c.y = THREE.Curve.Utils.interpolate(d.y, e.y, f.y, b.y, a);c.z = THREE.Curve.Utils.interpolate(d.z, e.z, f.z, b.z, a);return c;\n});\nTHREE.ClosedSplineCurve3 = THREE.Curve.create(function (a) {\n  this.points = void 0 == a ? [] : a;\n}, function (a) {\n  var b = this.points;a *= b.length - 0;var c = Math.floor(a);a -= c;var c = c + (0 < c ? 0 : (Math.floor(Math.abs(c) / b.length) + 1) * b.length),\n      d = b[(c - 1) % b.length],\n      e = b[c % b.length],\n      f = b[(c + 1) % b.length],\n      b = b[(c + 2) % b.length],\n      c = new THREE.Vector3();c.x = THREE.Curve.Utils.interpolate(d.x, e.x, f.x, b.x, a);c.y = THREE.Curve.Utils.interpolate(d.y, e.y, f.y, b.y, a);c.z = THREE.Curve.Utils.interpolate(d.z, e.z, f.z, b.z, a);return c;\n});\nTHREE.AnimationHandler = { LINEAR: 0, CATMULLROM: 1, CATMULLROM_FORWARD: 2, add: function add() {\n    THREE.warn(\"THREE.AnimationHandler.add() has been deprecated.\");\n  }, get: function get() {\n    THREE.warn(\"THREE.AnimationHandler.get() has been deprecated.\");\n  }, remove: function remove() {\n    THREE.warn(\"THREE.AnimationHandler.remove() has been deprecated.\");\n  }, animations: [], init: function init(a) {\n    if (!0 === a.initialized) return a;for (var b = 0; b < a.hierarchy.length; b++) {\n      for (var c = 0; c < a.hierarchy[b].keys.length; c++) {\n        if (0 > a.hierarchy[b].keys[c].time && (a.hierarchy[b].keys[c].time = 0), void 0 !== a.hierarchy[b].keys[c].rot && !(a.hierarchy[b].keys[c].rot instanceof THREE.Quaternion)) {\n          var d = a.hierarchy[b].keys[c].rot;a.hierarchy[b].keys[c].rot = new THREE.Quaternion().fromArray(d);\n        }\n      }if (a.hierarchy[b].keys.length && void 0 !== a.hierarchy[b].keys[0].morphTargets) {\n        d = {};for (c = 0; c < a.hierarchy[b].keys.length; c++) {\n          for (var e = 0; e < a.hierarchy[b].keys[c].morphTargets.length; e++) {\n            var f = a.hierarchy[b].keys[c].morphTargets[e];d[f] = -1;\n          }\n        }a.hierarchy[b].usedMorphTargets = d;for (c = 0; c < a.hierarchy[b].keys.length; c++) {\n          var g = {};for (f in d) {\n            for (e = 0; e < a.hierarchy[b].keys[c].morphTargets.length; e++) {\n              if (a.hierarchy[b].keys[c].morphTargets[e] === f) {\n                g[f] = a.hierarchy[b].keys[c].morphTargetsInfluences[e];break;\n              }\n            }e === a.hierarchy[b].keys[c].morphTargets.length && (g[f] = 0);\n          }a.hierarchy[b].keys[c].morphTargetsInfluences = g;\n        }\n      }for (c = 1; c < a.hierarchy[b].keys.length; c++) {\n        a.hierarchy[b].keys[c].time === a.hierarchy[b].keys[c - 1].time && (a.hierarchy[b].keys.splice(c, 1), c--);\n      }for (c = 0; c < a.hierarchy[b].keys.length; c++) {\n        a.hierarchy[b].keys[c].index = c;\n      }\n    }a.initialized = !0;return a;\n  }, parse: function parse(a) {\n    var b = function b(a, c) {\n      c.push(a);for (var d = 0; d < a.children.length; d++) {\n        b(a.children[d], c);\n      }\n    },\n        c = [];if (a instanceof THREE.SkinnedMesh) for (var d = 0; d < a.skeleton.bones.length; d++) {\n      c.push(a.skeleton.bones[d]);\n    } else b(a, c);return c;\n  }, play: function play(a) {\n    -1 === this.animations.indexOf(a) && this.animations.push(a);\n  }, stop: function stop(a) {\n    a = this.animations.indexOf(a);-1 !== a && this.animations.splice(a, 1);\n  }, update: function update(a) {\n    for (var b = 0; b < this.animations.length; b++) {\n      this.animations[b].resetBlendWeights();\n    }for (b = 0; b < this.animations.length; b++) {\n      this.animations[b].update(a);\n    }\n  } };THREE.Animation = function (a, b) {\n  this.root = a;this.data = THREE.AnimationHandler.init(b);this.hierarchy = THREE.AnimationHandler.parse(a);this.currentTime = 0;this.timeScale = 1;this.isPlaying = !1;this.loop = !0;this.weight = 0;this.interpolationType = THREE.AnimationHandler.LINEAR;\n};\nTHREE.Animation.prototype = { constructor: THREE.Animation, keyTypes: [\"pos\", \"rot\", \"scl\"], play: function play(a, b) {\n    this.currentTime = void 0 !== a ? a : 0;this.weight = void 0 !== b ? b : 1;this.isPlaying = !0;this.reset();THREE.AnimationHandler.play(this);\n  }, stop: function stop() {\n    this.isPlaying = !1;THREE.AnimationHandler.stop(this);\n  }, reset: function reset() {\n    for (var a = 0, b = this.hierarchy.length; a < b; a++) {\n      var c = this.hierarchy[a];void 0 === c.animationCache && (c.animationCache = { animations: {}, blending: { positionWeight: 0, quaternionWeight: 0, scaleWeight: 0 } });\n      var d = this.data.name,\n          e = c.animationCache.animations,\n          f = e[d];void 0 === f && (f = { prevKey: { pos: 0, rot: 0, scl: 0 }, nextKey: { pos: 0, rot: 0, scl: 0 }, originalMatrix: c.matrix }, e[d] = f);for (c = 0; 3 > c; c++) {\n        for (var d = this.keyTypes[c], e = this.data.hierarchy[a].keys[0], g = this.getNextKeyWith(d, a, 1); g.time < this.currentTime && g.index > e.index;) {\n          e = g, g = this.getNextKeyWith(d, a, g.index + 1);\n        }f.prevKey[d] = e;f.nextKey[d] = g;\n      }\n    }\n  }, resetBlendWeights: function resetBlendWeights() {\n    for (var a = 0, b = this.hierarchy.length; a < b; a++) {\n      var c = this.hierarchy[a].animationCache;void 0 !== c && (c = c.blending, c.positionWeight = 0, c.quaternionWeight = 0, c.scaleWeight = 0);\n    }\n  }, update: function () {\n    var a = [],\n        b = new THREE.Vector3(),\n        c = new THREE.Vector3(),\n        d = new THREE.Quaternion(),\n        e = function e(a, b) {\n      var c = [],\n          d = [],\n          e,\n          q,\n          n,\n          t,\n          r,\n          s;e = (a.length - 1) * b;q = Math.floor(e);e -= q;c[0] = 0 === q ? q : q - 1;c[1] = q;c[2] = q > a.length - 2 ? q : q + 1;c[3] = q > a.length - 3 ? q : q + 2;q = a[c[0]];t = a[c[1]];r = a[c[2]];s = a[c[3]];c = e * e;n = e * c;d[0] = f(q[0], t[0], r[0], s[0], e, c, n);d[1] = f(q[1], t[1], r[1], s[1], e, c, n);d[2] = f(q[2], t[2], r[2], s[2], e, c, n);return d;\n    },\n        f = function f(a, b, c, d, e, _f, n) {\n      a = .5 * (c - a);d = .5 * (d - b);return (2 * (b - c) + a + d) * n + (-3 * (b - c) - 2 * a - d) * _f + a * e + b;\n    };return function (f) {\n      if (!1 !== this.isPlaying && (this.currentTime += f * this.timeScale, 0 !== this.weight)) {\n        f = this.data.length;if (this.currentTime > f || 0 > this.currentTime) this.loop ? (this.currentTime %= f, 0 > this.currentTime && (this.currentTime += f), this.reset()) : this.stop();f = 0;for (var h = this.hierarchy.length; f < h; f++) {\n          for (var k = this.hierarchy[f], l = k.animationCache.animations[this.data.name], p = k.animationCache.blending, q = 0; 3 > q; q++) {\n            var n = this.keyTypes[q],\n                t = l.prevKey[n],\n                r = l.nextKey[n];if (0 < this.timeScale && r.time <= this.currentTime || 0 > this.timeScale && t.time >= this.currentTime) {\n              t = this.data.hierarchy[f].keys[0];for (r = this.getNextKeyWith(n, f, 1); r.time < this.currentTime && r.index > t.index;) {\n                t = r, r = this.getNextKeyWith(n, f, r.index + 1);\n              }l.prevKey[n] = t;l.nextKey[n] = r;\n            }var s = (this.currentTime - t.time) / (r.time - t.time),\n                u = t[n],\n                v = r[n];0 > s && (s = 0);1 < s && (s = 1);if (\"pos\" === n) {\n              if (this.interpolationType === THREE.AnimationHandler.LINEAR) c.x = u[0] + (v[0] - u[0]) * s, c.y = u[1] + (v[1] - u[1]) * s, c.z = u[2] + (v[2] - u[2]) * s, t = this.weight / (this.weight + p.positionWeight), k.position.lerp(c, t), p.positionWeight += this.weight;else {\n                if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) a[0] = this.getPrevKeyWith(\"pos\", f, t.index - 1).pos, a[1] = u, a[2] = v, a[3] = this.getNextKeyWith(\"pos\", f, r.index + 1).pos, s = .33 * s + .33, r = e(a, s), t = this.weight / (this.weight + p.positionWeight), p.positionWeight += this.weight, n = k.position, n.x += (r[0] - n.x) * t, n.y += (r[1] - n.y) * t, n.z += (r[2] - n.z) * t, this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD && (s = e(a, 1.01 * s), b.set(s[0], s[1], s[2]), b.sub(n), b.y = 0, b.normalize(), s = Math.atan2(b.x, b.z), k.rotation.set(0, s, 0));\n              }\n            } else \"rot\" === n ? (THREE.Quaternion.slerp(u, v, d, s), 0 === p.quaternionWeight ? (k.quaternion.copy(d), p.quaternionWeight = this.weight) : (t = this.weight / (this.weight + p.quaternionWeight), THREE.Quaternion.slerp(k.quaternion, d, k.quaternion, t), p.quaternionWeight += this.weight)) : \"scl\" === n && (c.x = u[0] + (v[0] - u[0]) * s, c.y = u[1] + (v[1] - u[1]) * s, c.z = u[2] + (v[2] - u[2]) * s, t = this.weight / (this.weight + p.scaleWeight), k.scale.lerp(c, t), p.scaleWeight += this.weight);\n          }\n        }return !0;\n      }\n    };\n  }(), getNextKeyWith: function getNextKeyWith(a, b, c) {\n    var d = this.data.hierarchy[b].keys;for (c = this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? c < d.length - 1 ? c : d.length - 1 : c % d.length; c < d.length; c++) {\n      if (void 0 !== d[c][a]) return d[c];\n    }return this.data.hierarchy[b].keys[0];\n  }, getPrevKeyWith: function getPrevKeyWith(a, b, c) {\n    var d = this.data.hierarchy[b].keys;for (c = this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? 0 < c ? c : 0 : 0 <= c ? c : c + d.length; 0 <= c; c--) {\n      if (void 0 !== d[c][a]) return d[c];\n    }return this.data.hierarchy[b].keys[d.length - 1];\n  } };\nTHREE.KeyFrameAnimation = function (a) {\n  this.root = a.node;this.data = THREE.AnimationHandler.init(a);this.hierarchy = THREE.AnimationHandler.parse(this.root);this.currentTime = 0;this.timeScale = .001;this.isPlaying = !1;this.loop = this.isPaused = !0;a = 0;for (var b = this.hierarchy.length; a < b; a++) {\n    var c = this.data.hierarchy[a].sids,\n        d = this.hierarchy[a];if (this.data.hierarchy[a].keys.length && c) {\n      for (var e = 0; e < c.length; e++) {\n        var f = c[e],\n            g = this.getNextKeyWith(f, a, 0);g && g.apply(f);\n      }d.matrixAutoUpdate = !1;this.data.hierarchy[a].node.updateMatrix();\n      d.matrixWorldNeedsUpdate = !0;\n    }\n  }\n};\nTHREE.KeyFrameAnimation.prototype = { constructor: THREE.KeyFrameAnimation, play: function play(a) {\n    this.currentTime = void 0 !== a ? a : 0;if (!1 === this.isPlaying) {\n      this.isPlaying = !0;var b = this.hierarchy.length,\n          c,\n          d;for (a = 0; a < b; a++) {\n        c = this.hierarchy[a], d = this.data.hierarchy[a], void 0 === d.animationCache && (d.animationCache = {}, d.animationCache.prevKey = null, d.animationCache.nextKey = null, d.animationCache.originalMatrix = c.matrix), c = this.data.hierarchy[a].keys, c.length && (d.animationCache.prevKey = c[0], d.animationCache.nextKey = c[1], this.startTime = Math.min(c[0].time, this.startTime), this.endTime = Math.max(c[c.length - 1].time, this.endTime));\n      }this.update(0);\n    }this.isPaused = !1;THREE.AnimationHandler.play(this);\n  }, stop: function stop() {\n    this.isPaused = this.isPlaying = !1;THREE.AnimationHandler.stop(this);for (var a = 0; a < this.data.hierarchy.length; a++) {\n      var b = this.hierarchy[a],\n          c = this.data.hierarchy[a];if (void 0 !== c.animationCache) {\n        var d = c.animationCache.originalMatrix;d.copy(b.matrix);b.matrix = d;delete c.animationCache;\n      }\n    }\n  }, update: function update(a) {\n    if (!1 !== this.isPlaying) {\n      this.currentTime += a * this.timeScale;a = this.data.length;!0 === this.loop && this.currentTime > a && (this.currentTime %= a);this.currentTime = Math.min(this.currentTime, a);a = 0;for (var b = this.hierarchy.length; a < b; a++) {\n        var c = this.hierarchy[a],\n            d = this.data.hierarchy[a],\n            e = d.keys,\n            d = d.animationCache;if (e.length) {\n          var f = d.prevKey,\n              g = d.nextKey;if (g.time <= this.currentTime) {\n            for (; g.time < this.currentTime && g.index > f.index;) {\n              f = g, g = e[f.index + 1];\n            }d.prevKey = f;d.nextKey = g;\n          }g.time >= this.currentTime ? f.interpolate(g, this.currentTime) : f.interpolate(g, g.time);this.data.hierarchy[a].node.updateMatrix();c.matrixWorldNeedsUpdate = !0;\n        }\n      }\n    }\n  }, getNextKeyWith: function getNextKeyWith(a, b, c) {\n    b = this.data.hierarchy[b].keys;for (c %= b.length; c < b.length; c++) {\n      if (b[c].hasTarget(a)) return b[c];\n    }return b[0];\n  }, getPrevKeyWith: function getPrevKeyWith(a, b, c) {\n    b = this.data.hierarchy[b].keys;for (c = 0 <= c ? c : c + b.length; 0 <= c; c--) {\n      if (b[c].hasTarget(a)) return b[c];\n    }return b[b.length - 1];\n  } };\nTHREE.MorphAnimation = function (a) {\n  this.mesh = a;this.frames = a.morphTargetInfluences.length;this.currentTime = 0;this.duration = 1E3;this.loop = !0;this.currentFrame = this.lastFrame = 0;this.isPlaying = !1;\n};\nTHREE.MorphAnimation.prototype = { constructor: THREE.MorphAnimation, play: function play() {\n    this.isPlaying = !0;\n  }, pause: function pause() {\n    this.isPlaying = !1;\n  }, update: function update(a) {\n    if (!1 !== this.isPlaying) {\n      this.currentTime += a;!0 === this.loop && this.currentTime > this.duration && (this.currentTime %= this.duration);this.currentTime = Math.min(this.currentTime, this.duration);a = this.duration / this.frames;var b = Math.floor(this.currentTime / a),\n          c = this.mesh.morphTargetInfluences;b != this.currentFrame && (c[this.lastFrame] = 0, c[this.currentFrame] = 1, c[b] = 0, this.lastFrame = this.currentFrame, this.currentFrame = b);c[b] = this.currentTime % a / a;c[this.lastFrame] = 1 - c[b];\n    }\n  } };\nTHREE.BoxGeometry = function (a, b, c, d, e, f) {\n  function g(a, b, c, d, e, f, g, s) {\n    var u,\n        v = h.widthSegments,\n        x = h.heightSegments,\n        D = e / 2,\n        w = f / 2,\n        y = h.vertices.length;if (\"x\" === a && \"y\" === b || \"y\" === a && \"x\" === b) u = \"z\";else if (\"x\" === a && \"z\" === b || \"z\" === a && \"x\" === b) u = \"y\", x = h.depthSegments;else if (\"z\" === a && \"y\" === b || \"y\" === a && \"z\" === b) u = \"x\", v = h.depthSegments;var A = v + 1,\n        E = x + 1,\n        G = e / v,\n        F = f / x,\n        z = new THREE.Vector3();z[u] = 0 < g ? 1 : -1;for (e = 0; e < E; e++) {\n      for (f = 0; f < A; f++) {\n        var I = new THREE.Vector3();I[a] = (f * G - D) * c;I[b] = (e * F - w) * d;I[u] = g;h.vertices.push(I);\n      }\n    }for (e = 0; e < x; e++) {\n      for (f = 0; f < v; f++) {\n        w = f + A * e, a = f + A * (e + 1), b = f + 1 + A * (e + 1), c = f + 1 + A * e, d = new THREE.Vector2(f / v, 1 - e / x), g = new THREE.Vector2(f / v, 1 - (e + 1) / x), u = new THREE.Vector2((f + 1) / v, 1 - (e + 1) / x), D = new THREE.Vector2((f + 1) / v, 1 - e / x), w = new THREE.Face3(w + y, a + y, c + y), w.normal.copy(z), w.vertexNormals.push(z.clone(), z.clone(), z.clone()), w.materialIndex = s, h.faces.push(w), h.faceVertexUvs[0].push([d, g, D]), w = new THREE.Face3(a + y, b + y, c + y), w.normal.copy(z), w.vertexNormals.push(z.clone(), z.clone(), z.clone()), w.materialIndex = s, h.faces.push(w), h.faceVertexUvs[0].push([g.clone(), u, D.clone()]);\n      }\n    }\n  }THREE.Geometry.call(this);this.type = \"BoxGeometry\";this.parameters = { width: a, height: b, depth: c, widthSegments: d, heightSegments: e, depthSegments: f };this.widthSegments = d || 1;this.heightSegments = e || 1;this.depthSegments = f || 1;var h = this;d = a / 2;e = b / 2;f = c / 2;g(\"z\", \"y\", -1, -1, c, b, d, 0);g(\"z\", \"y\", 1, -1, c, b, -d, 1);g(\"x\", \"z\", 1, 1, a, c, e, 2);g(\"x\", \"z\", 1, -1, a, c, -e, 3);g(\"x\", \"y\", 1, -1, a, b, f, 4);g(\"x\", \"y\", -1, -1, a, b, -f, 5);this.mergeVertices();\n};THREE.BoxGeometry.prototype = Object.create(THREE.Geometry.prototype);\nTHREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;\nTHREE.CircleGeometry = function (a, b, c, d) {\n  THREE.Geometry.call(this);this.type = \"CircleGeometry\";this.parameters = { radius: a, segments: b, thetaStart: c, thetaLength: d };a = a || 50;b = void 0 !== b ? Math.max(3, b) : 8;c = void 0 !== c ? c : 0;d = void 0 !== d ? d : 2 * Math.PI;var e,\n      f = [];e = new THREE.Vector3();var g = new THREE.Vector2(.5, .5);this.vertices.push(e);f.push(g);for (e = 0; e <= b; e++) {\n    var h = new THREE.Vector3(),\n        k = c + e / b * d;h.x = a * Math.cos(k);h.y = a * Math.sin(k);this.vertices.push(h);f.push(new THREE.Vector2((h.x / a + 1) / 2, (h.y / a + 1) / 2));\n  }c = new THREE.Vector3(0, 0, 1);for (e = 1; e <= b; e++) {\n    this.faces.push(new THREE.Face3(e, e + 1, 0, [c.clone(), c.clone(), c.clone()])), this.faceVertexUvs[0].push([f[e].clone(), f[e + 1].clone(), g.clone()]);\n  }this.computeFaceNormals();this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), a);\n};THREE.CircleGeometry.prototype = Object.create(THREE.Geometry.prototype);THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;\nTHREE.CubeGeometry = function (a, b, c, d, e, f) {\n  THREE.warn(\"THREE.CubeGeometry has been renamed to THREE.BoxGeometry.\");return new THREE.BoxGeometry(a, b, c, d, e, f);\n};\nTHREE.CylinderGeometry = function (a, b, c, d, e, f, g, h) {\n  THREE.Geometry.call(this);this.type = \"CylinderGeometry\";this.parameters = { radiusTop: a, radiusBottom: b, height: c, radialSegments: d, heightSegments: e, openEnded: f, thetaStart: g, thetaLength: h };a = void 0 !== a ? a : 20;b = void 0 !== b ? b : 20;c = void 0 !== c ? c : 100;d = d || 8;e = e || 1;f = void 0 !== f ? f : !1;g = void 0 !== g ? g : 0;h = void 0 !== h ? h : 2 * Math.PI;var k = c / 2,\n      l,\n      p,\n      q = [],\n      n = [];for (p = 0; p <= e; p++) {\n    var t = [],\n        r = [],\n        s = p / e,\n        u = s * (b - a) + a;for (l = 0; l <= d; l++) {\n      var v = l / d,\n          x = new THREE.Vector3();x.x = u * Math.sin(v * h + g);x.y = -s * c + k;x.z = u * Math.cos(v * h + g);this.vertices.push(x);t.push(this.vertices.length - 1);r.push(new THREE.Vector2(v, 1 - s));\n    }q.push(t);n.push(r);\n  }c = (b - a) / c;for (l = 0; l < d; l++) {\n    for (0 !== a ? (g = this.vertices[q[0][l]].clone(), h = this.vertices[q[0][l + 1]].clone()) : (g = this.vertices[q[1][l]].clone(), h = this.vertices[q[1][l + 1]].clone()), g.setY(Math.sqrt(g.x * g.x + g.z * g.z) * c).normalize(), h.setY(Math.sqrt(h.x * h.x + h.z * h.z) * c).normalize(), p = 0; p < e; p++) {\n      var t = q[p][l],\n          r = q[p + 1][l],\n          s = q[p + 1][l + 1],\n          u = q[p][l + 1],\n          v = g.clone(),\n          x = g.clone(),\n          D = h.clone(),\n          w = h.clone(),\n          y = n[p][l].clone(),\n          A = n[p + 1][l].clone(),\n          E = n[p + 1][l + 1].clone(),\n          G = n[p][l + 1].clone();this.faces.push(new THREE.Face3(t, r, u, [v, x, w]));this.faceVertexUvs[0].push([y, A, G]);this.faces.push(new THREE.Face3(r, s, u, [x.clone(), D, w.clone()]));this.faceVertexUvs[0].push([A.clone(), E, G.clone()]);\n    }\n  }if (!1 === f && 0 < a) for (this.vertices.push(new THREE.Vector3(0, k, 0)), l = 0; l < d; l++) {\n    t = q[0][l], r = q[0][l + 1], s = this.vertices.length - 1, v = new THREE.Vector3(0, 1, 0), x = new THREE.Vector3(0, 1, 0), D = new THREE.Vector3(0, 1, 0), y = n[0][l].clone(), A = n[0][l + 1].clone(), E = new THREE.Vector2(A.x, 0), this.faces.push(new THREE.Face3(t, r, s, [v, x, D])), this.faceVertexUvs[0].push([y, A, E]);\n  }if (!1 === f && 0 < b) for (this.vertices.push(new THREE.Vector3(0, -k, 0)), l = 0; l < d; l++) {\n    t = q[e][l + 1], r = q[e][l], s = this.vertices.length - 1, v = new THREE.Vector3(0, -1, 0), x = new THREE.Vector3(0, -1, 0), D = new THREE.Vector3(0, -1, 0), y = n[e][l + 1].clone(), A = n[e][l].clone(), E = new THREE.Vector2(A.x, 1), this.faces.push(new THREE.Face3(t, r, s, [v, x, D])), this.faceVertexUvs[0].push([y, A, E]);\n  }this.computeFaceNormals();\n};THREE.CylinderGeometry.prototype = Object.create(THREE.Geometry.prototype);THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;THREE.ExtrudeGeometry = function (a, b) {\n  \"undefined\" !== typeof a && (THREE.Geometry.call(this), this.type = \"ExtrudeGeometry\", a = a instanceof Array ? a : [a], this.addShapeList(a, b), this.computeFaceNormals());\n};THREE.ExtrudeGeometry.prototype = Object.create(THREE.Geometry.prototype);THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;\nTHREE.ExtrudeGeometry.prototype.addShapeList = function (a, b) {\n  for (var c = a.length, d = 0; d < c; d++) {\n    this.addShape(a[d], b);\n  }\n};\nTHREE.ExtrudeGeometry.prototype.addShape = function (a, b) {\n  function c(a, b, c) {\n    b || THREE.error(\"THREE.ExtrudeGeometry: vec does not exist\");return b.clone().multiplyScalar(c).add(a);\n  }function d(a, b, c) {\n    var d = 1,\n        d = a.x - b.x,\n        e = a.y - b.y,\n        f = c.x - a.x,\n        g = c.y - a.y,\n        h = d * d + e * e;if (1E-10 < Math.abs(d * g - e * f)) {\n      var k = Math.sqrt(h),\n          l = Math.sqrt(f * f + g * g),\n          h = b.x - e / k;b = b.y + d / k;f = ((c.x - g / l - h) * g - (c.y + f / l - b) * f) / (d * g - e * f);c = h + d * f - a.x;a = b + e * f - a.y;d = c * c + a * a;if (2 >= d) return new THREE.Vector2(c, a);d = Math.sqrt(d / 2);\n    } else a = !1, 1E-10 < d ? 1E-10 < f && (a = !0) : -1E-10 > d ? -1E-10 > f && (a = !0) : Math.sign(e) == Math.sign(g) && (a = !0), a ? (c = -e, a = d, d = Math.sqrt(h)) : (c = d, a = e, d = Math.sqrt(h / 2));return new THREE.Vector2(c / d, a / d);\n  }function e(a, b) {\n    var c, d;for (O = a.length; 0 <= --O;) {\n      c = O;d = O - 1;0 > d && (d = a.length - 1);for (var e = 0, f = t + 2 * p, e = 0; e < f; e++) {\n        var g = oa * e,\n            h = oa * (e + 1),\n            k = b + c + g,\n            g = b + d + g,\n            l = b + d + h,\n            h = b + c + h,\n            k = k + U,\n            g = g + U,\n            l = l + U,\n            h = h + U;I.faces.push(new THREE.Face3(k, g, h, null, null, x));I.faces.push(new THREE.Face3(g, l, h, null, null, x));k = D.generateSideWallUV(I, k, g, l, h);I.faceVertexUvs[0].push([k[0], k[1], k[3]]);I.faceVertexUvs[0].push([k[1], k[2], k[3]]);\n      }\n    }\n  }function f(a, b, c) {\n    I.vertices.push(new THREE.Vector3(a, b, c));\n  }function g(a, b, c) {\n    a += U;b += U;c += U;I.faces.push(new THREE.Face3(a, b, c, null, null, v));a = D.generateTopUV(I, a, b, c);I.faceVertexUvs[0].push(a);\n  }var h = void 0 !== b.amount ? b.amount : 100,\n      k = void 0 !== b.bevelThickness ? b.bevelThickness : 6,\n      l = void 0 !== b.bevelSize ? b.bevelSize : k - 2,\n      p = void 0 !== b.bevelSegments ? b.bevelSegments : 3,\n      q = void 0 !== b.bevelEnabled ? b.bevelEnabled : !0,\n      n = void 0 !== b.curveSegments ? b.curveSegments : 12,\n      t = void 0 !== b.steps ? b.steps : 1,\n      r = b.extrudePath,\n      s,\n      u = !1,\n      v = b.material,\n      x = b.extrudeMaterial,\n      D = void 0 !== b.UVGenerator ? b.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator,\n      w,\n      y,\n      A,\n      E;r && (s = r.getSpacedPoints(t), u = !0, q = !1, w = void 0 !== b.frames ? b.frames : new THREE.TubeGeometry.FrenetFrames(r, t, !1), y = new THREE.Vector3(), A = new THREE.Vector3(), E = new THREE.Vector3());q || (l = k = p = 0);var G,\n      F,\n      z,\n      I = this,\n      U = this.vertices.length,\n      r = a.extractPoints(n),\n      n = r.shape,\n      M = r.holes;if (r = !THREE.Shape.Utils.isClockWise(n)) {\n    n = n.reverse();F = 0;for (z = M.length; F < z; F++) {\n      G = M[F], THREE.Shape.Utils.isClockWise(G) && (M[F] = G.reverse());\n    }r = !1;\n  }var H = THREE.Shape.Utils.triangulateShape(n, M),\n      L = n;F = 0;for (z = M.length; F < z; F++) {\n    G = M[F], n = n.concat(G);\n  }var P,\n      N,\n      R,\n      V,\n      J,\n      oa = n.length,\n      ja,\n      ha = H.length,\n      r = [],\n      O = 0;R = L.length;P = R - 1;for (N = O + 1; O < R; O++, P++, N++) {\n    P === R && (P = 0), N === R && (N = 0), r[O] = d(L[O], L[P], L[N]);\n  }var ca = [],\n      ba,\n      qa = r.concat();F = 0;for (z = M.length; F < z; F++) {\n    G = M[F];ba = [];O = 0;R = G.length;P = R - 1;for (N = O + 1; O < R; O++, P++, N++) {\n      P === R && (P = 0), N === R && (N = 0), ba[O] = d(G[O], G[P], G[N]);\n    }ca.push(ba);qa = qa.concat(ba);\n  }for (P = 0; P < p; P++) {\n    R = P / p;V = k * (1 - R);N = l * Math.sin(R * Math.PI / 2);O = 0;for (R = L.length; O < R; O++) {\n      J = c(L[O], r[O], N), f(J.x, J.y, -V);\n    }F = 0;for (z = M.length; F < z; F++) {\n      for (G = M[F], ba = ca[F], O = 0, R = G.length; O < R; O++) {\n        J = c(G[O], ba[O], N), f(J.x, J.y, -V);\n      }\n    }\n  }N = l;for (O = 0; O < oa; O++) {\n    J = q ? c(n[O], qa[O], N) : n[O], u ? (A.copy(w.normals[0]).multiplyScalar(J.x), y.copy(w.binormals[0]).multiplyScalar(J.y), E.copy(s[0]).add(A).add(y), f(E.x, E.y, E.z)) : f(J.x, J.y, 0);\n  }for (R = 1; R <= t; R++) {\n    for (O = 0; O < oa; O++) {\n      J = q ? c(n[O], qa[O], N) : n[O], u ? (A.copy(w.normals[R]).multiplyScalar(J.x), y.copy(w.binormals[R]).multiplyScalar(J.y), E.copy(s[R]).add(A).add(y), f(E.x, E.y, E.z)) : f(J.x, J.y, h / t * R);\n    }\n  }for (P = p - 1; 0 <= P; P--) {\n    R = P / p;V = k * (1 - R);N = l * Math.sin(R * Math.PI / 2);O = 0;for (R = L.length; O < R; O++) {\n      J = c(L[O], r[O], N), f(J.x, J.y, h + V);\n    }F = 0;for (z = M.length; F < z; F++) {\n      for (G = M[F], ba = ca[F], O = 0, R = G.length; O < R; O++) {\n        J = c(G[O], ba[O], N), u ? f(J.x, J.y + s[t - 1].y, s[t - 1].x + V) : f(J.x, J.y, h + V);\n      }\n    }\n  }(function () {\n    if (q) {\n      var a;a = 0 * oa;for (O = 0; O < ha; O++) {\n        ja = H[O], g(ja[2] + a, ja[1] + a, ja[0] + a);\n      }a = t + 2 * p;a *= oa;for (O = 0; O < ha; O++) {\n        ja = H[O], g(ja[0] + a, ja[1] + a, ja[2] + a);\n      }\n    } else {\n      for (O = 0; O < ha; O++) {\n        ja = H[O], g(ja[2], ja[1], ja[0]);\n      }for (O = 0; O < ha; O++) {\n        ja = H[O], g(ja[0] + oa * t, ja[1] + oa * t, ja[2] + oa * t);\n      }\n    }\n  })();(function () {\n    var a = 0;e(L, a);a += L.length;F = 0;for (z = M.length; F < z; F++) {\n      G = M[F], e(G, a), a += G.length;\n    }\n  })();\n};\nTHREE.ExtrudeGeometry.WorldUVGenerator = { generateTopUV: function generateTopUV(a, b, c, d) {\n    a = a.vertices;b = a[b];c = a[c];d = a[d];return [new THREE.Vector2(b.x, b.y), new THREE.Vector2(c.x, c.y), new THREE.Vector2(d.x, d.y)];\n  }, generateSideWallUV: function generateSideWallUV(a, b, c, d, e) {\n    a = a.vertices;b = a[b];c = a[c];d = a[d];e = a[e];return .01 > Math.abs(b.y - c.y) ? [new THREE.Vector2(b.x, 1 - b.z), new THREE.Vector2(c.x, 1 - c.z), new THREE.Vector2(d.x, 1 - d.z), new THREE.Vector2(e.x, 1 - e.z)] : [new THREE.Vector2(b.y, 1 - b.z), new THREE.Vector2(c.y, 1 - c.z), new THREE.Vector2(d.y, 1 - d.z), new THREE.Vector2(e.y, 1 - e.z)];\n  } };THREE.ShapeGeometry = function (a, b) {\n  THREE.Geometry.call(this);this.type = \"ShapeGeometry\";!1 === a instanceof Array && (a = [a]);this.addShapeList(a, b);this.computeFaceNormals();\n};THREE.ShapeGeometry.prototype = Object.create(THREE.Geometry.prototype);THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;THREE.ShapeGeometry.prototype.addShapeList = function (a, b) {\n  for (var c = 0, d = a.length; c < d; c++) {\n    this.addShape(a[c], b);\n  }return this;\n};\nTHREE.ShapeGeometry.prototype.addShape = function (a, b) {\n  void 0 === b && (b = {});var c = b.material,\n      d = void 0 === b.UVGenerator ? THREE.ExtrudeGeometry.WorldUVGenerator : b.UVGenerator,\n      e,\n      f,\n      g,\n      h = this.vertices.length;e = a.extractPoints(void 0 !== b.curveSegments ? b.curveSegments : 12);var k = e.shape,\n      l = e.holes;if (!THREE.Shape.Utils.isClockWise(k)) for (k = k.reverse(), e = 0, f = l.length; e < f; e++) {\n    g = l[e], THREE.Shape.Utils.isClockWise(g) && (l[e] = g.reverse());\n  }var p = THREE.Shape.Utils.triangulateShape(k, l);e = 0;for (f = l.length; e < f; e++) {\n    g = l[e], k = k.concat(g);\n  }l = k.length;f = p.length;for (e = 0; e < l; e++) {\n    g = k[e], this.vertices.push(new THREE.Vector3(g.x, g.y, 0));\n  }for (e = 0; e < f; e++) {\n    l = p[e], k = l[0] + h, g = l[1] + h, l = l[2] + h, this.faces.push(new THREE.Face3(k, g, l, null, null, c)), this.faceVertexUvs[0].push(d.generateTopUV(this, k, g, l));\n  }\n};\nTHREE.LatheGeometry = function (a, b, c, d) {\n  THREE.Geometry.call(this);this.type = \"LatheGeometry\";this.parameters = { points: a, segments: b, phiStart: c, phiLength: d };b = b || 12;c = c || 0;d = d || 2 * Math.PI;for (var e = 1 / (a.length - 1), f = 1 / b, g = 0, h = b; g <= h; g++) {\n    for (var k = c + g * f * d, l = Math.cos(k), p = Math.sin(k), k = 0, q = a.length; k < q; k++) {\n      var n = a[k],\n          t = new THREE.Vector3();t.x = l * n.x - p * n.y;t.y = p * n.x + l * n.y;t.z = n.z;this.vertices.push(t);\n    }\n  }c = a.length;g = 0;for (h = b; g < h; g++) {\n    for (k = 0, q = a.length - 1; k < q; k++) {\n      b = p = k + c * g;d = p + c;var l = p + 1 + c,\n          p = p + 1,\n          n = g * f,\n          t = k * e,\n          r = n + f,\n          s = t + e;this.faces.push(new THREE.Face3(b, d, p));this.faceVertexUvs[0].push([new THREE.Vector2(n, t), new THREE.Vector2(r, t), new THREE.Vector2(n, s)]);this.faces.push(new THREE.Face3(d, l, p));this.faceVertexUvs[0].push([new THREE.Vector2(r, t), new THREE.Vector2(r, s), new THREE.Vector2(n, s)]);\n    }\n  }this.mergeVertices();this.computeFaceNormals();this.computeVertexNormals();\n};THREE.LatheGeometry.prototype = Object.create(THREE.Geometry.prototype);THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;\nTHREE.PlaneGeometry = function (a, b, c, d) {\n  console.info(\"THREE.PlaneGeometry: Consider using THREE.PlaneBufferGeometry for lower memory footprint.\");THREE.Geometry.call(this);this.type = \"PlaneGeometry\";this.parameters = { width: a, height: b, widthSegments: c, heightSegments: d };this.fromBufferGeometry(new THREE.PlaneBufferGeometry(a, b, c, d));\n};THREE.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype);THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;\nTHREE.PlaneBufferGeometry = function (a, b, c, d) {\n  THREE.BufferGeometry.call(this);this.type = \"PlaneBufferGeometry\";this.parameters = { width: a, height: b, widthSegments: c, heightSegments: d };var e = a / 2,\n      f = b / 2;c = c || 1;d = d || 1;var g = c + 1,\n      h = d + 1,\n      k = a / c,\n      l = b / d;b = new Float32Array(g * h * 3);a = new Float32Array(g * h * 3);for (var p = new Float32Array(g * h * 2), q = 0, n = 0, t = 0; t < h; t++) {\n    for (var r = t * l - f, s = 0; s < g; s++) {\n      b[q] = s * k - e, b[q + 1] = -r, a[q + 2] = 1, p[n] = s / c, p[n + 1] = 1 - t / d, q += 3, n += 2;\n    }\n  }q = 0;e = new (65535 < b.length / 3 ? Uint32Array : Uint16Array)(c * d * 6);for (t = 0; t < d; t++) {\n    for (s = 0; s < c; s++) {\n      f = s + g * (t + 1), h = s + 1 + g * (t + 1), k = s + 1 + g * t, e[q] = s + g * t, e[q + 1] = f, e[q + 2] = k, e[q + 3] = f, e[q + 4] = h, e[q + 5] = k, q += 6;\n    }\n  }this.addAttribute(\"index\", new THREE.BufferAttribute(e, 1));this.addAttribute(\"position\", new THREE.BufferAttribute(b, 3));this.addAttribute(\"normal\", new THREE.BufferAttribute(a, 3));this.addAttribute(\"uv\", new THREE.BufferAttribute(p, 2));\n};THREE.PlaneBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;\nTHREE.RingGeometry = function (a, b, c, d, e, f) {\n  THREE.Geometry.call(this);this.type = \"RingGeometry\";this.parameters = { innerRadius: a, outerRadius: b, thetaSegments: c, phiSegments: d, thetaStart: e, thetaLength: f };a = a || 0;b = b || 50;e = void 0 !== e ? e : 0;f = void 0 !== f ? f : 2 * Math.PI;c = void 0 !== c ? Math.max(3, c) : 8;d = void 0 !== d ? Math.max(1, d) : 8;var g,\n      h = [],\n      k = a,\n      l = (b - a) / d;for (a = 0; a < d + 1; a++) {\n    for (g = 0; g < c + 1; g++) {\n      var p = new THREE.Vector3(),\n          q = e + g / c * f;p.x = k * Math.cos(q);p.y = k * Math.sin(q);this.vertices.push(p);h.push(new THREE.Vector2((p.x / b + 1) / 2, (p.y / b + 1) / 2));\n    }k += l;\n  }b = new THREE.Vector3(0, 0, 1);for (a = 0; a < d; a++) {\n    for (e = a * (c + 1), g = 0; g < c; g++) {\n      f = q = g + e, l = q + c + 1, p = q + c + 2, this.faces.push(new THREE.Face3(f, l, p, [b.clone(), b.clone(), b.clone()])), this.faceVertexUvs[0].push([h[f].clone(), h[l].clone(), h[p].clone()]), f = q, l = q + c + 2, p = q + 1, this.faces.push(new THREE.Face3(f, l, p, [b.clone(), b.clone(), b.clone()])), this.faceVertexUvs[0].push([h[f].clone(), h[l].clone(), h[p].clone()]);\n    }\n  }this.computeFaceNormals();this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), k);\n};\nTHREE.RingGeometry.prototype = Object.create(THREE.Geometry.prototype);THREE.RingGeometry.prototype.constructor = THREE.RingGeometry;\nTHREE.SphereGeometry = function (a, b, c, d, e, f, g) {\n  THREE.Geometry.call(this);this.type = \"SphereGeometry\";this.parameters = { radius: a, widthSegments: b, heightSegments: c, phiStart: d, phiLength: e, thetaStart: f, thetaLength: g };a = a || 50;b = Math.max(3, Math.floor(b) || 8);c = Math.max(2, Math.floor(c) || 6);d = void 0 !== d ? d : 0;e = void 0 !== e ? e : 2 * Math.PI;f = void 0 !== f ? f : 0;g = void 0 !== g ? g : Math.PI;var h,\n      k,\n      l = [],\n      p = [];for (k = 0; k <= c; k++) {\n    var q = [],\n        n = [];for (h = 0; h <= b; h++) {\n      var t = h / b,\n          r = k / c,\n          s = new THREE.Vector3();s.x = -a * Math.cos(d + t * e) * Math.sin(f + r * g);\n      s.y = a * Math.cos(f + r * g);s.z = a * Math.sin(d + t * e) * Math.sin(f + r * g);this.vertices.push(s);q.push(this.vertices.length - 1);n.push(new THREE.Vector2(t, 1 - r));\n    }l.push(q);p.push(n);\n  }for (k = 0; k < c; k++) {\n    for (h = 0; h < b; h++) {\n      d = l[k][h + 1];e = l[k][h];f = l[k + 1][h];g = l[k + 1][h + 1];var q = this.vertices[d].clone().normalize(),\n          n = this.vertices[e].clone().normalize(),\n          t = this.vertices[f].clone().normalize(),\n          r = this.vertices[g].clone().normalize(),\n          s = p[k][h + 1].clone(),\n          u = p[k][h].clone(),\n          v = p[k + 1][h].clone(),\n          x = p[k + 1][h + 1].clone();Math.abs(this.vertices[d].y) === a ? (s.x = (s.x + u.x) / 2, this.faces.push(new THREE.Face3(d, f, g, [q, t, r])), this.faceVertexUvs[0].push([s, v, x])) : Math.abs(this.vertices[f].y) === a ? (v.x = (v.x + x.x) / 2, this.faces.push(new THREE.Face3(d, e, f, [q, n, t])), this.faceVertexUvs[0].push([s, u, v])) : (this.faces.push(new THREE.Face3(d, e, g, [q, n, r])), this.faceVertexUvs[0].push([s, u, x]), this.faces.push(new THREE.Face3(e, f, g, [n.clone(), t, r.clone()])), this.faceVertexUvs[0].push([u.clone(), v, x.clone()]));\n    }\n  }this.computeFaceNormals();this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), a);\n};THREE.SphereGeometry.prototype = Object.create(THREE.Geometry.prototype);THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;THREE.TextGeometry = function (a, b) {\n  b = b || {};var c = THREE.FontUtils.generateShapes(a, b);b.amount = void 0 !== b.height ? b.height : 50;void 0 === b.bevelThickness && (b.bevelThickness = 10);void 0 === b.bevelSize && (b.bevelSize = 8);void 0 === b.bevelEnabled && (b.bevelEnabled = !1);THREE.ExtrudeGeometry.call(this, c, b);this.type = \"TextGeometry\";\n};THREE.TextGeometry.prototype = Object.create(THREE.ExtrudeGeometry.prototype);\nTHREE.TextGeometry.prototype.constructor = THREE.TextGeometry;\nTHREE.TorusGeometry = function (a, b, c, d, e) {\n  THREE.Geometry.call(this);this.type = \"TorusGeometry\";this.parameters = { radius: a, tube: b, radialSegments: c, tubularSegments: d, arc: e };a = a || 100;b = b || 40;c = c || 8;d = d || 6;e = e || 2 * Math.PI;for (var f = new THREE.Vector3(), g = [], h = [], k = 0; k <= c; k++) {\n    for (var l = 0; l <= d; l++) {\n      var p = l / d * e,\n          q = k / c * Math.PI * 2;f.x = a * Math.cos(p);f.y = a * Math.sin(p);var n = new THREE.Vector3();n.x = (a + b * Math.cos(q)) * Math.cos(p);n.y = (a + b * Math.cos(q)) * Math.sin(p);n.z = b * Math.sin(q);this.vertices.push(n);g.push(new THREE.Vector2(l / d, k / c));h.push(n.clone().sub(f).normalize());\n    }\n  }for (k = 1; k <= c; k++) {\n    for (l = 1; l <= d; l++) {\n      a = (d + 1) * k + l - 1, b = (d + 1) * (k - 1) + l - 1, e = (d + 1) * (k - 1) + l, f = (d + 1) * k + l, p = new THREE.Face3(a, b, f, [h[a].clone(), h[b].clone(), h[f].clone()]), this.faces.push(p), this.faceVertexUvs[0].push([g[a].clone(), g[b].clone(), g[f].clone()]), p = new THREE.Face3(b, e, f, [h[b].clone(), h[e].clone(), h[f].clone()]), this.faces.push(p), this.faceVertexUvs[0].push([g[b].clone(), g[e].clone(), g[f].clone()]);\n    }\n  }this.computeFaceNormals();\n};\nTHREE.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype);THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;\nTHREE.TorusKnotGeometry = function (a, b, c, d, e, f, g) {\n  function h(a, b, c, d, e) {\n    var f = Math.cos(a),\n        g = Math.sin(a);a *= b / c;b = Math.cos(a);f *= d * (2 + b) * .5;g = d * (2 + b) * g * .5;d = e * d * Math.sin(a) * .5;return new THREE.Vector3(f, g, d);\n  }THREE.Geometry.call(this);this.type = \"TorusKnotGeometry\";this.parameters = { radius: a, tube: b, radialSegments: c, tubularSegments: d, p: e, q: f, heightScale: g };a = a || 100;b = b || 40;c = c || 64;d = d || 8;e = e || 2;f = f || 3;g = g || 1;for (var k = Array(c), l = new THREE.Vector3(), p = new THREE.Vector3(), q = new THREE.Vector3(), n = 0; n < c; ++n) {\n    k[n] = Array(d);var t = n / c * 2 * e * Math.PI,\n        r = h(t, f, e, a, g),\n        t = h(t + .01, f, e, a, g);l.subVectors(t, r);p.addVectors(t, r);q.crossVectors(l, p);p.crossVectors(q, l);q.normalize();p.normalize();for (t = 0; t < d; ++t) {\n      var s = t / d * 2 * Math.PI,\n          u = -b * Math.cos(s),\n          s = b * Math.sin(s),\n          v = new THREE.Vector3();v.x = r.x + u * p.x + s * q.x;v.y = r.y + u * p.y + s * q.y;v.z = r.z + u * p.z + s * q.z;k[n][t] = this.vertices.push(v) - 1;\n    }\n  }for (n = 0; n < c; ++n) {\n    for (t = 0; t < d; ++t) {\n      e = (n + 1) % c, f = (t + 1) % d, a = k[n][t], b = k[e][t], e = k[e][f], f = k[n][f], g = new THREE.Vector2(n / c, t / d), l = new THREE.Vector2((n + 1) / c, t / d), p = new THREE.Vector2((n + 1) / c, (t + 1) / d), q = new THREE.Vector2(n / c, (t + 1) / d), this.faces.push(new THREE.Face3(a, b, f)), this.faceVertexUvs[0].push([g, l, q]), this.faces.push(new THREE.Face3(b, e, f)), this.faceVertexUvs[0].push([l.clone(), p, q.clone()]);\n    }\n  }this.computeFaceNormals();this.computeVertexNormals();\n};THREE.TorusKnotGeometry.prototype = Object.create(THREE.Geometry.prototype);THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;\nTHREE.TubeGeometry = function (a, b, c, d, e, f) {\n  THREE.Geometry.call(this);this.type = \"TubeGeometry\";this.parameters = { path: a, segments: b, radius: c, radialSegments: d, closed: e };b = b || 64;c = c || 1;d = d || 8;e = e || !1;f = f || THREE.TubeGeometry.NoTaper;var g = [],\n      h,\n      k,\n      l = b + 1,\n      p,\n      q,\n      n,\n      t,\n      r,\n      s = new THREE.Vector3(),\n      u,\n      v,\n      x;u = new THREE.TubeGeometry.FrenetFrames(a, b, e);v = u.normals;x = u.binormals;this.tangents = u.tangents;this.normals = v;this.binormals = x;for (u = 0; u < l; u++) {\n    for (g[u] = [], p = u / (l - 1), r = a.getPointAt(p), h = v[u], k = x[u], n = c * f(p), p = 0; p < d; p++) {\n      q = p / d * 2 * Math.PI, t = -n * Math.cos(q), q = n * Math.sin(q), s.copy(r), s.x += t * h.x + q * k.x, s.y += t * h.y + q * k.y, s.z += t * h.z + q * k.z, g[u][p] = this.vertices.push(new THREE.Vector3(s.x, s.y, s.z)) - 1;\n    }\n  }for (u = 0; u < b; u++) {\n    for (p = 0; p < d; p++) {\n      f = e ? (u + 1) % b : u + 1, l = (p + 1) % d, a = g[u][p], c = g[f][p], f = g[f][l], l = g[u][l], s = new THREE.Vector2(u / b, p / d), v = new THREE.Vector2((u + 1) / b, p / d), x = new THREE.Vector2((u + 1) / b, (p + 1) / d), h = new THREE.Vector2(u / b, (p + 1) / d), this.faces.push(new THREE.Face3(a, c, l)), this.faceVertexUvs[0].push([s, v, h]), this.faces.push(new THREE.Face3(c, f, l)), this.faceVertexUvs[0].push([v.clone(), x, h.clone()]);\n    }\n  }this.computeFaceNormals();this.computeVertexNormals();\n};THREE.TubeGeometry.prototype = Object.create(THREE.Geometry.prototype);THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;THREE.TubeGeometry.NoTaper = function (a) {\n  return 1;\n};THREE.TubeGeometry.SinusoidalTaper = function (a) {\n  return Math.sin(Math.PI * a);\n};\nTHREE.TubeGeometry.FrenetFrames = function (a, b, c) {\n  var d = new THREE.Vector3(),\n      e = [],\n      f = [],\n      g = [],\n      h = new THREE.Vector3(),\n      k = new THREE.Matrix4();b += 1;var l, p, q;this.tangents = e;this.normals = f;this.binormals = g;for (l = 0; l < b; l++) {\n    p = l / (b - 1), e[l] = a.getTangentAt(p), e[l].normalize();\n  }f[0] = new THREE.Vector3();g[0] = new THREE.Vector3();a = Number.MAX_VALUE;l = Math.abs(e[0].x);p = Math.abs(e[0].y);q = Math.abs(e[0].z);l <= a && (a = l, d.set(1, 0, 0));p <= a && (a = p, d.set(0, 1, 0));q <= a && d.set(0, 0, 1);h.crossVectors(e[0], d).normalize();f[0].crossVectors(e[0], h);g[0].crossVectors(e[0], f[0]);for (l = 1; l < b; l++) {\n    f[l] = f[l - 1].clone(), g[l] = g[l - 1].clone(), h.crossVectors(e[l - 1], e[l]), 1E-4 < h.length() && (h.normalize(), d = Math.acos(THREE.Math.clamp(e[l - 1].dot(e[l]), -1, 1)), f[l].applyMatrix4(k.makeRotationAxis(h, d))), g[l].crossVectors(e[l], f[l]);\n  }if (c) for (d = Math.acos(THREE.Math.clamp(f[0].dot(f[b - 1]), -1, 1)), d /= b - 1, 0 < e[0].dot(h.crossVectors(f[0], f[b - 1])) && (d = -d), l = 1; l < b; l++) {\n    f[l].applyMatrix4(k.makeRotationAxis(e[l], d * l)), g[l].crossVectors(e[l], f[l]);\n  }\n};\nTHREE.PolyhedronGeometry = function (a, b, c, d) {\n  function e(a) {\n    var b = a.normalize().clone();b.index = k.vertices.push(b) - 1;var c = Math.atan2(a.z, -a.x) / 2 / Math.PI + .5;a = Math.atan2(-a.y, Math.sqrt(a.x * a.x + a.z * a.z)) / Math.PI + .5;b.uv = new THREE.Vector2(c, 1 - a);return b;\n  }function f(a, b, c) {\n    var d = new THREE.Face3(a.index, b.index, c.index, [a.clone(), b.clone(), c.clone()]);k.faces.push(d);u.copy(a).add(b).add(c).divideScalar(3);d = Math.atan2(u.z, -u.x);k.faceVertexUvs[0].push([h(a.uv, a, d), h(b.uv, b, d), h(c.uv, c, d)]);\n  }function g(a, b) {\n    for (var c = Math.pow(2, b), d = e(k.vertices[a.a]), g = e(k.vertices[a.b]), h = e(k.vertices[a.c]), l = [], n = 0; n <= c; n++) {\n      l[n] = [];for (var p = e(d.clone().lerp(h, n / c)), q = e(g.clone().lerp(h, n / c)), s = c - n, r = 0; r <= s; r++) {\n        l[n][r] = 0 == r && n == c ? p : e(p.clone().lerp(q, r / s));\n      }\n    }for (n = 0; n < c; n++) {\n      for (r = 0; r < 2 * (c - n) - 1; r++) {\n        d = Math.floor(r / 2), 0 == r % 2 ? f(l[n][d + 1], l[n + 1][d], l[n][d]) : f(l[n][d + 1], l[n + 1][d + 1], l[n + 1][d]);\n      }\n    }\n  }function h(a, b, c) {\n    0 > c && 1 === a.x && (a = new THREE.Vector2(a.x - 1, a.y));0 === b.x && 0 === b.z && (a = new THREE.Vector2(c / 2 / Math.PI + .5, a.y));return a.clone();\n  }\n  THREE.Geometry.call(this);this.type = \"PolyhedronGeometry\";this.parameters = { vertices: a, indices: b, radius: c, detail: d };c = c || 1;d = d || 0;for (var k = this, l = 0, p = a.length; l < p; l += 3) {\n    e(new THREE.Vector3(a[l], a[l + 1], a[l + 2]));\n  }a = this.vertices;for (var q = [], n = l = 0, p = b.length; l < p; l += 3, n++) {\n    var t = a[b[l]],\n        r = a[b[l + 1]],\n        s = a[b[l + 2]];q[n] = new THREE.Face3(t.index, r.index, s.index, [t.clone(), r.clone(), s.clone()]);\n  }for (var u = new THREE.Vector3(), l = 0, p = q.length; l < p; l++) {\n    g(q[l], d);\n  }l = 0;for (p = this.faceVertexUvs[0].length; l < p; l++) {\n    b = this.faceVertexUvs[0][l], d = b[0].x, a = b[1].x, q = b[2].x, n = Math.max(d, Math.max(a, q)), t = Math.min(d, Math.min(a, q)), .9 < n && .1 > t && (.2 > d && (b[0].x += 1), .2 > a && (b[1].x += 1), .2 > q && (b[2].x += 1));\n  }l = 0;for (p = this.vertices.length; l < p; l++) {\n    this.vertices[l].multiplyScalar(c);\n  }this.mergeVertices();this.computeFaceNormals();this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), c);\n};THREE.PolyhedronGeometry.prototype = Object.create(THREE.Geometry.prototype);THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;\nTHREE.DodecahedronGeometry = function (a, b) {\n  this.parameters = { radius: a, detail: b };var c = (1 + Math.sqrt(5)) / 2,\n      d = 1 / c;THREE.PolyhedronGeometry.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -d, -c, 0, -d, c, 0, d, -c, 0, d, c, -d, -c, 0, -d, c, 0, d, -c, 0, d, c, 0, -c, 0, -d, c, 0, -d, -c, 0, d, c, 0, d], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], a, b);\n};THREE.DodecahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);THREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;\nTHREE.IcosahedronGeometry = function (a, b) {\n  var c = (1 + Math.sqrt(5)) / 2;THREE.PolyhedronGeometry.call(this, [-1, c, 0, 1, c, 0, -1, -c, 0, 1, -c, 0, 0, -1, c, 0, 1, c, 0, -1, -c, 0, 1, -c, c, 0, -1, c, 0, 1, -c, 0, -1, -c, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], a, b);this.type = \"IcosahedronGeometry\";this.parameters = { radius: a, detail: b };\n};THREE.IcosahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);\nTHREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;THREE.OctahedronGeometry = function (a, b) {\n  this.parameters = { radius: a, detail: b };THREE.PolyhedronGeometry.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], a, b);this.type = \"OctahedronGeometry\";this.parameters = { radius: a, detail: b };\n};THREE.OctahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;\nTHREE.TetrahedronGeometry = function (a, b) {\n  THREE.PolyhedronGeometry.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], a, b);this.type = \"TetrahedronGeometry\";this.parameters = { radius: a, detail: b };\n};THREE.TetrahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);THREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;\nTHREE.ParametricGeometry = function (a, b, c) {\n  THREE.Geometry.call(this);this.type = \"ParametricGeometry\";this.parameters = { func: a, slices: b, stacks: c };var d = this.vertices,\n      e = this.faces,\n      f = this.faceVertexUvs[0],\n      g,\n      h,\n      k,\n      l,\n      p = b + 1;for (g = 0; g <= c; g++) {\n    for (l = g / c, h = 0; h <= b; h++) {\n      k = h / b, k = a(k, l), d.push(k);\n    }\n  }var q, n, t, r;for (g = 0; g < c; g++) {\n    for (h = 0; h < b; h++) {\n      a = g * p + h, d = g * p + h + 1, l = (g + 1) * p + h + 1, k = (g + 1) * p + h, q = new THREE.Vector2(h / b, g / c), n = new THREE.Vector2((h + 1) / b, g / c), t = new THREE.Vector2((h + 1) / b, (g + 1) / c), r = new THREE.Vector2(h / b, (g + 1) / c), e.push(new THREE.Face3(a, d, k)), f.push([q, n, r]), e.push(new THREE.Face3(d, l, k)), f.push([n.clone(), t, r.clone()]);\n    }\n  }this.computeFaceNormals();this.computeVertexNormals();\n};THREE.ParametricGeometry.prototype = Object.create(THREE.Geometry.prototype);THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;\nTHREE.AxisHelper = function (a) {\n  a = a || 1;var b = new Float32Array([0, 0, 0, a, 0, 0, 0, 0, 0, 0, a, 0, 0, 0, 0, 0, 0, a]),\n      c = new Float32Array([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1]);a = new THREE.BufferGeometry();a.addAttribute(\"position\", new THREE.BufferAttribute(b, 3));a.addAttribute(\"color\", new THREE.BufferAttribute(c, 3));b = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors });THREE.Line.call(this, a, b, THREE.LinePieces);\n};THREE.AxisHelper.prototype = Object.create(THREE.Line.prototype);\nTHREE.AxisHelper.prototype.constructor = THREE.AxisHelper;\nTHREE.ArrowHelper = function () {\n  var a = new THREE.Geometry();a.vertices.push(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0));var b = new THREE.CylinderGeometry(0, .5, 1, 5, 1);b.applyMatrix(new THREE.Matrix4().makeTranslation(0, -.5, 0));return function (c, d, e, f, g, h) {\n    THREE.Object3D.call(this);void 0 === f && (f = 16776960);void 0 === e && (e = 1);void 0 === g && (g = .2 * e);void 0 === h && (h = .2 * g);this.position.copy(d);this.line = new THREE.Line(a, new THREE.LineBasicMaterial({ color: f }));this.line.matrixAutoUpdate = !1;this.add(this.line);\n    this.cone = new THREE.Mesh(b, new THREE.MeshBasicMaterial({ color: f }));this.cone.matrixAutoUpdate = !1;this.add(this.cone);this.setDirection(c);this.setLength(e, g, h);\n  };\n}();THREE.ArrowHelper.prototype = Object.create(THREE.Object3D.prototype);THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;\nTHREE.ArrowHelper.prototype.setDirection = function () {\n  var a = new THREE.Vector3(),\n      b;return function (c) {\n    .99999 < c.y ? this.quaternion.set(0, 0, 0, 1) : -.99999 > c.y ? this.quaternion.set(1, 0, 0, 0) : (a.set(c.z, 0, -c.x).normalize(), b = Math.acos(c.y), this.quaternion.setFromAxisAngle(a, b));\n  };\n}();THREE.ArrowHelper.prototype.setLength = function (a, b, c) {\n  void 0 === b && (b = .2 * a);void 0 === c && (c = .2 * b);this.line.scale.set(1, a - b, 1);this.line.updateMatrix();this.cone.scale.set(c, b, c);this.cone.position.y = a;this.cone.updateMatrix();\n};\nTHREE.ArrowHelper.prototype.setColor = function (a) {\n  this.line.material.color.set(a);this.cone.material.color.set(a);\n};THREE.BoxHelper = function (a) {\n  var b = new THREE.BufferGeometry();b.addAttribute(\"position\", new THREE.BufferAttribute(new Float32Array(72), 3));THREE.Line.call(this, b, new THREE.LineBasicMaterial({ color: 16776960 }), THREE.LinePieces);void 0 !== a && this.update(a);\n};THREE.BoxHelper.prototype = Object.create(THREE.Line.prototype);THREE.BoxHelper.prototype.constructor = THREE.BoxHelper;\nTHREE.BoxHelper.prototype.update = function (a) {\n  var b = a.geometry;null === b.boundingBox && b.computeBoundingBox();var c = b.boundingBox.min,\n      b = b.boundingBox.max,\n      d = this.geometry.attributes.position.array;d[0] = b.x;d[1] = b.y;d[2] = b.z;d[3] = c.x;d[4] = b.y;d[5] = b.z;d[6] = c.x;d[7] = b.y;d[8] = b.z;d[9] = c.x;d[10] = c.y;d[11] = b.z;d[12] = c.x;d[13] = c.y;d[14] = b.z;d[15] = b.x;d[16] = c.y;d[17] = b.z;d[18] = b.x;d[19] = c.y;d[20] = b.z;d[21] = b.x;d[22] = b.y;d[23] = b.z;d[24] = b.x;d[25] = b.y;d[26] = c.z;d[27] = c.x;d[28] = b.y;d[29] = c.z;d[30] = c.x;d[31] = b.y;\n  d[32] = c.z;d[33] = c.x;d[34] = c.y;d[35] = c.z;d[36] = c.x;d[37] = c.y;d[38] = c.z;d[39] = b.x;d[40] = c.y;d[41] = c.z;d[42] = b.x;d[43] = c.y;d[44] = c.z;d[45] = b.x;d[46] = b.y;d[47] = c.z;d[48] = b.x;d[49] = b.y;d[50] = b.z;d[51] = b.x;d[52] = b.y;d[53] = c.z;d[54] = c.x;d[55] = b.y;d[56] = b.z;d[57] = c.x;d[58] = b.y;d[59] = c.z;d[60] = c.x;d[61] = c.y;d[62] = b.z;d[63] = c.x;d[64] = c.y;d[65] = c.z;d[66] = b.x;d[67] = c.y;d[68] = b.z;d[69] = b.x;d[70] = c.y;d[71] = c.z;this.geometry.attributes.position.needsUpdate = !0;this.geometry.computeBoundingSphere();this.matrix = a.matrixWorld;\n  this.matrixAutoUpdate = !1;\n};THREE.BoundingBoxHelper = function (a, b) {\n  var c = void 0 !== b ? b : 8947848;this.object = a;this.box = new THREE.Box3();THREE.Mesh.call(this, new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({ color: c, wireframe: !0 }));\n};THREE.BoundingBoxHelper.prototype = Object.create(THREE.Mesh.prototype);THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;THREE.BoundingBoxHelper.prototype.update = function () {\n  this.box.setFromObject(this.object);this.box.size(this.scale);this.box.center(this.position);\n};\nTHREE.CameraHelper = function (a) {\n  function b(a, b, d) {\n    c(a, d);c(b, d);\n  }function c(a, b) {\n    d.vertices.push(new THREE.Vector3());d.colors.push(new THREE.Color(b));void 0 === f[a] && (f[a] = []);f[a].push(d.vertices.length - 1);\n  }var d = new THREE.Geometry(),\n      e = new THREE.LineBasicMaterial({ color: 16777215, vertexColors: THREE.FaceColors }),\n      f = {};b(\"n1\", \"n2\", 16755200);b(\"n2\", \"n4\", 16755200);b(\"n4\", \"n3\", 16755200);b(\"n3\", \"n1\", 16755200);b(\"f1\", \"f2\", 16755200);b(\"f2\", \"f4\", 16755200);b(\"f4\", \"f3\", 16755200);b(\"f3\", \"f1\", 16755200);b(\"n1\", \"f1\", 16755200);\n  b(\"n2\", \"f2\", 16755200);b(\"n3\", \"f3\", 16755200);b(\"n4\", \"f4\", 16755200);b(\"p\", \"n1\", 16711680);b(\"p\", \"n2\", 16711680);b(\"p\", \"n3\", 16711680);b(\"p\", \"n4\", 16711680);b(\"u1\", \"u2\", 43775);b(\"u2\", \"u3\", 43775);b(\"u3\", \"u1\", 43775);b(\"c\", \"t\", 16777215);b(\"p\", \"c\", 3355443);b(\"cn1\", \"cn2\", 3355443);b(\"cn3\", \"cn4\", 3355443);b(\"cf1\", \"cf2\", 3355443);b(\"cf3\", \"cf4\", 3355443);THREE.Line.call(this, d, e, THREE.LinePieces);this.camera = a;this.matrix = a.matrixWorld;this.matrixAutoUpdate = !1;this.pointMap = f;this.update();\n};\nTHREE.CameraHelper.prototype = Object.create(THREE.Line.prototype);THREE.CameraHelper.prototype.constructor = THREE.CameraHelper;\nTHREE.CameraHelper.prototype.update = function () {\n  var a,\n      b,\n      c = new THREE.Vector3(),\n      d = new THREE.Camera(),\n      e = function e(_e, g, h, k) {\n    c.set(g, h, k).unproject(d);_e = b[_e];if (void 0 !== _e) for (g = 0, h = _e.length; g < h; g++) {\n      a.vertices[_e[g]].copy(c);\n    }\n  };return function () {\n    a = this.geometry;b = this.pointMap;d.projectionMatrix.copy(this.camera.projectionMatrix);e(\"c\", 0, 0, -1);e(\"t\", 0, 0, 1);e(\"n1\", -1, -1, -1);e(\"n2\", 1, -1, -1);e(\"n3\", -1, 1, -1);e(\"n4\", 1, 1, -1);e(\"f1\", -1, -1, 1);e(\"f2\", 1, -1, 1);e(\"f3\", -1, 1, 1);e(\"f4\", 1, 1, 1);e(\"u1\", .7, 1.1, -1);e(\"u2\", -.7, 1.1, -1);e(\"u3\", 0, 2, -1);e(\"cf1\", -1, 0, 1);e(\"cf2\", 1, 0, 1);e(\"cf3\", 0, -1, 1);e(\"cf4\", 0, 1, 1);e(\"cn1\", -1, 0, -1);e(\"cn2\", 1, 0, -1);e(\"cn3\", 0, -1, -1);e(\"cn4\", 0, 1, -1);a.verticesNeedUpdate = !0;\n  };\n}();\nTHREE.DirectionalLightHelper = function (a, b) {\n  THREE.Object3D.call(this);this.light = a;this.light.updateMatrixWorld();this.matrix = a.matrixWorld;this.matrixAutoUpdate = !1;b = b || 1;var c = new THREE.Geometry();c.vertices.push(new THREE.Vector3(-b, b, 0), new THREE.Vector3(b, b, 0), new THREE.Vector3(b, -b, 0), new THREE.Vector3(-b, -b, 0), new THREE.Vector3(-b, b, 0));var d = new THREE.LineBasicMaterial({ fog: !1 });d.color.copy(this.light.color).multiplyScalar(this.light.intensity);this.lightPlane = new THREE.Line(c, d);this.add(this.lightPlane);\n  c = new THREE.Geometry();c.vertices.push(new THREE.Vector3(), new THREE.Vector3());d = new THREE.LineBasicMaterial({ fog: !1 });d.color.copy(this.light.color).multiplyScalar(this.light.intensity);this.targetLine = new THREE.Line(c, d);this.add(this.targetLine);this.update();\n};THREE.DirectionalLightHelper.prototype = Object.create(THREE.Object3D.prototype);THREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;\nTHREE.DirectionalLightHelper.prototype.dispose = function () {\n  this.lightPlane.geometry.dispose();this.lightPlane.material.dispose();this.targetLine.geometry.dispose();this.targetLine.material.dispose();\n};\nTHREE.DirectionalLightHelper.prototype.update = function () {\n  var a = new THREE.Vector3(),\n      b = new THREE.Vector3(),\n      c = new THREE.Vector3();return function () {\n    a.setFromMatrixPosition(this.light.matrixWorld);b.setFromMatrixPosition(this.light.target.matrixWorld);c.subVectors(b, a);this.lightPlane.lookAt(c);this.lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);this.targetLine.geometry.vertices[1].copy(c);this.targetLine.geometry.verticesNeedUpdate = !0;this.targetLine.material.color.copy(this.lightPlane.material.color);\n  };\n}();\nTHREE.EdgesHelper = function (a, b, c) {\n  b = void 0 !== b ? b : 16777215;c = Math.cos(THREE.Math.degToRad(void 0 !== c ? c : 1));var d = [0, 0],\n      e = {},\n      f = function f(a, b) {\n    return a - b;\n  },\n      g = [\"a\", \"b\", \"c\"],\n      h = new THREE.BufferGeometry(),\n      k;a.geometry instanceof THREE.BufferGeometry ? (k = new THREE.Geometry(), k.fromBufferGeometry(a.geometry)) : k = a.geometry.clone();k.mergeVertices();k.computeFaceNormals();var l = k.vertices;k = k.faces;for (var p = 0, q = 0, n = k.length; q < n; q++) {\n    for (var t = k[q], r = 0; 3 > r; r++) {\n      d[0] = t[g[r]];d[1] = t[g[(r + 1) % 3]];d.sort(f);var s = d.toString();\n      void 0 === e[s] ? (e[s] = { vert1: d[0], vert2: d[1], face1: q, face2: void 0 }, p++) : e[s].face2 = q;\n    }\n  }d = new Float32Array(6 * p);f = 0;for (s in e) {\n    if (g = e[s], void 0 === g.face2 || k[g.face1].normal.dot(k[g.face2].normal) <= c) p = l[g.vert1], d[f++] = p.x, d[f++] = p.y, d[f++] = p.z, p = l[g.vert2], d[f++] = p.x, d[f++] = p.y, d[f++] = p.z;\n  }h.addAttribute(\"position\", new THREE.BufferAttribute(d, 3));THREE.Line.call(this, h, new THREE.LineBasicMaterial({ color: b }), THREE.LinePieces);this.matrix = a.matrixWorld;this.matrixAutoUpdate = !1;\n};\nTHREE.EdgesHelper.prototype = Object.create(THREE.Line.prototype);THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;\nTHREE.FaceNormalsHelper = function (a, b, c, d) {\n  this.object = a;this.size = void 0 !== b ? b : 1;a = void 0 !== c ? c : 16776960;d = void 0 !== d ? d : 1;b = new THREE.Geometry();c = 0;for (var e = this.object.geometry.faces.length; c < e; c++) {\n    b.vertices.push(new THREE.Vector3(), new THREE.Vector3());\n  }THREE.Line.call(this, b, new THREE.LineBasicMaterial({ color: a, linewidth: d }), THREE.LinePieces);this.matrixAutoUpdate = !1;this.normalMatrix = new THREE.Matrix3();this.update();\n};THREE.FaceNormalsHelper.prototype = Object.create(THREE.Line.prototype);\nTHREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;\nTHREE.FaceNormalsHelper.prototype.update = function () {\n  var a = this.geometry.vertices,\n      b = this.object,\n      c = b.geometry.vertices,\n      d = b.geometry.faces,\n      e = b.matrixWorld;b.updateMatrixWorld(!0);this.normalMatrix.getNormalMatrix(e);for (var f = b = 0, g = d.length; b < g; b++, f += 2) {\n    var h = d[b];a[f].copy(c[h.a]).add(c[h.b]).add(c[h.c]).divideScalar(3).applyMatrix4(e);a[f + 1].copy(h.normal).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size).add(a[f]);\n  }this.geometry.verticesNeedUpdate = !0;return this;\n};\nTHREE.GridHelper = function (a, b) {\n  var c = new THREE.Geometry(),\n      d = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors });this.color1 = new THREE.Color(4473924);this.color2 = new THREE.Color(8947848);for (var e = -a; e <= a; e += b) {\n    c.vertices.push(new THREE.Vector3(-a, 0, e), new THREE.Vector3(a, 0, e), new THREE.Vector3(e, 0, -a), new THREE.Vector3(e, 0, a));var f = 0 === e ? this.color1 : this.color2;c.colors.push(f, f, f, f);\n  }THREE.Line.call(this, c, d, THREE.LinePieces);\n};THREE.GridHelper.prototype = Object.create(THREE.Line.prototype);\nTHREE.GridHelper.prototype.constructor = THREE.GridHelper;THREE.GridHelper.prototype.setColors = function (a, b) {\n  this.color1.set(a);this.color2.set(b);this.geometry.colorsNeedUpdate = !0;\n};\nTHREE.HemisphereLightHelper = function (a, b) {\n  THREE.Object3D.call(this);this.light = a;this.light.updateMatrixWorld();this.matrix = a.matrixWorld;this.matrixAutoUpdate = !1;this.colors = [new THREE.Color(), new THREE.Color()];var c = new THREE.SphereGeometry(b, 4, 2);c.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));for (var d = 0; 8 > d; d++) {\n    c.faces[d].color = this.colors[4 > d ? 0 : 1];\n  }d = new THREE.MeshBasicMaterial({ vertexColors: THREE.FaceColors, wireframe: !0 });this.lightSphere = new THREE.Mesh(c, d);this.add(this.lightSphere);\n  this.update();\n};THREE.HemisphereLightHelper.prototype = Object.create(THREE.Object3D.prototype);THREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;THREE.HemisphereLightHelper.prototype.dispose = function () {\n  this.lightSphere.geometry.dispose();this.lightSphere.material.dispose();\n};\nTHREE.HemisphereLightHelper.prototype.update = function () {\n  var a = new THREE.Vector3();return function () {\n    this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity);this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity);this.lightSphere.lookAt(a.setFromMatrixPosition(this.light.matrixWorld).negate());this.lightSphere.geometry.colorsNeedUpdate = !0;\n  };\n}();\nTHREE.PointLightHelper = function (a, b) {\n  this.light = a;this.light.updateMatrixWorld();var c = new THREE.SphereGeometry(b, 4, 2),\n      d = new THREE.MeshBasicMaterial({ wireframe: !0, fog: !1 });d.color.copy(this.light.color).multiplyScalar(this.light.intensity);THREE.Mesh.call(this, c, d);this.matrix = this.light.matrixWorld;this.matrixAutoUpdate = !1;\n};THREE.PointLightHelper.prototype = Object.create(THREE.Mesh.prototype);THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;\nTHREE.PointLightHelper.prototype.dispose = function () {\n  this.geometry.dispose();this.material.dispose();\n};THREE.PointLightHelper.prototype.update = function () {\n  this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);\n};\nTHREE.SkeletonHelper = function (a) {\n  this.bones = this.getBoneList(a);for (var b = new THREE.Geometry(), c = 0; c < this.bones.length; c++) {\n    this.bones[c].parent instanceof THREE.Bone && (b.vertices.push(new THREE.Vector3()), b.vertices.push(new THREE.Vector3()), b.colors.push(new THREE.Color(0, 0, 1)), b.colors.push(new THREE.Color(0, 1, 0)));\n  }c = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors, depthTest: !1, depthWrite: !1, transparent: !0 });THREE.Line.call(this, b, c, THREE.LinePieces);this.root = a;this.matrix = a.matrixWorld;\n  this.matrixAutoUpdate = !1;this.update();\n};THREE.SkeletonHelper.prototype = Object.create(THREE.Line.prototype);THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;THREE.SkeletonHelper.prototype.getBoneList = function (a) {\n  var b = [];a instanceof THREE.Bone && b.push(a);for (var c = 0; c < a.children.length; c++) {\n    b.push.apply(b, this.getBoneList(a.children[c]));\n  }return b;\n};\nTHREE.SkeletonHelper.prototype.update = function () {\n  for (var a = this.geometry, b = new THREE.Matrix4().getInverse(this.root.matrixWorld), c = new THREE.Matrix4(), d = 0, e = 0; e < this.bones.length; e++) {\n    var f = this.bones[e];f.parent instanceof THREE.Bone && (c.multiplyMatrices(b, f.matrixWorld), a.vertices[d].setFromMatrixPosition(c), c.multiplyMatrices(b, f.parent.matrixWorld), a.vertices[d + 1].setFromMatrixPosition(c), d += 2);\n  }a.verticesNeedUpdate = !0;a.computeBoundingSphere();\n};\nTHREE.SpotLightHelper = function (a) {\n  THREE.Object3D.call(this);this.light = a;this.light.updateMatrixWorld();this.matrix = a.matrixWorld;this.matrixAutoUpdate = !1;a = new THREE.CylinderGeometry(0, 1, 1, 8, 1, !0);a.applyMatrix(new THREE.Matrix4().makeTranslation(0, -.5, 0));a.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));var b = new THREE.MeshBasicMaterial({ wireframe: !0, fog: !1 });this.cone = new THREE.Mesh(a, b);this.add(this.cone);this.update();\n};THREE.SpotLightHelper.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;THREE.SpotLightHelper.prototype.dispose = function () {\n  this.cone.geometry.dispose();this.cone.material.dispose();\n};\nTHREE.SpotLightHelper.prototype.update = function () {\n  var a = new THREE.Vector3(),\n      b = new THREE.Vector3();return function () {\n    var c = this.light.distance ? this.light.distance : 1E4,\n        d = c * Math.tan(this.light.angle);this.cone.scale.set(d, d, c);a.setFromMatrixPosition(this.light.matrixWorld);b.setFromMatrixPosition(this.light.target.matrixWorld);this.cone.lookAt(b.sub(a));this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);\n  };\n}();\nTHREE.VertexNormalsHelper = function (a, b, c, d) {\n  this.object = a;this.size = void 0 !== b ? b : 1;b = void 0 !== c ? c : 16711680;d = void 0 !== d ? d : 1;c = new THREE.Geometry();a = a.geometry.faces;for (var e = 0, f = a.length; e < f; e++) {\n    for (var g = 0, h = a[e].vertexNormals.length; g < h; g++) {\n      c.vertices.push(new THREE.Vector3(), new THREE.Vector3());\n    }\n  }THREE.Line.call(this, c, new THREE.LineBasicMaterial({ color: b, linewidth: d }), THREE.LinePieces);this.matrixAutoUpdate = !1;this.normalMatrix = new THREE.Matrix3();this.update();\n};THREE.VertexNormalsHelper.prototype = Object.create(THREE.Line.prototype);\nTHREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;\nTHREE.VertexNormalsHelper.prototype.update = function (a) {\n  var b = new THREE.Vector3();return function (a) {\n    a = [\"a\", \"b\", \"c\", \"d\"];this.object.updateMatrixWorld(!0);this.normalMatrix.getNormalMatrix(this.object.matrixWorld);for (var d = this.geometry.vertices, e = this.object.geometry.vertices, f = this.object.geometry.faces, g = this.object.matrixWorld, h = 0, k = 0, l = f.length; k < l; k++) {\n      for (var p = f[k], q = 0, n = p.vertexNormals.length; q < n; q++) {\n        var t = p.vertexNormals[q];d[h].copy(e[p[a[q]]]).applyMatrix4(g);b.copy(t).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size);\n        b.add(d[h]);h += 1;d[h].copy(b);h += 1;\n      }\n    }this.geometry.verticesNeedUpdate = !0;return this;\n  };\n}();\nTHREE.VertexTangentsHelper = function (a, b, c, d) {\n  this.object = a;this.size = void 0 !== b ? b : 1;b = void 0 !== c ? c : 255;d = void 0 !== d ? d : 1;c = new THREE.Geometry();a = a.geometry.faces;for (var e = 0, f = a.length; e < f; e++) {\n    for (var g = 0, h = a[e].vertexTangents.length; g < h; g++) {\n      c.vertices.push(new THREE.Vector3()), c.vertices.push(new THREE.Vector3());\n    }\n  }THREE.Line.call(this, c, new THREE.LineBasicMaterial({ color: b, linewidth: d }), THREE.LinePieces);this.matrixAutoUpdate = !1;this.update();\n};THREE.VertexTangentsHelper.prototype = Object.create(THREE.Line.prototype);\nTHREE.VertexTangentsHelper.prototype.constructor = THREE.VertexTangentsHelper;\nTHREE.VertexTangentsHelper.prototype.update = function (a) {\n  var b = new THREE.Vector3();return function (a) {\n    a = [\"a\", \"b\", \"c\", \"d\"];this.object.updateMatrixWorld(!0);for (var d = this.geometry.vertices, e = this.object.geometry.vertices, f = this.object.geometry.faces, g = this.object.matrixWorld, h = 0, k = 0, l = f.length; k < l; k++) {\n      for (var p = f[k], q = 0, n = p.vertexTangents.length; q < n; q++) {\n        var t = p.vertexTangents[q];d[h].copy(e[p[a[q]]]).applyMatrix4(g);b.copy(t).transformDirection(g).multiplyScalar(this.size);b.add(d[h]);h += 1;d[h].copy(b);\n        h += 1;\n      }\n    }this.geometry.verticesNeedUpdate = !0;return this;\n  };\n}();\nTHREE.WireframeHelper = function (a, b) {\n  var c = void 0 !== b ? b : 16777215,\n      d = [0, 0],\n      e = {},\n      f = function f(a, b) {\n    return a - b;\n  },\n      g = [\"a\", \"b\", \"c\"],\n      h = new THREE.BufferGeometry();if (a.geometry instanceof THREE.Geometry) {\n    for (var k = a.geometry.vertices, l = a.geometry.faces, p = 0, q = new Uint32Array(6 * l.length), n = 0, t = l.length; n < t; n++) {\n      for (var r = l[n], s = 0; 3 > s; s++) {\n        d[0] = r[g[s]];d[1] = r[g[(s + 1) % 3]];d.sort(f);var u = d.toString();void 0 === e[u] && (q[2 * p] = d[0], q[2 * p + 1] = d[1], e[u] = !0, p++);\n      }\n    }d = new Float32Array(6 * p);n = 0;for (t = p; n < t; n++) {\n      for (s = 0; 2 > s; s++) {\n        p = k[q[2 * n + s]], g = 6 * n + 3 * s, d[g + 0] = p.x, d[g + 1] = p.y, d[g + 2] = p.z;\n      }\n    }h.addAttribute(\"position\", new THREE.BufferAttribute(d, 3));\n  } else if (a.geometry instanceof THREE.BufferGeometry) {\n    if (void 0 !== a.geometry.attributes.index) {\n      k = a.geometry.attributes.position.array;t = a.geometry.attributes.index.array;l = a.geometry.drawcalls;p = 0;0 === l.length && (l = [{ count: t.length, index: 0, start: 0 }]);for (var q = new Uint32Array(2 * t.length), r = 0, v = l.length; r < v; ++r) {\n        for (var s = l[r].start, u = l[r].count, g = l[r].index, n = s, x = s + u; n < x; n += 3) {\n          for (s = 0; 3 > s; s++) {\n            d[0] = g + t[n + s], d[1] = g + t[n + (s + 1) % 3], d.sort(f), u = d.toString(), void 0 === e[u] && (q[2 * p] = d[0], q[2 * p + 1] = d[1], e[u] = !0, p++);\n          }\n        }\n      }d = new Float32Array(6 * p);n = 0;for (t = p; n < t; n++) {\n        for (s = 0; 2 > s; s++) {\n          g = 6 * n + 3 * s, p = 3 * q[2 * n + s], d[g + 0] = k[p], d[g + 1] = k[p + 1], d[g + 2] = k[p + 2];\n        }\n      }\n    } else for (k = a.geometry.attributes.position.array, p = k.length / 3, q = p / 3, d = new Float32Array(6 * p), n = 0, t = q; n < t; n++) {\n      for (s = 0; 3 > s; s++) {\n        g = 18 * n + 6 * s, q = 9 * n + 3 * s, d[g + 0] = k[q], d[g + 1] = k[q + 1], d[g + 2] = k[q + 2], p = 9 * n + (s + 1) % 3 * 3, d[g + 3] = k[p], d[g + 4] = k[p + 1], d[g + 5] = k[p + 2];\n      }\n    }h.addAttribute(\"position\", new THREE.BufferAttribute(d, 3));\n  }THREE.Line.call(this, h, new THREE.LineBasicMaterial({ color: c }), THREE.LinePieces);this.matrix = a.matrixWorld;this.matrixAutoUpdate = !1;\n};THREE.WireframeHelper.prototype = Object.create(THREE.Line.prototype);THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;THREE.ImmediateRenderObject = function () {\n  THREE.Object3D.call(this);this.render = function (a) {};\n};THREE.ImmediateRenderObject.prototype = Object.create(THREE.Object3D.prototype);THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;\nTHREE.MorphBlendMesh = function (a, b) {\n  THREE.Mesh.call(this, a, b);this.animationsMap = {};this.animationsList = [];var c = this.geometry.morphTargets.length;this.createAnimation(\"__default\", 0, c - 1, c / 1);this.setAnimationWeight(\"__default\", 1);\n};THREE.MorphBlendMesh.prototype = Object.create(THREE.Mesh.prototype);THREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;\nTHREE.MorphBlendMesh.prototype.createAnimation = function (a, b, c, d) {\n  b = { startFrame: b, endFrame: c, length: c - b + 1, fps: d, duration: (c - b) / d, lastFrame: 0, currentFrame: 0, active: !1, time: 0, direction: 1, weight: 1, directionBackwards: !1, mirroredLoop: !1 };this.animationsMap[a] = b;this.animationsList.push(b);\n};\nTHREE.MorphBlendMesh.prototype.autoCreateAnimations = function (a) {\n  for (var b = /([a-z]+)_?(\\d+)/, c, d = {}, e = this.geometry, f = 0, g = e.morphTargets.length; f < g; f++) {\n    var h = e.morphTargets[f].name.match(b);if (h && 1 < h.length) {\n      var k = h[1];d[k] || (d[k] = { start: Infinity, end: -Infinity });h = d[k];f < h.start && (h.start = f);f > h.end && (h.end = f);c || (c = k);\n    }\n  }for (k in d) {\n    h = d[k], this.createAnimation(k, h.start, h.end, a);\n  }this.firstAnimation = c;\n};\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function (a) {\n  if (a = this.animationsMap[a]) a.direction = 1, a.directionBackwards = !1;\n};THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function (a) {\n  if (a = this.animationsMap[a]) a.direction = -1, a.directionBackwards = !0;\n};THREE.MorphBlendMesh.prototype.setAnimationFPS = function (a, b) {\n  var c = this.animationsMap[a];c && (c.fps = b, c.duration = (c.end - c.start) / c.fps);\n};\nTHREE.MorphBlendMesh.prototype.setAnimationDuration = function (a, b) {\n  var c = this.animationsMap[a];c && (c.duration = b, c.fps = (c.end - c.start) / c.duration);\n};THREE.MorphBlendMesh.prototype.setAnimationWeight = function (a, b) {\n  var c = this.animationsMap[a];c && (c.weight = b);\n};THREE.MorphBlendMesh.prototype.setAnimationTime = function (a, b) {\n  var c = this.animationsMap[a];c && (c.time = b);\n};THREE.MorphBlendMesh.prototype.getAnimationTime = function (a) {\n  var b = 0;if (a = this.animationsMap[a]) b = a.time;return b;\n};\nTHREE.MorphBlendMesh.prototype.getAnimationDuration = function (a) {\n  var b = -1;if (a = this.animationsMap[a]) b = a.duration;return b;\n};THREE.MorphBlendMesh.prototype.playAnimation = function (a) {\n  var b = this.animationsMap[a];b ? (b.time = 0, b.active = !0) : THREE.warn(\"THREE.MorphBlendMesh: animation[\" + a + \"] undefined in .playAnimation()\");\n};THREE.MorphBlendMesh.prototype.stopAnimation = function (a) {\n  if (a = this.animationsMap[a]) a.active = !1;\n};\nTHREE.MorphBlendMesh.prototype.update = function (a) {\n  for (var b = 0, c = this.animationsList.length; b < c; b++) {\n    var d = this.animationsList[b];if (d.active) {\n      var e = d.duration / d.length;d.time += d.direction * a;if (d.mirroredLoop) {\n        if (d.time > d.duration || 0 > d.time) d.direction *= -1, d.time > d.duration && (d.time = d.duration, d.directionBackwards = !0), 0 > d.time && (d.time = 0, d.directionBackwards = !1);\n      } else d.time %= d.duration, 0 > d.time && (d.time += d.duration);var f = d.startFrame + THREE.Math.clamp(Math.floor(d.time / e), 0, d.length - 1),\n          g = d.weight;\n      f !== d.currentFrame && (this.morphTargetInfluences[d.lastFrame] = 0, this.morphTargetInfluences[d.currentFrame] = 1 * g, this.morphTargetInfluences[f] = 0, d.lastFrame = d.currentFrame, d.currentFrame = f);e = d.time % e / e;d.directionBackwards && (e = 1 - e);this.morphTargetInfluences[d.currentFrame] = e * g;this.morphTargetInfluences[d.lastFrame] = (1 - e) * g;\n    }\n  }\n};\n"]}